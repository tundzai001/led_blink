import tkinter as tk
from tkinter import messagebox, filedialog, Toplevel
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tksheet import Sheet
import paho.mqtt.client as mqtt
import json
from datetime import datetime, timedelta
import threading
import time
import warnings
import configparser
import signal
import os
import sys
import queue
from collections import deque
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt
import numpy as np
import logging
from logging.handlers import TimedRotatingFileHandler
import atexit
import subprocess
import psutil
import math 
import traceback

# Bỏ qua cảnh báo không cần thiết và thiết lập môi trường
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1"
warnings.filterwarnings("ignore", category=DeprecationWarning)

# --- CÁC THƯ VIỆN ĐẶC THÙ PI ---
import RPi.GPIO as GPIO
import pygame

# --- Cấu hình logging ---
logger = logging.getLogger()
logger.setLevel(logging.INFO)
info_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
info_handler = TimedRotatingFileHandler('sensor_monitor_info.log', when='midnight', interval=1, backupCount=1, encoding='utf-8')
info_handler.setLevel(logging.INFO)
info_handler.setFormatter(info_formatter)
info_handler.addFilter(lambda record: record.levelno < logging.ERROR)
logger.addHandler(info_handler)
error_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(pathname)s:%(lineno)d - %(message)s')
error_handler = TimedRotatingFileHandler('sensor_monitor_error.log', when='midnight', interval=1, backupCount=30, encoding='utf-8')
error_handler.setLevel(logging.ERROR)
error_handler.setFormatter(error_formatter)
logger.addHandler(error_handler)
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
console_handler.setFormatter(console_formatter)
logger.addHandler(console_handler)

# ==============================================================================
# QUẢN LÝ HẰNG SỐ
# ==============================================================================
class Constants:
    CONFIG_FILE = 'config.ini'
    SESSION_FILE = "session.json"
    SHIFTING_PID_FILE = "shifting.pid"
    WATER_SOUNDS_DIR = "/home/vippro123/Desktop/code/sounds/water"
    GNSS_SOUNDS_DIR = "/home/vippro123/Desktop/code/sounds/gnss"
    LED1_PIN = 3
    LED2_PIN = 27
    MAX_PLOT_POINTS = 10000
    MAX_SENSOR_RECORDS = 10000
    CHART_POINTS_PER_VIEW = 40
    DEFAULT_BROKER = "aitogy.xyz"
    DEFAULT_PORT = 1883
    DEFAULT_USER = "abc"
    DEFAULT_PASS = "xyz"
    DEFAULT_WARN_THRESHOLD = 1.0
    DEFAULT_CRIT_THRESHOLD = 1.2
    DATA_CLEAR_SIGNAL = "CLEAR_ALL_DATA"
    WARNING_REPEAT_INTERVAL = 6
    DECREASING_REPEAT_INTERVAL = 10
    SAFE_READINGS_REQUIRED_INITIAL = 10
    SAFE_READINGS_REQUIRED_RETURN_1 = 10
    SAFE_READINGS_REQUIRED_RETURN_2 = 15

# ==============================================================================
# LỚP LOGIC NỀN (BACKEND) - PHIÊN BẢN BỘ CHỈ HUY
# ==============================================================================
class Backend:
    def __init__(self):
        # --- Trạng thái hoạt động ---
        self.listening = False
        self.exiting = False
        self.status_text = "Trạng thái: THỦ CÔNG"
        self.status_color = "red"
        
        # --- Cấu hình ---
        self.config = configparser.ConfigParser()
        self.broker = Constants.DEFAULT_BROKER
        self.port = Constants.DEFAULT_PORT
        self.username = Constants.DEFAULT_USER
        self.password = Constants.DEFAULT_PASS
        self.water_topics = []
        self.gnss_topics = []
        self.warning_threshold = Constants.DEFAULT_WARN_THRESHOLD
        self.critical_threshold = Constants.DEFAULT_CRIT_THRESHOLD
        
        # --- Âm thanh (vẫn giữ lại để có thể phát theo lệnh từ shifting.py sau này) ---
        self.mixer_initialized = False
        self.siren_sound = None
        self.critical_sound = None
        # (Thêm các âm thanh khác nếu cần)

        # --- Quản lý tiến trình con shifting.py ---
        self.shifting_process = None
        self.last_shifting_heartbeat = time.time()
        
        # --- Lưu trữ trạng thái và dữ liệu ---
        self.gui_update_queue = queue.Queue()
        self.latest_full_report = {}  # Lưu báo cáo JSON đầy đủ cuối cùng
        
        # Các bộ đệm lịch sử mới để vẽ biểu đồ
        self.displacement_history = deque(maxlen=Constants.MAX_PLOT_POINTS)
        self.water_level_history = deque(maxlen=Constants.MAX_PLOT_POINTS)
        self.anomaly_score_history = deque(maxlen=Constants.MAX_PLOT_POINTS)
        self.threat_score_history = deque(maxlen=Constants.MAX_PLOT_POINTS)

        # --- Khởi tạo ---
        self._cleanup_old_shifting_process()
        self.setup_audio_mixer() # Vẫn có thể setup audio
        self.setup_gpio()
        self.load_config()

        self._shifting_liveness_thread = threading.Thread(target=self._check_shifting_liveness, daemon=True)
        self._shifting_liveness_thread.start()

        atexit.register(self.cleanup_on_exit)

    def _check_shifting_liveness(self):
        HEARTBEAT_TIMEOUT = 90  # Giới hạn chờ 90 giây
        while not self.exiting:
            if self.listening and self.shifting_process and self.shifting_process.poll() is None:
                time_since_last_heartbeat = time.time() - self.last_shifting_heartbeat
                if time_since_last_heartbeat > HEARTBEAT_TIMEOUT:
                    logger.critical("Không nhận được nhịp tim từ shifting.py! Có thể nó đã bị treo. Đang khởi động lại...")
                    self.stop_shifting_process()
                    time.sleep(2)
                    self.start_shifting_process()
            time.sleep(30) # Giảm tần suất kiểm tra để nhẹ hệ thống

    def _cleanup_old_shifting_process(self):
        pid_file = Constants.SHIFTING_PID_FILE
        if os.path.exists(pid_file):
            try:
                with open(pid_file, 'r') as f:
                    old_pid = int(f.read().strip())
                if psutil.pid_exists(old_pid):
                    logger.warning(f"Phát hiện tiến trình shifting.py mồ côi với PID {old_pid}. Đang dừng nó...")
                    process = psutil.Process(old_pid)
                    process.kill()
                    logger.info("Đã dừng tiến trình mồ côi thành công.")
            except (ValueError, psutil.NoSuchProcess, psutil.AccessDenied) as e:
                logger.warning(f"Lỗi khi dọn dẹp tiến trình cũ: {e}")
            finally:
                if os.path.exists(pid_file):
                    os.remove(pid_file)

    def start_shifting_process(self):
        if self.shifting_process and self.shifting_process.poll() is None:
            logger.info("Tiến trình shifting.py đã đang chạy.")
            return

        if not self.gnss_topics and not self.water_topics:
            logger.warning("Chưa cấu hình topic. Không khởi động shifting.py.")
            self.status_text, self.status_color = "LỖI: CHƯA CÓ TOPIC", "red"
            self.listening = False
            return
        
        try:
            command = [
                sys.executable, '-u', 'shifting.py',
                '--broker', self.broker,
                '--port', str(self.port),
                '--pid-file', Constants.SHIFTING_PID_FILE,
                '--water-warn-threshold', str(self.warning_threshold),
                '--water-crit-threshold', str(self.critical_threshold),
            ]
            
            if self.username: command.extend(['--username', self.username])
            if self.password: command.extend(['--password', self.password])

            for topic in self.gnss_topics:
                command.extend(['--gnss-topic', topic])
            
            for topic in self.water_topics:
                command.extend(['--water-topic', topic])
            
            logger.info(f"Đang khởi chạy shifting.py với lệnh: {' '.join(command)}")

            self.shifting_process = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                encoding='utf-8',
                bufsize=1,
                universal_newlines=True
            )
            
            threading.Thread(target=self._read_shifting_output, args=(self.shifting_process.stdout,), daemon=True).start()
            threading.Thread(target=self._log_process_errors, args=(self.shifting_process.stderr,), daemon=True).start()
            
            logger.info("Đã khởi động tiến trình shifting.py và các luồng giám sát.")
            self.status_text, self.status_color = "Trạng thái: TỰ ĐỘNG", "green"

        except Exception as e:
            logger.error(f"Lỗi nghiêm trọng khi khởi động shifting.py: {e}\n{traceback.format_exc()}")
            if self.shifting_process: self.shifting_process.kill()
            self.shifting_process = None
            self.status_text, self.status_color = "LỖI KHỞI ĐỘNG SHIFTING", "red"
            self.listening = False

    def _log_process_errors(self, pipe):
        for line in iter(pipe.readline, ''):
            logger.error(f"[SHIFTING_STDERR]: {line.strip()}")

    def _read_shifting_output(self, pipe):
        for line in iter(pipe.readline, ''):
            if self.exiting: break
            
            line_str = line.strip()
            if not line_str: continue

            try:
                data = json.loads(line_str)
                packet_type = data.get("type")

                if packet_type in ["ASTCS_ANALYSIS_REPORT", "HEARTBEAT"]:
                    self.gui_update_queue.put((packet_type, data))
                    self.last_shifting_heartbeat = time.time()
                
            except json.JSONDecodeError:
                logger.warning(f"Nhận được dòng không phải JSON từ shifting.py: {line_str}")
            except Exception as e:
                logger.error(f"Lỗi trong luồng đọc shifting.py: {e}")
        
        logger.info("Luồng đọc kết quả từ shifting.py đã dừng.")

    def stop_shifting_process(self):
        if self.shifting_process and self.shifting_process.poll() is None:
            try:
                logger.info("Đang dừng tiến trình shifting.py...")
                self.shifting_process.terminate()
                self.shifting_process.wait(timeout=5)
                logger.info("Đã dừng thành công tiến trình shifting.py.")
            except subprocess.TimeoutExpired:
                logger.warning("Tiến trình shifting.py không phản hồi, buộc dừng (kill).")
                self.shifting_process.kill()
            except Exception as e:
                logger.error(f"Lỗi khi dừng shifting.py: {e}")
        self.shifting_process = None

    def setup_audio_mixer(self):
        try:
            pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=4096)
            self.mixer_initialized = True
            logger.info("Pygame mixer đã khởi tạo thành công.")
            # Load âm thanh ở đây nếu cần
            # self.siren_sound = pygame.mixer.Sound(...)
        except Exception as e:
            logger.error(f"Không thể khởi tạo pygame mixer: {e}")
            self.mixer_initialized = False

    def play_sound_by_name(self, sound_name):
        """Hàm này có thể được gọi để phát âm thanh dựa trên lệnh từ GUI."""
        if not self.mixer_initialized: return
        # Thêm logic để chọn và phát âm thanh
        if sound_name == "siren":
            # self.siren_sound.play()
            pass
        logger.info(f"Đã nhận lệnh phát âm thanh: {sound_name}")

    def update_and_reconnect(self, settings: dict):
        self.broker = settings['broker']
        self.port = int(settings['port'])
        self.username = settings['username']
        self.password = settings['password']
        self.water_topics = [t.strip() for t in settings.get('water_topics', '').splitlines() if t.strip()]
        self.gnss_topics = [t.strip() for t in settings.get('gnss_topics', '').splitlines() if t.strip()]
        self.warning_threshold = float(settings['warning_threshold'])
        self.critical_threshold = float(settings['critical_threshold'])
        
        self.save_config()

        if self.listening:
            logger.info("Phát hiện thay đổi cấu hình, đang khởi động lại shifting.py với thiết lập mới...")
            self.stop_shifting_process()
            time.sleep(1)
            self.start_shifting_process()

    def load_config(self):
        if not os.path.exists(Constants.CONFIG_FILE):
            logger.warning(f"File cấu hình '{Constants.CONFIG_FILE}' không tồn tại. Sử dụng giá trị mặc định.")
            return
        try:
            self.config.read(Constants.CONFIG_FILE, encoding='utf-8')
            if "MQTT" in self.config:
                mqtt_cfg = self.config['MQTT']
                self.broker = mqtt_cfg.get("broker", Constants.DEFAULT_BROKER)
                self.port = mqtt_cfg.getint("port", Constants.DEFAULT_PORT)
                self.username = mqtt_cfg.get("username", Constants.DEFAULT_USER)
                self.password = mqtt_cfg.get("password", Constants.DEFAULT_PASS)
                self.water_topics = [t.strip() for t in mqtt_cfg.get("water_sub_topic", "").splitlines() if t.strip()]
                self.gnss_topics = [t.strip() for t in mqtt_cfg.get("gnss_sub_topic", "").splitlines() if t.strip()]
            if "Settings" in self.config:
                settings_cfg = self.config['Settings']
                self.warning_threshold = settings_cfg.getfloat("warning_threshold", Constants.DEFAULT_WARN_THRESHOLD)
                self.critical_threshold = settings_cfg.getfloat("critical_threshold", Constants.DEFAULT_CRIT_THRESHOLD)
        except Exception as e:
            logger.error(f"Lỗi tải cấu hình: {e}")

    def save_config(self):
        try:
            self.config['MQTT'] = {
                'broker': self.broker, 'port': self.port, 'username': self.username,
                'password': self.password,
                'water_sub_topic': "\n".join(self.water_topics),
                'gnss_sub_topic': "\n".join(self.gnss_topics),
            }
            self.config['Settings'] = {
                'warning_threshold': self.warning_threshold,
                'critical_threshold': self.critical_threshold
            }
            with open(Constants.CONFIG_FILE, 'w', encoding='utf-8') as f:
                self.config.write(f)
            logger.info("Đã lưu cấu hình.")
        except Exception as e:
            logger.error(f"Lỗi lưu cấu hình: {e}")

    def cleanup_on_exit(self):
        if self.exiting: return
        logger.info("Bắt đầu quá trình dọn dẹp để thoát...")
        self.exiting = True
        self.stop_shifting_process()
        GPIO.cleanup()
        logger.info("Backend đã dừng.")

    def setup_gpio(self):
        try:
            GPIO.setmode(GPIO.BCM)
            GPIO.setwarnings(False)
            GPIO.setup(Constants.LED1_PIN, GPIO.OUT, initial=GPIO.LOW)
            GPIO.setup(Constants.LED2_PIN, GPIO.OUT, initial=GPIO.LOW)
            logger.info("GPIO setup successful.")
        except Exception as e:
            logger.error(f"Lỗi khi cài đặt GPIO: {e}. Vui lòng chạy với quyền sudo.")

    def flash_led(self, pin, duration=0.3):
        try:
            GPIO.output(pin, GPIO.HIGH)
            time.sleep(duration)
            GPIO.output(pin, GPIO.LOW)
        except Exception as e:
            logger.error(f"Lỗi nháy LED trên pin {pin}: {e}")

    def toggle_on(self):
        if self.listening: return
        self.listening = True
        self.status_text = "Trạng thái: ĐANG KHỞI ĐỘNG..."
        self.status_color = "orange"
        self.start_shifting_process()

    def toggle_off(self):
        if not self.listening: return
        self.listening = False
        self.stop_shifting_process()
        self.status_text = "Trạng thái: THỦ CÔNG"
        self.status_color = "red"

    def check_leds(self):
        if self.listening:
            logger.warning("Không thể kiểm tra LED ở chế độ TỰ ĐỘNG.")
            return False
        threading.Thread(target=self._run_led_check, daemon=True).start()
        return True

    def _run_led_check(self):
        logger.info("Kiểm tra LED...")
        self.flash_led(Constants.LED1_PIN, duration=0.5)
        time.sleep(0.1)
        self.flash_led(Constants.LED2_PIN, duration=0.5)

    def clear_all_data(self):
        # Xóa dữ liệu lịch sử và báo cho GUI
        self.latest_full_report = {}
        self.displacement_history.clear()
        self.water_level_history.clear()
        self.anomaly_score_history.clear()
        self.threat_score_history.clear()
        self.gui_update_queue.put((Constants.DATA_CLEAR_SIGNAL, None))
        logger.info("Đã xóa dữ liệu nền và lịch sử.")

    def get_gui_updates(self):
        updates = []
        while not self.gui_update_queue.empty():
            try:
                updates.append(self.gui_update_queue.get_nowait())
            except queue.Empty:
                break
        return updates

# ==============================================================================
# LỚP GIAO DIỆN NGƯỜI DÙNG (GUI) - PHIÊN BẢN BẢNG ĐIỀU KHIỂN
# ==============================================================================
class AppGUI:
    def __init__(self, root: tk.Toplevel, backend: Backend, on_close_callback):
        self.root = root
        self.backend = backend
        self.on_close_callback = on_close_callback
        self.root.title("ASTCS - Bảng điều khiển Tình báo")
        # Lấy kích thước màn hình để mở toàn màn hình
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        self.root.geometry(f"{screen_width}x{screen_height - 70}+0+0")
        
        self.chart_window = None
        self.settings_window = None
        
        # Biến cho các widget cấu hình
        self.warning_threshold_var = tk.StringVar()
        self.critical_threshold_var = tk.StringVar()
        
        self.create_widgets()
        self.load_initial_data()
        self.root.after(250, self.periodic_update)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close_window)

    def create_widgets(self):
        main = ttk.Frame(self.root, padding=10)
        main.pack(fill="both", expand=True)
        main.grid_columnconfigure(1, weight=1) # Cột phải (dashboard) rộng hơn
        main.grid_columnconfigure(0, weight=0) # Cột trái (cấu hình) cố định
        main.grid_rowconfigure(0, weight=1)
        self.create_left_panel(main)
        self.create_right_panel(main)

    def create_left_panel(self, parent):
        # Phần này giữ nguyên, chỉ bỏ publish topic và các cài đặt GNSS không cần thiết
        left = ttk.LabelFrame(parent, text="Cài đặt & Điều khiển", padding=10)
        left.grid(row=0, column=0, sticky="nsw", padx=(0, 15))

        def add_labeled_entry(frame, label, row, show=None):
            ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w", pady=3)
            entry = ttk.Entry(frame, show=show)
            entry.grid(row=row, column=1, sticky="ew", pady=3, columnspan=2)
            return entry

        # --- Cài đặt MQTT ---
        mqtt_frame = ttk.LabelFrame(left, text="Cấu hình MQTT", padding=10)
        mqtt_frame.pack(fill="x", pady=5)
        self.broker_entry = add_labeled_entry(mqtt_frame, "Broker:", 0)
        self.port_entry = add_labeled_entry(mqtt_frame, "Port:", 1)
        self.user_entry = add_labeled_entry(mqtt_frame, "Username:", 2)
        self.pass_entry = add_labeled_entry(mqtt_frame, "Password:", 3, show="*")

        # --- Cài đặt Topics ---
        topic_frame = ttk.LabelFrame(left, text="Topics Cảm biến", padding=10)
        topic_frame.pack(fill="x", pady=5)
        ttk.Label(topic_frame, text="GNSS Sub Topics:").pack(anchor="w")
        self.gnss_topic_entry = tk.Text(topic_frame, height=4, width=35, relief="solid", borderwidth=1)
        self.gnss_topic_entry.pack(fill="x", expand=True, pady=(0, 5))
        ttk.Label(topic_frame, text="Water Sub Topics:").pack(anchor="w")
        self.water_topic_entry = tk.Text(topic_frame, height=4, width=35, relief="solid", borderwidth=1)
        self.water_topic_entry.pack(fill="x", expand=True, pady=(0, 5))

        # --- Cài đặt Ngưỡng ---
        threshold_frame = ttk.LabelFrame(left, text="Ngưỡng Cảnh báo Nước", padding=10)
        threshold_frame.pack(fill="x", pady=5)
        add_labeled_entry(threshold_frame, "Cảnh báo (m):", 0, var=self.warning_threshold_var)
        add_labeled_entry(threshold_frame, "Nguy hiểm (m):", 1, var=self.critical_threshold_var)
        
        # --- Nút Điều khiển ---
        ttk.Button(left, text="Lưu & Áp dụng Cấu hình", command=self.apply_and_save_config, bootstyle="primary").pack(fill="x", pady=(10, 5))

    def create_right_panel(self, parent):
        right = ttk.Frame(parent)
        right.grid(row=0, column=1, sticky="nsew")
        right.grid_rowconfigure(1, weight=1)
        right.grid_columnconfigure(0, weight=1)
        
        self.status_label = ttk.Label(right, text="Khởi tạo...", font=("Arial", 11, "bold"))
        self.status_label.grid(row=0, column=0, sticky="ew", pady=(0, 5), padx=5)

        dashboard_frame = ttk.Frame(right)
        dashboard_frame.grid(row=1, column=0, sticky="nsew")
        self.create_dashboard_widgets(dashboard_frame)

        self.create_control_panel(right)

    def create_dashboard_widgets(self, parent):
        parent.grid_columnconfigure(0, weight=1)
        parent.grid_columnconfigure(1, weight=2)

        status_frame = ttk.LabelFrame(parent, text="TRẠNG THÁI HỆ THỐNG", padding=15)
        status_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=5, padx=5)
        status_frame.grid_columnconfigure(0, weight=1)
        
        self.final_status_label = ttk.Label(status_frame, text="CHỜ DỮ LIỆU", font=("Helvetica", 28, "bold"), anchor="center")
        self.final_status_label.grid(row=0, column=0, sticky="ew")
        
        self.summary_text_label = ttk.Label(status_frame, text="Chuyển sang chế độ TỰ ĐỘNG để bắt đầu giám sát.", font=("Helvetica", 11), wraplength=700, justify="center")
        self.summary_text_label.grid(row=1, column=0, sticky="ew", pady=(5,0))

        primary_frame = ttk.LabelFrame(parent, text="Chỉ số Chính", padding=10)
        primary_frame.grid(row=1, column=0, sticky="nsew", pady=5, padx=5)
        
        self.disp_label = ttk.Label(primary_frame, text="Dịch chuyển 3D: -- mm", font=("Arial", 12))
        self.disp_label.pack(pady=5, anchor="w")
        self.velo_label = ttk.Label(primary_frame, text="Vận tốc 3D: -- mm/s", font=("Arial", 12))
        self.velo_label.pack(pady=5, anchor="w")
        self.water_label = ttk.Label(primary_frame, text="Mực nước: -- m", font=("Arial", 12))
        self.water_label.pack(pady=5, anchor="w")
        self.water_roc_label = ttk.Label(primary_frame, text="Tốc độ nước: -- mm/phút", font=("Arial", 12))
        self.water_roc_label.pack(pady=5, anchor="w")

        ai_frame = ttk.LabelFrame(parent, text="Phân tích Tình báo", padding=10)
        ai_frame.grid(row=1, column=1, sticky="nsew", pady=5, padx=5)

        self.threat_score_label = ttk.Label(ai_frame, text="Điểm Rủi ro: --", font=("Arial", 12))
        self.threat_score_label.pack(pady=5, anchor="w")
        self.anomaly_label = ttk.Label(ai_frame, text="Điểm Bất thường AI: --", font=("Arial", 12))
        self.anomaly_label.pack(pady=5, anchor="w")
        self.sentry_label = ttk.Label(ai_frame, text="Lính canh: --", font=("Arial", 12))
        self.sentry_label.pack(pady=5, anchor="w")

    def create_control_panel(self, parent_frame):
        bottom_part = ttk.Frame(parent_frame)
        bottom_part.grid(row=2, column=0, sticky="ew", pady=(10, 0), padx=5)
        
        ctrl = ttk.Frame(bottom_part)
        ctrl.pack(side=tk.TOP, fill=tk.X, expand=True)
        for i in range(4): ctrl.grid_columnconfigure(i, weight=1)

        ttk.Button(ctrl, text="Tự động (ON)", command=self.backend.toggle_on, bootstyle="success").grid(row=0, column=0, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Thủ công (OFF)", command=self.backend.toggle_off, bootstyle="danger").grid(row=0, column=1, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Xóa Lịch sử", command=self.clear_gui_data, bootstyle="warning").grid(row=0, column=2, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Xem Biểu Đồ", command=self.show_chart_window, bootstyle="primary").grid(row=0, column=3, padx=2, sticky="ew")
        
        led_panel = ttk.LabelFrame(bottom_part, text="Thiết bị & Hệ thống", padding=5)
        led_panel.pack(side=tk.TOP, fill=tk.X, expand=True, pady=(10, 0))
        led_panel.grid_columnconfigure(0, weight=3)
        led_panel.grid_columnconfigure(1, weight=1)
        ttk.Button(led_panel, text="Kiểm tra LED", command=self.on_check_led_click).grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        ttk.Button(led_panel, text="Thoát", command=self.exit_program_graceful, bootstyle="secondary-outline").grid(row=0, column=1, padx=5, pady=5, sticky="ew")

    def periodic_update(self):
        if not self.root.winfo_exists(): return
        
        self.update_status_label()
        
        new_packets = self.backend.get_gui_updates()
        
        full_report_to_process = None
        latest_heartbeat = None

        for packet_type, data in new_packets:
            if packet_type == "FULL_REPORT":
                full_report_to_process = data
            elif packet_type == "HEARTBEAT":
                latest_heartbeat = data
            elif packet_type == Constants.DATA_CLEAR_SIGNAL:
                self.reset_dashboard()
                logger.info("GUI đã nhận tín hiệu và xóa hiển thị.")
                continue

        if full_report_to_process:
            self.process_full_report(full_report_to_process)
        elif latest_heartbeat:
            self.process_heartbeat(latest_heartbeat)

        if self.chart_window and self.chart_window.winfo_exists():
            self.chart_window.update_plot()

        self.root.after(250, self.periodic_update)

    def process_full_report(self, report):
        self.backend.latest_full_report = report
        ts = datetime.fromtimestamp(report.get('timestamp', time.time()))

        assessment = report.get('final_assessment', {})
        status_code = assessment.get('status_code', 'UNKNOWN')
        summary = assessment.get('summary_text', 'Mất kết nối với bộ phân tích...')
        threat_score = assessment.get('overall_threat_score', 0)
        
        primary = report.get('primary_state', {})
        disp = primary.get('displacement_3d_mm', 0)
        velo = primary.get('displacement_velocity_mmps', 0)
        water = primary.get('water_level_m', 0)
        water_roc = primary.get('water_level_roc_mm_per_min', 0)
        
        context = report.get('contextual_analysis', {})
        sentry_reason = context.get('sentry_reason', 'N/A')

        ai = report.get('ai_analysis', {})
        anomaly_score = ai.get('anomaly_score', 0)
        
        color_map = {"SAFE": "#28A745", "MONITOR": "#17A2B8", "WARNING": "#FFC107", "CRITICAL": "#DC3545"}
        self.final_status_label.config(text=status_code, foreground=color_map.get(status_code, "black"))
        self.summary_text_label.config(text=summary)

        self.disp_label.config(text=f"Dịch chuyển 3D: {disp:.2f} mm")
        self.velo_label.config(text=f"Vận tốc 3D: {velo:.3f} mm/s")
        self.water_label.config(text=f"Mực nước: {water:.3f} m")
        self.water_roc_label.config(text=f"Tốc độ nước: {water_roc:.2f} mm/phút")
        
        self.threat_score_label.config(text=f"Điểm Rủi ro: {threat_score:.0f}")
        self.anomaly_label.config(text=f"Điểm Bất thường AI: {anomaly_score:.3f}")
        self.sentry_label.config(text=f"Lính canh: {sentry_reason}")
        
        self.backend.displacement_history.append((ts, disp))
        self.backend.water_level_history.append((ts, water))
        self.backend.anomaly_score_history.append((ts, anomaly_score))
        self.backend.threat_score_history.append((ts, threat_score))

    def process_heartbeat(self, hb):
        status_code = hb.get('status_code', 'UNKNOWN')
        disp = hb.get('displacement_3d_mm', 0)
        water = hb.get('water_level_m', 0)

        self.disp_label.config(text=f"Dịch chuyển 3D: {disp:.2f} mm")
        self.water_label.config(text=f"Mực nước: {water:.3f} m")
        
        color_map = {"SAFE": "#28A745", "MONITOR": "#17A2B8", "WARNING": "#FFC107", "CRITICAL": "#DC3545"}
        self.final_status_label.config(foreground=color_map.get(status_code, "black"))

    def reset_dashboard(self):
        """Đặt lại các widget trên dashboard về trạng thái ban đầu."""
        self.final_status_label.config(text="CHỜ DỮ LIỆU", foreground="black")
        self.summary_text_label.config(text="Chuyển sang chế độ TỰ ĐỘNG để bắt đầu giám sát.")
        self.disp_label.config(text="Dịch chuyển 3D: -- mm")
        self.velo_label.config(text="Vận tốc 3D: -- mm/s")
        self.water_label.config(text="Mực nước: -- m")
        self.water_roc_label.config(text="Tốc độ nước: -- mm/phút")
        self.threat_score_label.config(text="Điểm Rủi ro: --")
        self.anomaly_label.config(text="Điểm Bất thường AI: --")
        self.sentry_label.config(text="Lính canh: --")

    def load_initial_data(self):
        self.broker_entry.insert(0, self.backend.broker)
        self.port_entry.insert(0, str(self.backend.port))
        self.user_entry.insert(0, self.backend.username)
        self.pass_entry.insert(0, self.backend.password)
        self.water_topic_entry.insert("1.0", "\n".join(self.backend.water_topics))
        self.gnss_topic_entry.insert("1.0", "\n".join(self.backend.gnss_topics))
        self.warning_threshold_var.set(str(self.backend.warning_threshold))
        self.critical_threshold_var.set(str(self.backend.critical_threshold))

    def apply_and_save_config(self):
        settings = {
            'broker': self.broker_entry.get(),
            'port': self.port_entry.get(),
            'username': self.user_entry.get(),
            'password': self.pass_entry.get(),
            'water_topics': self.water_topic_entry.get("1.0", "end-1c").strip(),
            'gnss_topics': self.gnss_topic_entry.get("1.0", "end-1c").strip(),
            'warning_threshold': self.warning_threshold_var.get(),
            'critical_threshold': self.critical_threshold_var.get(),
        }
        # Thêm validation nếu cần
        self.backend.update_and_reconnect(settings)
        messagebox.showinfo("Thành công", "Đã lưu và áp dụng cấu hình. Hệ thống phân tích sẽ khởi động lại nếu đang chạy.", parent=self.root)

    def update_status_label(self):
        if self.status_label.cget("text") != self.backend.status_text or \
           self.status_label.cget("bootstyle") != self.backend.status_color:
            self.status_label.config(text=f"Trạng thái Bộ chỉ huy: {self.backend.status_text.upper()}", 
                                     bootstyle=f"{self.backend.status_color}.inverse")

    def clear_gui_data(self):
        if messagebox.askokcancel("Xác nhận", "Bạn có chắc muốn xóa toàn bộ lịch sử hiển thị trên giao diện?", parent=self.root):
            self.backend.clear_all_data()

    def show_chart_window(self):
        messagebox.showinfo("Sắp ra mắt", "Chức năng biểu đồ nâng cao đang được phát triển!", parent=self.root)
        # TODO: Sửa lại hàm này để vẽ biểu đồ từ các deque lịch sử mới

    def on_check_led_click(self):
        if not self.backend.check_leds(): messagebox.showwarning("Cảnh báo", "Chỉ có thể kiểm tra LED ở chế độ THỦ CÔNG (OFF).", parent=self.root)
        
    def on_close_window(self):
        logger.info("Đã đóng cửa sổ giao diện. Gõ 'show' trong terminal để mở lại.")
        self.on_close_callback()
        if self.root.winfo_exists(): self.root.destroy()
        
    def exit_program_graceful(self):
        if messagebox.askokcancel("Xác nhận", "Bạn có chắc muốn thoát hoàn toàn chương trình?", parent=self.root):
            logger.info("Tự động lưu cấu hình hiện tại trước khi thoát...")
            # Không cần lưu config ở đây nữa vì nó được lưu mỗi khi nhấn nút
            self.on_close_callback(shutdown=True)

# ===========================
# KHỐI ĐIỀU KHIỂN CHÍNH 
# ===========================
class MainController:
    def __init__(self, backend, command_queue):
        self.backend = backend
        self.command_queue = command_queue
        self.app_instance = None
        self.root = ttk.Window()
        self.root.withdraw()

    def run(self):
        self.check_for_commands()
        self.root.mainloop()

    def check_for_commands(self):
        try:
            command = self.command_queue.get_nowait()
            if command == 'show': self.create_gui_window()
            elif command == 'exit': self.handle_shutdown()
            elif command == 'restart': self.handle_restart()
        except queue.Empty: pass
        finally:
            if not self.backend.exiting and self.root.winfo_exists():
                self.root.after(100, self.check_for_commands)

    def create_gui_window(self):
        if self.app_instance and self.app_instance.root.winfo_exists():
            logger.info("Giao diện đã đang chạy.")
            self.app_instance.root.lift()
            return
        logger.info("Đang khởi động giao diện người dùng...")
        toplevel_window = tk.Toplevel(self.root)
        self.app_instance = AppGUI(toplevel_window, self.backend, self.on_gui_close)

    def on_gui_close(self, shutdown=False):
        self.app_instance = None
        if shutdown:
            self.command_queue.put('exit')

    def handle_shutdown(self):
        logger.info("Nhận lệnh thoát...")
        if self.app_instance: self.app_instance.destroy_all_windows()
        self.backend.exiting = True
        if self.root.winfo_exists(): self.root.destroy()

    def handle_restart(self):
        logger.info("Nhận lệnh khởi động lại...")
        global needs_restart; needs_restart = True
        self.handle_shutdown()

# ==============================================================================
# KHỐI THỰC THI CHÍNH (MAIN)
# ==============================================================================
needs_restart = False
command_queue = queue.Queue()

def console_input_listener(cmd_queue: queue.Queue):
    while True:
        try:
            command = input().strip().lower()
            if command: cmd_queue.put(command)
            if command in ['exit', 'restart']: break
        except (EOFError, KeyboardInterrupt):
            cmd_queue.put('exit'); break

def signal_handler(signum, frame):
    logger.info("\nNhận tín hiệu ngắt (Ctrl+C), đang thoát...")
    while not command_queue.empty():
        try: command_queue.get_nowait()
        except queue.Empty: pass
    command_queue.put('exit')

if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal_handler)
    
    backend_instance = Backend()
    backend_instance.start_background_tasks()
    
    console_thread = threading.Thread(target=console_input_listener, args=(command_queue,), daemon=True)
    console_thread.start()
    
    logger.info("="*50)
    logger.info("Chương trình đã sẵn sàng.")
    logger.info("Gõ 'show' để mở giao diện, 'exit' để thoát, 'restart' để khởi động lại.")
    logger.info("="*50)
    
    main_controller = MainController(backend_instance, command_queue)
    command_queue.put('show')
    main_controller.run()
    
    if needs_restart:
        logger.info("\n" + "="*50)
        logger.info("KHỞI ĐỘNG LẠI CHƯƠNG TRÌNH...")
        logger.info("="*50 + "\n")
        try:
            os.execv(sys.executable, ['python'] + sys.argv)
        except Exception as e:
            logger.critical(f"LỖI KHÔNG THỂ KHỞI ĐỘNG LẠI: {e}")
    else:
        logger.info("Chương trình đã kết thúc.")
