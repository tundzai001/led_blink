import ttkbootstrap as ttk
import tkinter as tk
from tkinter import TclError
from ttkbootstrap.constants import *
from ttkbootstrap import Style
from ttkbootstrap.dialogs import Messagebox
from tkinter import messagebox
from tkinter import filedialog
from tksheet import Sheet
import paho.mqtt.client as mqtt
import json
from datetime import datetime
import csv
import RPi.GPIO as GPIO
import threading
import time
import warnings
import configparser
import signal
import os

warnings.filterwarnings("ignore", category=DeprecationWarning)
# GPIOsetup
LED1_PIN = 3
LED2_PIN = 27
try:
    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)
    GPIO.setup(LED1_PIN, GPIO.OUT)
    GPIO.setup(LED2_PIN, GPIO.OUT)
    print("GPIO setup successful.")
except Exception as e:
    print(f"Error setting up GPIO. Are you running on a Raspberry Pi with permissions? Error: {e}")

SHUTDOWN_REQUESTED = False
threshold = 1.3
sensor_data = []
listening = False
blink_mode = False
stop_event = threading.Event()
current_topics = []


# ==== Flash LED ====
def flash_led(pin, duration=0.3):
    GPIO.setwarnings(False)
    try:
        GPIO.output(pin, GPIO.HIGH)
        time.sleep(duration)
        GPIO.output(pin, GPIO.LOW)
    except Exception as e:
        print(f"Error flashing LED on pin {pin}: {e}")


# ==== GUI ====
root = ttk.Window(themename="flatly")
root.title("Sensor & LED Control Interface")
root.geometry(f"{root.winfo_screenwidth()}x{root.winfo_screenheight()}")
main = ttk.Frame(root)
main.pack(fill="both", expand=True, padx=10, pady=10)
main.grid_columnconfigure(1, weight=1)
main.grid_rowconfigure(0, weight=1)

style = ttk.Style()
style.configure("Treeview.Heading", font=("Arial", 10, "bold"))
style.configure("Treeview", rowheight=24, font=("Arial", 10))

# ==== LEFT PANEL ====
left = ttk.LabelFrame(main, text="MQTT & Threshold Settings")
left.grid(row=0, column=0, sticky="nsw", padx=(0, 15), pady=10)
left.grid_rowconfigure(8, weight=1)


def add_labeled_entry(frame, label, row, default="", width=14, show=None):
    ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w")
    entry = ttk.Entry(frame, width=width, show=show)
    entry.insert(0, default)
    entry.grid(row=row, column=1, sticky="ew", pady=2)
    frame.grid_columnconfigure(1, weight=1)
    return entry


broker_entry = add_labeled_entry(left, "MQTT Broker:", 0, "aitogy.xyz")
port_entry = add_labeled_entry(left, "Port:", 1, "1883")
user_entry = add_labeled_entry(left, "Username:", 2, "abc")
pass_entry = add_labeled_entry(left, "Password:", 3, "xyz", show="*")
pub_entry = add_labeled_entry(left, "Publish Topic:", 4, "", )
threshold_entry = add_labeled_entry(left, "Warning Threshold:", 5, str(threshold))


def save_config(silent=False):
    # This function now needs to be thread-safe in case it's called during shutdown
    try:
        config = configparser.ConfigParser()
        config['MQTT'] = {
            'broker': broker_entry.get(),
            'port': port_entry.get(),
            'username': user_entry.get(),
            'password': pass_entry.get(),
            'topics': topic_input.get("1.0", "end").strip(),
            'publish': pub_entry.get()
        }
        config['Settings'] = {
            'threshold': threshold_entry.get()
        }
        with open('config.ini', 'w') as f:
            config.write(f)
        if not silent:
            messagebox.showinfo("Save Configuration", "Configuration saved successfully")
    except tk.TclError:
        print("Warning: Could not save config, GUI might be closed.")
    except Exception as e:
        print(f"Error saving config: {e}")

def apply_and_save_config():
    save_config()
    if listening:
        print("In automatic mode, applying new MQTT configuration...")
        update_mqtt()


def load_config():
    config = configparser.ConfigParser()
    if not os.path.exists('config.ini'):
        print("config.ini file not found. Using default values.")
        return
    config.read('config.ini')
    if "MQTT" in config:
        mqtt_config = config["MQTT"]
        broker_entry.delete(0, tk.END)
        broker_entry.insert(0, mqtt_config.get("broker", ""))

        port_entry.delete(0, tk.END)
        port_entry.insert(0, mqtt_config.get("port", "1883"))

        user_entry.delete(0, tk.END)
        user_entry.insert(0, mqtt_config.get("username", ""))

        pass_entry.delete(0, tk.END)
        pass_entry.insert(0, mqtt_config.get("password", ""))

        topic_input.delete("1.0", tk.END)
        topic_input.insert("1.0", mqtt_config.get("topics", ""))
        pub_entry.delete(0, tk.END)
        pub_entry.insert(0, mqtt_config.get("publish", "led_data"))
    if "Settings" in config and "threshold" in config["Settings"]:
        threshold_entry.delete(0, tk.END)
        threshold_entry.insert(0, config["Settings"]["threshold"])
    print("Configuration loaded.")


def load_threshold():
    config = configparser.ConfigParser()
    config.read('config.ini')
    if "Settings" in config and 'threshold' in config['Settings']:
        threshold_entry.delete(0, tk.END)
        threshold_entry.insert(0, config['Settings']['threshold'])


def toggle_pass():
    if pass_entry.cget("show") == "":
        pass_entry.config(show="*")
        show_btn.config(text="üëÅ")
    else:
        pass_entry.config(show="")
        show_btn.config(text="üôà")


show_btn = ttk.Button(left, text="üëÅ", command=toggle_pass, width=2)
show_btn.grid(row=3, column=2, sticky="w")
ttk.Label(left, text="Subscribe Topics (1 per line):").grid(row=7, column=0, columnspan=2, sticky="w")
topic_input = tk.Text(left, width=22, height=6)
topic_input.grid(row=8, column=0, columnspan=3, pady=(0, 5), sticky="nsew")
ttk.Button(left, text="Save & Apply", command=apply_and_save_config, bootstyle="primary").grid(row=9, column=0,
                                                                                                  columnspan=3,
                                                                                                  sticky="ew", pady=5)
exiting = False


def on_connect(client, userdata, flags, rc):
    if exiting: return
    root.after(0, _on_connect_gui, rc, flags)


def _on_connect_gui(rc, flags):
    global current_topics
    if rc == 0:
        print("MQTT Connected successfully.")
        topics_to_subscribe = [t for t in topic_input.get("1.0", "end").strip().splitlines() if t]

        topics_to_unsubscribe = set(current_topics) - set(topics_to_subscribe)
        for t in topics_to_unsubscribe:
            if t:
                client.unsubscribe(t)
                print(f"Unsubscribed from topic: {t}")

        topics_to_subscribe_new = set(topics_to_subscribe) - set(current_topics)
        for t in topics_to_subscribe_new:
            if t:
                client.subscribe(t)
                print(f"Subscribed to topic: {t}")

        current_topics = topics_to_subscribe

        if not current_topics:
            print("Warning: No topics specified to subscribe to.")
            if listening:
                status_label.config(text="Status: AUTOMATIC (No topics)", foreground="green")
        else:
            if listening:
                status_label.config(text="Status: AUTOMATIC", foreground="green")
    else:
        print(f"Failed to connect, return code {rc}\n")
        status_label.config(text="Status: CONNECTION ERROR", foreground="red")
        if listening:
            messagebox.showerror("MQTT Error", f"Cannot connect to MQTT, error code: {rc}")
        toggle_off()


def _attempt_reconnect(client):
    while not stop_event.is_set() and listening:
        try:
            print("Attempting to reconnect to MQTT...")
            broker = broker_entry.get().strip()
            port = int(port_entry.get().strip())
            client.connect(broker, port, 60)
            client.loop_start()
            return
        except Exception as e:
            print(f"Reconnect failed: {e}. Retrying in 5 seconds.")
            time.sleep(5)


def update_mqtt():
    global exiting
    if exiting:
        return
    try:
        client.loop_stop()
        if client.disconnect():
            client.disconnect()
    except Exception as e:
        messagebox.showerror("MQTT Connection Error", f"Cannot connect: {e}");
        status_label.config(text="Status: DISCONNECTED", foreground="red")
        threading.Thread(target=_attempt_reconnect, args=(client,), daemon=True).start()
    if listening:
        toggle_on(reconnecting=True)


def toggle_on(reconnecting=False):
    global listening, client
    if blink_mode:
        messagebox.showwarning("Warning", "Please turn off BLINK mode before enabling AUTOMATIC mode")
        return
    if listening and not reconnecting:
        print("Automatic mode is already enabled.")
        return

    listening = True
    if blink_mode: toggle_blink()
    status_label.config(text="Status: CONNECTING...", foreground="orange")

    broker = broker_entry.get().strip()
    port_text = port_entry.get().strip()
    pwd = pass_entry.get().strip()
    user = user_entry.get().strip()

    if not broker:
        messagebox.showerror("MQTT Error", "Please enter the MQTT Broker address")
        toggle_off()
        return
    try:
        port = int(port_text)
    except (ValueError, TypeError):
        messagebox.showerror("Configuration Error", "Port must be an integer.")
        toggle_off()
        return

    client = mqtt.Client(protocol=mqtt.MQTTv311)
    client.on_connect = on_connect
    client.on_message = on_message
    client.on_disconnect = on_disconnect
    client.username_pw_set(user, pwd)

    try:
        print(f"Connecting to MQTT broker: {broker}:{port}...")
        client.connect(broker, port=port, keepalive=60)
        client.loop_start()
    except Exception as e:
        messagebox.showerror("MQTT Connection Error", f"Cannot connect: {e}");
        status_label.config(text="Status: DISCONNECTED", foreground="red")
        threading.Thread(target=_attempt_reconnect, args=(client,), daemon=True).start()

# ==== RIGHT PANEL ==== (No changes needed here)
right = ttk.Frame(main, borderwidth=1, relief="solid")
right.grid(row=0, column=1, sticky="nsew")
right.grid_columnconfigure(0, weight=1)
right.grid_rowconfigure(1, weight=1)

status_label = ttk.Label(right, text="Status: MANUAL", foreground="red", font=("Arial", 11, "bold"))
status_label.grid(row=0, column=0, pady=5)

sheet_frame = ttk.Frame(right)
sheet_frame.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)
sheet_frame.grid_columnconfigure(0, weight=1)
sheet_frame.grid_rowconfigure(0, weight=1)
sheet = Sheet(sheet_frame,
              headers=["Name", "Value", "Status", "Timestamp"],
              show_row_index=False,
              column_widths=[150, 100, 100, 150],
              )
sheet.enable_bindings()
sheet.set_options(
    font=("Arial", 10, "normal"),
    align="w",
    header_font=("Arial", 10, "bold"),
    table_bg="#ffffff",
    grid_color="#cccccc"
)
sheet.disable_bindings(
    ["edit_cell", "arrowkeys", "drag_and_drop", "column_drag_and_drop", "rc_delete_row", "rc_insert_row",
     "rc_delete_column", "rc_insert_column"])
sheet.set_options(grid_color="#cccccc", table_bg="#ffffff", index_bg="#eeeeee")
sheet.grid(row=0, column=0, sticky="nsew")


def resize_columns(event=None):
    width = right.winfo_width() - 15
    if width <= 1: return
    ratios = [0.30, 0.20, 0.20, 0.30]
    new_widths = [int(width * r) for r in ratios]
    try:
        sheet.column_widths(new_widths)
    except:
        pass


right.bind("<Configure>", resize_columns)


def update_table(record):
    sheet.dehighlight_all()
    data_as_lists = [list(row) for row in sensor_data]
    sheet.set_sheet_data(data_as_lists)
    new_row_index = len(sensor_data) - 1
    if new_row_index >= 0:
        sheet.highlight_rows([new_row_index], bg='#D2EAF8')
    sheet.see(row=new_row_index, column=0)
    sheet.redraw()


def clear_table():
    sensor_data.clear()
    root.after(0, lambda: sheet.set_sheet_data([]))
    print("Cleared data table at 00:00")


def auto_clear_loop():
    while not stop_event.wait(timeout=10):
        now = datetime.now()
        if now.hour == 0 and now.minute == 0:
            clear_table()
            stop_event.wait(60)


def on_message(client, userdata, msg):
    if not listening or exiting:
        return
    try:
        data = json.loads(msg.payload.decode())
        name = data.get("sensorname", msg.topic)
        value = float(data.get("value", 0))
        ts = float(data.get("timestamp", time.time()))
        try:
            current_threshold = float(threshold_entry.get())
        except (ValueError, TclError):
            current_threshold = float('inf')
        status = "WARNING" if value > current_threshold else "SAFE"
        time_str = datetime.fromtimestamp(ts).strftime("%H:%M:%S %d-%m")
        record = (name, value, status, time_str)
        sensor_data.append(record)
        root.after(0, update_table, record)
        threading.Thread(target=flash_led, args=(LED1_PIN,), daemon=True).start()
        if value > current_threshold:
            threading.Thread(target=flash_led, args=(LED2_PIN,), daemon=True).start()
        pub_topic = pub_entry.get().strip()
        if pub_topic:
            client.publish(pub_topic, f"({value}, {status}, {int(ts)})")
    except Exception as e:
        print(f"Error in on_message: {e}")

def on_disconnect(client, userdata, rc):
    if not exiting and listening:
        root.after(0, update_disconnect_status)

def update_disconnect_status():
    if listening:
        print("MQTT connection lost, attempting to reconnect...")
    status_label.config(text="Status: DISCONNECTED", foreground="orange")

client = mqtt.Client(protocol=mqtt.MQTTv311)
# ... assign callbacks in toggle_on ...

def toggle_off():
    global listening, current_topics
    if not listening:
        return
    listening = False
    current_topics.clear()
    try:
        client.loop_stop()
        client.disconnect()
        print("Disconnected from MQTT.")
    except Exception as e:
        pass
    status_label.config(text="Status: MANUAL", foreground="red")

def toggle_led(pin):
    if not listening:
        try:
            GPIO.output(pin, not GPIO.input(pin))
        except Exception as e:
            print(f"Could not toggle LED on pin {pin}: {e}")
    else:
        messagebox.showwarning("Warning", "Please turn off automatic mode before controlling LEDs manually")

def blink_loop():
    state = True
    while not stop_event.wait(timeout=0.5):
        if blink_mode and not listening:
            try:
                GPIO.output(LED1_PIN, state)
                GPIO.output(LED2_PIN, state)
                state = not state
            except Exception as e:
                pass

def toggle_blink():
    global blink_mode
    if listening:
        messagebox.showwarning("Warning", "Please turn off automatic mode before enabling BLINK")
        return
    blink_mode = not blink_mode
    if blink_mode:
        status_label.config(text="Status: BLINK", foreground="blue")
    else:
        try:
            GPIO.output(LED1_PIN, GPIO.LOW)
            GPIO.output(LED2_PIN, GPIO.LOW)
        except Exception as e:
            print(f"Could not turn off LEDs: {e}")
        status_label.config(text="Status: MANUAL", foreground="red")


def console_input_listener():
    print("Type 'exit' and press Enter in this console for an emergency exit.")
    while not stop_event.is_set():
        try:
            command = input()
            if command.strip().lower() == 'exit':
                exit_program_force()
                break
        except (EOFError, KeyboardInterrupt):
            if not exiting:
                exit_program_force()
            break
        except Exception:
            break

def _write_csv_in_background(path, data_to_save):
    try:
        with open(path, "w", newline="", encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(["Name", "Value", "Status", "Timestamp"])
            writer.writerows(data_to_save)
        root.after(0, lambda: messagebox.showinfo("Success", f"Data saved to {path}"))
    except Exception as e:
        root.after(0, lambda: messagebox.showerror("Error", f"Could not save file: {e}"))
    finally:
        root.after(0, lambda: save_csv_button.config(state="normal"))

def save_to_csv():
    if not sensor_data:
        messagebox.showinfo("Information", "No data to save.")
        return
    path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")])
    data_copy = list(sensor_data)
    if path:
        save_csv_button.config(state="disabled")
        threading.Thread(target=_write_csv_in_background, args=(path, data_copy), daemon=True).start()

exiting = False

def exit_program_graceful():
    global exiting
    if exiting: return
    if messagebox.askokcancel("Confirm", "Do you want to exit the program?"):
        exiting = True
        print("Starting graceful exit process...")
        stop_event.set()

        if sensor_data and messagebox.askyesno("Save Data", "Do you want to save the data table to a CSV file?"):
            save_to_csv() # This is already threaded, so it's fine

        def cleanup_task():
            print("Disconnecting from MQTT...")
            try:
                client.loop_stop()
                client.disconnect()
            except Exception: pass
            
            print("Cleaning up GPIO...")
            try:
                GPIO.cleanup()
                print("GPIO cleaned up.")
            except Exception as e:
                print(f"Error during GPIO cleanup: {e}")
            
            print("Cleanup complete. Closing application.")
            root.quit()

        threading.Thread(target=cleanup_task, daemon=True).start()

#==== NEW/MODIFIED FUNCTIONS START ====
def _force_cleanup_thread():
    """
    This function runs on a separate, short-lived thread to perform
    critical non-GUI cleanup.
    """
    print("Force cleanup thread: Started.")
    try:
        print("Force cleanup thread: Disconnecting MQTT client...")
        client.loop_stop()
        client.disconnect()
        print("Force cleanup thread: MQTT client disconnected.")
    except Exception as e:
        print(f"Force cleanup thread: Error disconnecting MQTT (can be ignored): {e}")

    try:
        print("Force cleanup thread: Cleaning up GPIO...")
        GPIO.cleanup()
        print("Force cleanup thread: GPIO cleaned up.")
    except Exception as e:
        print(f"Force cleanup thread: Error cleaning up GPIO (can be ignored): {e}")
    print("Force cleanup thread: Finished.")

def exit_program_force():
    """
    Initiates a forceful, immediate exit. It starts a parallel cleanup
    thread and then terminates the main process.
    """
    global exiting
    if exiting:
        return
    exiting = True
    stop_event.set()

    print("\nEMERGENCY EXIT INITIATED.")
    print("Starting a parallel cleanup thread...")
    
    cleanup_thread = threading.Thread(target=_force_cleanup_thread, daemon=True)
    cleanup_thread.start()
    
    # Give the cleanup thread a moment to run before killing the process
    print("Waiting 0.5 seconds before forceful termination...")
    time.sleep(0.5)
    
    print("Terminating process now. os._exit(1)")
    os._exit(1)  # Force exit the entire program

def signal_handler(signum, frame):
    """Handles Ctrl+C, triggering the force exit."""
    if not exiting:
        print("\nCtrl+C detected!")
        exit_program_force()
#==== NEW/MODIFIED FUNCTIONS END ====


# Control buttons panel
ctrl = ttk.Frame(right)
ctrl.grid(row=2, column=0, pady=5, sticky="ew")
ctrl.grid_columnconfigure((0, 1, 2, 3), weight=1)
right.grid_rowconfigure(2, weight=0)

ttk.Button(ctrl, text="Automatic (ON)", command=toggle_on, bootstyle="success").grid(row=0, column=0, padx=3)
ttk.Button(ctrl, text="Manual (OFF)", command=toggle_off, bootstyle="danger").grid(row=0, column=1, padx=3)
save_csv_button = ttk.Button(ctrl, text="Save CSV", command=save_to_csv, bootstyle="info")
save_csv_button.grid(row=0, column=2, padx=3)
ttk.Button(ctrl, text="Exit", command=exit_program_graceful, bootstyle="secondary").grid(row=0, column=3, padx=3)

# Manual LED control panel
led_panel = ttk.LabelFrame(right, text="Manual LED Control")
led_panel.grid(row=3, column=0, pady=5, sticky="ew")
led_panel.grid_columnconfigure((0, 1, 2), weight=1)
right.grid_rowconfigure(3, weight=0)
ttk.Button(led_panel, text="LED1", width=10, command=lambda: toggle_led(LED1_PIN)).grid(row=0, column=0, padx=5, pady=5)
ttk.Button(led_panel, text="LED2", width=10, command=lambda: toggle_led(LED2_PIN)).grid(row=0, column=1, padx=5, pady=5)
ttk.Button(led_panel, text="BLINK", width=10, command=toggle_blink).grid(row=0, column=2, padx=5, pady=5)

# ==== Run ====
console_listener_thread = threading.Thread(target=console_input_listener, daemon=True)
console_listener_thread.start()
auto_clear_thread = threading.Thread(target=auto_clear_loop, daemon=True)
auto_clear_thread.start()
blink_thread = threading.Thread(target=blink_loop, daemon=True)
blink_thread.start()

signal.signal(signal.SIGINT, signal_handler)
root.protocol("WM_DELETE_WINDOW", exit_program_graceful)

load_config()
update_table(None)
print("Program is ready. Close the window, or use the terminal to exit.")
root.mainloop()

# This part will only be reached after a graceful exit (root.quit())
if not exiting:
    exiting = True
    print("Mainloop finished. Final cleanup.")
    GPIO.cleanup()

print("Program exited.")
