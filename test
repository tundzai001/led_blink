import tkinter as tk
from tkinter import TclError, messagebox, filedialog
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tksheet import Sheet
import paho.mqtt.client as mqtt
import json
from datetime import datetime, timedelta
try:
    import RPi.GPIO as GPIO
    IS_PI = True
except (ImportError, RuntimeError):
    IS_PI = False
    print("C·∫¢NH B√ÅO: Kh√¥ng th·ªÉ import RPi.GPIO. Ch·∫°y ·ªü ch·∫ø ƒë·ªô m√¥ ph·ªèng GPIO.")
import threading
import time
import warnings
import configparser
import signal
import os
import sys
import queue
from collections import deque
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import matplotlib.dates as mdates
import numpy as np
from matplotlib.widgets import Slider
import matplotlib.pyplot as plt

VERBOSE = False
warnings.filterwarnings("ignore", category=DeprecationWarning)

class MockGPIO:
    BCM = "BCM_MODE"; OUT = "OUT_MODE"; LOW = 0; HIGH = 1
    def setmode(self, mode): print(f"[GPIO Mock] Set mode to {mode}")
    def setwarnings(self, state): print(f"[GPIO Mock] Set warnings to {state}")
    def setup(self, pin, mode): print(f"[GPIO Mock] Setup pin {pin} to mode {mode}")
    def output(self, pin, state): print(f"[GPIO Mock] Set pin {pin} to state {'HIGH' if state else 'LOW'}")
    def input(self, pin): return self.LOW
    def cleanup(self): print("[GPIO Mock] GPIO cleanup called.")

if not IS_PI: GPIO = MockGPIO()

# ==============================================================================
# L·ªöP LOGIC N·ªÄN (BACKEND) - Kh√¥ng thay ƒë·ªïi
# ==============================================================================
class Backend:
    def __init__(self):
        self.listening = False; self.exiting = False
        self.status_text = "Tr·∫°ng th√°i: TH·ª¶ C√îNG"; self.status_color = "red"
        self.config = configparser.ConfigParser(); self.broker = "aitogy.xyz"; self.port = 1883
        self.username = "abc"; self.password = "xyz"; self.publish_topic = ""
        self.subscribe_topics = []; self.threshold = 1.1
        self.led1_pin = 3; self.led2_pin = 27
        self.session_file = "session.json"; self.sensor_data = []
        self.plot_data_points = deque(maxlen=10000)
        self.new_data_lock = threading.Lock()
        self.new_data_queue = []; self.client = mqtt.Client(protocol=mqtt.MQTTv311)
        self.client.on_connect = self.on_connect; self.client.on_disconnect = self.on_disconnect
        self.client.on_message = self.on_message; self.stop_event = threading.Event()
        self.setup_gpio(); self.load_config()

    def setup_gpio(self):
        try:
            GPIO.setmode(GPIO.BCM); GPIO.setwarnings(False)
            GPIO.setup(self.led1_pin, GPIO.OUT); GPIO.setup(self.led2_pin, GPIO.OUT)
            GPIO.output(self.led1_pin, GPIO.LOW); GPIO.output(self.led2_pin, GPIO.LOW)
            print("GPIO setup successful.")
        except Exception as e: print(f"Error setting up GPIO. Error: {e}")

    def start_background_tasks(self):
        self.load_session_data()
        threading.Thread(target=self.auto_clear_scheduler, daemon=True).start()
        print("ƒê√£ kh·ªüi ch·∫°y c√°c t√°c v·ª• n·ªÅn.")

    def flash_led(self, pin, duration=0.3):
        try: GPIO.output(pin, GPIO.HIGH); time.sleep(duration); GPIO.output(pin, GPIO.LOW)
        except Exception as e: print(f"Error flashing LED on pin {pin}: {e}")

    def on_connect(self, client, userdata, flags, rc):
        if self.exiting: return
        if rc == 0:
            print("MQTT Connected successfully."); self.status_text = "Tr·∫°ng th√°i: T·ª∞ ƒê·ªòNG"; self.status_color = "green"
            for t in self.subscribe_topics: client.subscribe(t); print(f"Subscribed: {t}")
            if not self.subscribe_topics: self.status_text = "Tr·∫°ng th√°i: T·ª∞ ƒê·ªòNG (Kh√¥ng c√≥ topic)"
        else:
            print(f"Failed to connect, return code {rc}"); self.status_text = "Tr·∫°ng th√°i: L·ªñI K·∫æT N·ªêI"
            self.status_color = "red"; self.listening = False

    def on_disconnect(self, client, userdata, rc):
        if not self.exiting and self.listening:
            print("M·∫•t k·∫øt n·ªëi MQTT..."); self.status_text = "Tr·∫°ng th√°i: M·∫§T K·∫æT N·ªêI"; self.status_color = "orange"

    def on_message(self, client, userdata, msg):
        if not self.listening or self.exiting: return
        try:
            data = json.loads(msg.payload.decode()); name = data.get("sensorname", msg.topic)
            value = float(data.get("value", 0)); ts = float(data.get("timestamp", time.time()))
            dt_object = datetime.fromtimestamp(ts); self.plot_data_points.append((dt_object, value))
            status = "VUOT MUC" if value > self.threshold else "AN TOAN"
            record = (name, f"{value:.2f}", status, dt_object.strftime("%H:%M:%S %d-%m"))
            self.sensor_data.append(record)
            with self.new_data_lock: self.new_data_queue.append(record)
            threading.Thread(target=self.flash_led, args=(self.led1_pin,), daemon=True).start()
            if value > self.threshold: threading.Thread(target=self.flash_led, args=(self.led2_pin,), daemon=True).start()
            if self.publish_topic: self.client.publish(self.publish_topic, f"({value:.2f}, {status}, {int(ts)})")
        except Exception as e: print(f"L·ªói trong on_message: {e}")

    def get_new_data(self):
        with self.new_data_lock: data = list(self.new_data_queue); self.new_data_queue.clear(); return data

    def toggle_on(self):
        if self.listening: return True
        self.listening = True; self.status_text = "Tr·∫°ng th√°i: ƒêANG K·∫æT N·ªêI..."; self.status_color = "orange"
        if not self.broker:
            self.listening = False; self.status_text = "Tr·∫°ng th√°i: TH·ª¶ C√îNG (L·ªói Broker)"; self.status_color = "red"; return True
        self.client.username_pw_set(self.username, self.password)
        try:
            print(f"ƒêang k·∫øt n·ªëi t·ªõi MQTT broker: {self.broker}:{self.port}...")
            self.client.connect_async(self.broker, self.port, 60); self.client.loop_start()
        except Exception as e:
            self.listening = False; self.status_text = "Tr·∫°ng th√°i: L·ªñI K·∫æT N·ªêI"; self.status_color = "red"; print(f"L·ªói k·∫øt n·ªëi MQTT: {e}")
        return True

    def toggle_off(self):
        if not self.listening: return
        self.listening = False
        try: self.client.loop_stop(); self.client.disconnect(); print("ƒê√£ ng·∫Øt k·∫øt n·ªëi MQTT.")
        except Exception: pass
        self.status_text = "Tr·∫°ng th√°i: TH·ª¶ C√îNG"; self.status_color = "red"

    def update_and_reconnect(self, settings):
        self.broker = settings['broker']; self.port = int(settings['port']); self.username = settings['username']
        self.password = settings['password']; self.publish_topic = settings['publish']
        self.subscribe_topics = [t for t in settings['topics'].splitlines() if t]; self.threshold = float(settings['threshold'])
        self.save_config()
        if self.listening:
            print("ƒêang ·ªü ch·∫ø ƒë·ªô t·ª± ƒë·ªông, √°p d·ª•ng c·∫•u h√¨nh MQTT m·ªõi..."); self.toggle_off(); self.toggle_on()

    def check_leds(self):
        if self.listening:
            print("Kh√¥ng th·ªÉ ki·ªÉm tra LED ·ªü ch·∫ø ƒë·ªô T·ª∞ ƒê·ªòNG."); return False
        def run_check():
            print("Ki·ªÉm tra LED...")
            try: self.flash_led(self.led1_pin, duration=0.5); time.sleep(0.1); self.flash_led(self.led2_pin, duration=0.5)
            except Exception as e: print(f"L·ªói khi ki·ªÉm tra LED: {e}")
        threading.Thread(target=run_check, daemon=True).start()
        return True

    def auto_clear_scheduler(self):
        while not self.stop_event.is_set():
            now = datetime.now()
            if now.hour == 0 and now.minute == 0: print("ƒê√£ ƒë·∫øn 00:00, t·ª± ƒë·ªông x√≥a d·ªØ li·ªáu..."); self.clear_all_data(); time.sleep(61)
            else: time.sleep(30)

    def clear_all_data(self):
        self.sensor_data.clear(); self.plot_data_points.clear()
        with self.new_data_lock: self.new_data_queue.clear(); self.new_data_queue.append("CLEAR")
        print("ƒê√£ x√≥a d·ªØ li·ªáu n·ªÅn.")

    def load_config(self):
        if not os.path.exists('config.ini'): return
        try:
            config = configparser.ConfigParser(); config.read('config.ini')
            if "MQTT" in config:
                mqtt_cfg = config["MQTT"]; self.broker = mqtt_cfg.get("broker", self.broker); self.port = mqtt_cfg.getint("port", self.port)
                self.username = mqtt_cfg.get("username", self.username); self.password = mqtt_cfg.get("password", self.password)
                self.subscribe_topics = [t for t in mqtt_cfg.get("topics", "").splitlines() if t]; self.publish_topic = mqtt_cfg.get("publish", self.publish_topic)
            if "Settings" in config: self.threshold = config["Settings"].getfloat("threshold", self.threshold)
            print("ƒê√£ t·∫£i c·∫•u h√¨nh.")
        except Exception as e: print(f"L·ªói khi t·∫£i c·∫•u h√¨nh t·ª´ config.ini: {e}")

    def save_config(self):
        config = configparser.ConfigParser()
        config['MQTT'] = {'broker': self.broker, 'port': self.port, 'username': self.username, 'password': self.password, 'topics': "\n".join(self.subscribe_topics), 'publish': self.publish_topic}
        config['Settings'] = {'threshold': self.threshold}
        try:
            with open('config.ini', 'w') as f: config.write(f)
            print("ƒê√£ l∆∞u c·∫•u h√¨nh."); return True
        except Exception as e: print(f"L·ªói L∆∞u File: {e}"); return False

    def save_session_data(self, silent=False):
        if not silent: print(" -> ƒêang l∆∞u tr·∫°ng th√°i hi·ªán t·∫°i v√†o file...")
        try:
            plot_data_list = list(self.plot_data_points)
            plot_data_serializable = [(dt.isoformat(), val) for dt, val in plot_data_list]
            session = {"sensor_data": self.sensor_data, "plot_data_points": plot_data_serializable}
            with open(self.session_file, "w") as f: json.dump(session, f)
            if not silent: print(f" -> ƒê√£ l∆∞u tr·∫°ng th√°i v√†o {self.session_file}")
        except Exception as e: print(f" -> L·ªói khi l∆∞u tr·∫°ng th√°i: {e}")

    def load_session_data(self):
        if os.path.exists(self.session_file):
            print(f" -> T√¨m th·∫•y file tr·∫°ng th√°i {self.session_file}, ƒëang t·∫£i l·∫°i d·ªØ li·ªáu...")
            try:
                with open(self.session_file, "r") as f: session = json.load(f)
                self.sensor_data = session.get("sensor_data", [])
                plot_data_serializable = session.get("plot_data_points", [])
                self.plot_data_points.clear()
                for dt_str, val in plot_data_serializable:
                    self.plot_data_points.append((datetime.fromisoformat(dt_str), val))
                with self.new_data_lock: self.new_data_queue.extend(self.sensor_data)
                print(" -> ƒê√£ t·∫£i l·∫°i d·ªØ li·ªáu th√†nh c√¥ng.")
            except Exception as e: print(f" -> L·ªói khi t·∫£i tr·∫°ng th√°i: {e}")
            finally:
                if os.path.exists(self.session_file): os.remove(self.session_file)

    def shutdown(self, silent=False):
        if self.exiting: return
        if not silent: print("\nB·∫Øt ƒë·∫ßu qu√° tr√¨nh d·ªçn d·∫πp ƒë·ªÉ tho√°t/kh·ªüi ƒë·ªông l·∫°i...")
        self.exiting = True; self.stop_event.set()
        try: self.client.loop_stop(force=False); self.client.disconnect()
        except Exception: pass
        try: GPIO.cleanup()
        except Exception: pass
        if not silent: print(" -> Backend ƒë√£ d·ª´ng.")

# ==============================================================================
# L·ªöP GIAO DI·ªÜN NG∆Ø·ªúI D√ôNG (GUI) - C·∫£i ti·∫øn bi·ªÉu ƒë·ªì
# ==============================================================================
class AppGUI:
    def __init__(self, root, backend, on_close_callback):
        self.root = root; self.backend = backend; self.on_close_callback = on_close_callback
        self.root.title("Giao di·ªán C·∫£m bi·∫øn & ƒêi·ªÅu khi·ªÉn LED")
        self.root.geometry(f"{self.root.winfo_screenwidth()}x{self.root.winfo_screenheight()-70}+0+0")
        self.chart_window = None; self.CONVERSION_FACTORS = {"m": 1.0, "cm": 100.0, "mm": 1000.0, "ft": 3.28084}
        
        # Bi·∫øn ƒë·ªÉ qu·∫£n l√Ω thanh cu·ªôn v√† kho·∫£ng c√°ch ƒëi·ªÉm
        self.points_per_view = 50  # S·ªë ƒëi·ªÉm t·ªëi ƒëa hi·ªÉn th·ªã tr√™n m√†n h√¨nh
        self.current_start_index = 0  # Ch·ªâ s·ªë b·∫Øt ƒë·∫ßu hi·ªÉn th·ªã
        
        self.create_widgets(); self.load_initial_data()
        self.root.after(500, self.periodic_update)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close_window)

    def destroy_all_windows(self):
        if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.destroy()
        if self.root and self.root.winfo_exists(): self.root.destroy()

    def on_close_window(self):
        print("ƒê√£ ƒë√≥ng c·ª≠a s·ªï giao di·ªán. Ti·∫øn tr√¨nh n·ªÅn v·∫´n ƒëang ch·∫°y."); print("G√µ 'show' trong terminal ƒë·ªÉ m·ªü l·∫°i.")
        self.on_close_callback(); self.destroy_all_windows()

    def exit_program_graceful(self):
        if messagebox.askokcancel("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën tho√°t ho√†n to√†n ch∆∞∆°ng tr√¨nh?", parent=self.root):
            self.on_close_callback(shutdown=True)

    def create_widgets(self):
        main = ttk.Frame(self.root); main.pack(fill="both", expand=True, padx=10, pady=10)
        main.grid_columnconfigure(1, weight=1); main.grid_rowconfigure(0, weight=1)
        self.create_left_panel(main); self.create_right_panel(main)

    def create_left_panel(self, parent):
        left = ttk.LabelFrame(parent, text="C√†i ƒë·∫∑t MQTT & Ng∆∞·ª°ng")
        left.grid(row=0, column=0, sticky="nsw", padx=(0, 15), pady=10); left.grid_rowconfigure(8, weight=1)
        def add_labeled_entry(frame, label, row, width=14, show=None):
            ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w")
            entry = ttk.Entry(frame, width=width, show=show); entry.grid(row=row, column=1, sticky="ew", pady=2)
            frame.grid_columnconfigure(1, weight=1); return entry
        self.broker_entry = add_labeled_entry(left, "MQTT Broker:", 0); self.port_entry = add_labeled_entry(left, "Port:", 1)
        self.user_entry = add_labeled_entry(left, "Username:", 2); self.pass_entry = add_labeled_entry(left, "Password:", 3, show="*")
        self.pub_entry = add_labeled_entry(left, "Publish Topic:", 4); self.threshold_entry = add_labeled_entry(left, "Ng∆∞·ª°ng (m):", 5)
        show_btn = ttk.Button(left, text="üëÅ", command=self.toggle_pass, width=2); show_btn.grid(row=3, column=2, sticky="w")
        ttk.Label(left, text="Subscribe Topics:").grid(row=7, column=0, columnspan=2, sticky="w")
        self.topic_input = tk.Text(left, width=22, height=6); self.topic_input.grid(row=8, column=0, columnspan=3, pady=(0, 5), sticky="nsew")
        ttk.Button(left, text="L∆∞u & √Åp d·ª•ng", command=self.apply_and_save_config, bootstyle="primary").grid(row=9, column=0, columnspan=3, sticky="ew", pady=5)

    def create_right_panel(self, parent):
        right = ttk.Frame(parent); right.grid(row=0, column=1, sticky="nsew")
        bottom_part = ttk.Frame(right); bottom_part.pack(side=tk.BOTTOM, fill=tk.X, expand=False, pady=(10, 0))
        self.create_control_panel(bottom_part)
        top_part = ttk.Frame(right); top_part.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.status_label = ttk.Label(top_part, text="", foreground="red", font=("Arial", 11, "bold")); self.status_label.pack(side=tk.TOP, fill=tk.X, pady=(0, 5))
        sheet_frame = ttk.Frame(top_part); sheet_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.sheet = Sheet(sheet_frame, headers=["T√™n", "Gi√° tr·ªã (m)", "Tr·∫°ng th√°i", "Th·ªùi gian"], show_row_index=False, column_widths=[150, 100, 100, 150])
        self.sheet.enable_bindings(); self.sheet.set_options(font=("Arial", 10, "normal"), align="w", header_font=("Arial", 10, "bold"))
        self.sheet.disable_bindings(["edit_cell", "arrowkeys"]); self.sheet.pack(fill=tk.BOTH, expand=True)

    def create_control_panel(self, parent_frame):
        ctrl = ttk.Frame(parent_frame); ctrl.pack(side=tk.TOP, fill=tk.X, expand=True)
        for i in range(5): ctrl.grid_columnconfigure(i, weight=1)
        ttk.Button(ctrl, text="T·ª± ƒë·ªông (ON)", command=self.backend.toggle_on, bootstyle="success").grid(row=0, column=0, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Th·ªß c√¥ng (OFF)", command=self.backend.toggle_off, bootstyle="danger").grid(row=0, column=1, padx=2, sticky="ew")
        self.save_csv_button = ttk.Button(ctrl, text="L∆∞u CSV", command=self.save_to_csv, bootstyle="info"); self.save_csv_button.grid(row=0, column=2, padx=2, sticky="ew")
        ttk.Button(ctrl, text="X√≥a D·ªØ Li·ªáu", command=self.clear_table_gui, bootstyle="warning").grid(row=0, column=3, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Xem Bi·ªÉu ƒê·ªì", command=self.show_chart_window, bootstyle="primary").grid(row=0, column=4, padx=2, sticky="ew")
        led_panel = ttk.LabelFrame(parent_frame, text="Ki·ªÉm tra Thi·∫øt b·ªã"); led_panel.pack(side=tk.TOP, fill=tk.X, expand=True, pady=(5, 0))
        led_panel.grid_columnconfigure(0, weight=3); led_panel.grid_columnconfigure(1, weight=1)
        ttk.Button(led_panel, text="Ki·ªÉm tra LED", command=self.on_check_led_click).grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        ttk.Button(led_panel, text="Tho√°t", command=self.exit_program_graceful, bootstyle="secondary").grid(row=0, column=1, padx=5, pady=5, sticky="ew")

    def on_check_led_click(self):
        success = self.backend.check_leds()
        if not success: messagebox.showwarning("C·∫£nh b√°o", "Ch·ªâ c√≥ th·ªÉ ki·ªÉm tra LED ·ªü ch·∫ø ƒë·ªô TH·ª¶ C√îNG (OFF).", parent=self.root)

    def load_initial_data(self):
        self.broker_entry.delete(0, tk.END); self.port_entry.delete(0, tk.END); self.user_entry.delete(0, tk.END)
        self.pass_entry.delete(0, tk.END); self.pub_entry.delete(0, tk.END); self.threshold_entry.delete(0, tk.END)
        self.topic_input.delete("1.0", tk.END); self.broker_entry.insert(0, self.backend.broker)
        self.port_entry.insert(0, str(self.backend.port)); self.user_entry.insert(0, self.backend.username)
        self.pass_entry.insert(0, self.backend.password); self.pub_entry.insert(0, self.backend.publish_topic)
        self.threshold_entry.insert(0, str(self.backend.threshold)); self.topic_input.insert("1.0", "\n".join(self.backend.subscribe_topics))
        initial_data = self.backend.get_new_data()
        if initial_data:
            valid_data = [d for d in initial_data if isinstance(d, tuple)]
            self.sheet.set_sheet_data(valid_data)
        else: self.sheet.set_sheet_data([])
        self.update_status_label()

    def periodic_update(self):
        if self.backend.exiting or not self.root.winfo_exists(): return
        self.update_status_label()
        new_records = self.backend.get_new_data()
        if new_records:
            if any(record == "CLEAR" for record in new_records):
                self.sheet.set_sheet_data([])
                # Reset thanh cu·ªôn khi x√≥a d·ªØ li·ªáu
                self.current_start_index = 0
                print("GUI ƒë√£ nh·∫≠n t√≠n hi·ªáu v√† x√≥a b·∫£ng.")
            else:
                for record in new_records:
                    if isinstance(record, tuple): self.add_row_to_table(record)
            if self.chart_window and self.chart_window.winfo_exists(): self.update_plot()
        if self.root.winfo_exists(): self.root.after(500, self.periodic_update)

    def update_status_label(self):
        if self.status_label.cget("text") != self.backend.status_text or self.status_label.cget("foreground") != self.backend.status_color:
            self.status_label.config(text=self.backend.status_text, foreground=self.backend.status_color)

    def toggle_pass(self): self.pass_entry.config(show="" if self.pass_entry.cget("show") else "*")

    def apply_and_save_config(self):
        settings = { 'broker': self.broker_entry.get(), 'port': self.port_entry.get(), 'username': self.user_entry.get(), 'password': self.pass_entry.get(), 'topics': self.topic_input.get("1.0", "end").strip(), 'publish': self.pub_entry.get(), 'threshold': self.threshold_entry.get() }
        try:
            int(settings['port']); float(settings['threshold']); self.backend.update_and_reconnect(settings)
            messagebox.showinfo("Th√†nh c√¥ng", "ƒê√£ l∆∞u v√† √°p d·ª•ng c·∫•u h√¨nh.", parent=self.root)
        except ValueError as e: messagebox.showerror("L·ªói", f"D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá: {e}", parent=self.root)
        except Exception as e: messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ √°p d·ª•ng c·∫•u h√¨nh: {e}", parent=self.root)

    def add_row_to_table(self, record):
        self.sheet.insert_row(list(record))
        self.sheet.deselect("all")
        self.sheet.dehighlight_all()
        new_row_index = self.sheet.get_total_rows() - 1
        if new_row_index >= 0:
            self.sheet.highlight_rows([new_row_index], bg='#D2EAF8')
            self.sheet.see(row=new_row_index, column=0)

    def clear_table_gui(self):
        self.sheet.set_sheet_data([]); self.backend.clear_all_data()
        # Reset thanh cu·ªôn khi x√≥a d·ªØ li·ªáu
        self.current_start_index = 0
        if self.chart_window and self.chart_window.winfo_exists(): self.update_plot()
        print("ƒê√£ x√≥a d·ªØ li·ªáu t·ª´ giao di·ªán.")

    def save_to_csv(self):
        if not self.backend.sensor_data: messagebox.showinfo("Th√¥ng b√°o", "Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ l∆∞u.", parent=self.root); return
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")], parent=self.root)
        if path: self.save_csv_button.config(state="disabled"); threading.Thread(target=self._write_csv_in_background, args=(path, list(self.backend.sensor_data)), daemon=True).start()

    def _write_csv_in_background(self, path, data_to_save):
        try:
            import csv
            with open(path, "w", newline="", encoding='utf-8') as f:
                writer = csv.writer(f); writer.writerow(["T√™n", "Gi√° tr·ªã (m)", "Tr·∫°ng th√°i", "Th·ªùi gian"]); writer.writerows(data_to_save)
            if self.root.winfo_exists(): self.root.after(0, lambda: messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ l∆∞u d·ªØ li·ªáu v√†o {path}", parent=self.root))
        except Exception as e:
            if self.root.winfo_exists(): self.root.after(0, lambda: messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ l∆∞u file: {e}", parent=self.root))
        finally:
            if self.root.winfo_exists(): self.root.after(0, lambda: self.save_csv_button.config(state="normal"))
# Ho√†n thi·ªán ph·∫ßn create_widgets trong class AppGUI
def show_chart_window(self):
    if self.chart_window is not None and self.chart_window.winfo_exists():
        self.chart_window.lift(); return

    self.chart_window = tk.Toplevel(self.root)
    self.chart_window.title("Bi·ªÉu ƒë·ªì D·ªØ li·ªáu C·∫£m bi·∫øn")
    self.chart_window.geometry("1200x800")
    self.chart_window.protocol("WM_DELETE_WINDOW", self.on_chart_close)
    
    # Khung ƒëi·ªÅu khi·ªÉn ph√≠a tr√™n
    top_frame = ttk.Frame(self.chart_window)
    top_frame.pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)
    
    # D√≤ng ƒë·∫ßu ti√™n: ƒê∆°n v·ªã v√† t·ª± ƒë·ªông cu·ªôn
    first_row = ttk.Frame(top_frame)
    first_row.pack(side=tk.TOP, fill=tk.X, pady=(0, 5))
    
    ttk.Label(first_row, text="Ch·ªçn ƒë∆°n v·ªã:").pack(side=tk.LEFT, padx=(0, 5))
    self.unit_selector_combobox = ttk.Combobox(first_row, state="readonly", values=list(self.CONVERSION_FACTORS.keys()))
    self.unit_selector_combobox.set("m")
    self.unit_selector_combobox.pack(side=tk.LEFT, padx=5)
    self.unit_selector_combobox.bind("<<ComboboxSelected>>", lambda e: self.update_plot())
    
    # Checkbox t·ª± ƒë·ªông theo d√µi
    self.auto_follow_var = tk.BooleanVar(value=True)
    auto_follow_check = ttk.Checkbutton(first_row, text="T·ª± ƒë·ªông theo d√µi d·ªØ li·ªáu m·ªõi", variable=self.auto_follow_var)
    auto_follow_check.pack(side=tk.LEFT, padx=20)
    
    # D√≤ng th·ª© hai: ƒêi·ªÅu khi·ªÉn s·ªë ƒëi·ªÉm hi·ªÉn th·ªã
    second_row = ttk.Frame(top_frame)
    second_row.pack(side=tk.TOP, fill=tk.X, pady=(0, 5))
    
    ttk.Label(second_row, text="ƒêi·ªÉm hi·ªÉn th·ªã:").pack(side=tk.LEFT, padx=(0, 5))
    self.points_spinbox = ttk.Spinbox(second_row, from_=20, to=200, value=self.points_per_view, width=10)
    self.points_spinbox.pack(side=tk.LEFT, padx=5)
    self.points_spinbox.bind("<Return>", lambda e: self.update_points_per_view())
    
    update_points_btn = ttk.Button(second_row, text="C·∫≠p nh·∫≠t", command=self.update_points_per_view)
    update_points_btn.pack(side=tk.LEFT, padx=5)
    
    # N√∫t ƒëi·ªÅu khi·ªÉn
    ttk.Button(second_row, text="‚Üê Tr∆∞·ªõc", command=self.move_view_backward).pack(side=tk.LEFT, padx=10)
    ttk.Button(second_row, text="Sau ‚Üí", command=self.move_view_forward).pack(side=tk.LEFT, padx=5)
    ttk.Button(second_row, text="M·ªõi nh·∫•t", command=self.go_to_latest).pack(side=tk.LEFT, padx=10)
    
    # Khung bi·ªÉu ƒë·ªì
    chart_frame = ttk.Frame(self.chart_window)
    chart_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True, padx=10, pady=5)
    
    # T·∫°o figure v√† axes
    self.fig = Figure(figsize=(12, 6), dpi=100, facecolor='white')
    self.ax = self.fig.add_subplot(111)
    
    # Canvas ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì
    self.canvas = FigureCanvasTkAgg(self.fig, master=chart_frame)
    self.canvas.draw()
    self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
    
    # Thanh tr∆∞·ª£t ph√≠a d∆∞·ªõi
    slider_frame = ttk.Frame(self.chart_window)
    slider_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)
    
    self.slider_label = ttk.Label(slider_frame, text="V·ªã tr√≠ xem: 0/0")
    self.slider_label.pack(side=tk.TOP, pady=(0, 5))
    
    # Thanh tr∆∞·ª£t
    self.position_var = tk.DoubleVar()
    self.position_scale = ttk.Scale(slider_frame, from_=0, to=100, orient=tk.HORIZONTAL, 
                                   variable=self.position_var, command=self.on_slider_change)
    self.position_scale.pack(side=tk.TOP, fill=tk.X, padx=5)
    
    # Th√¥ng tin hi·ªÉn th·ªã
    info_frame = ttk.Frame(self.chart_window)
    info_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=(0, 5))
    
    self.info_label = ttk.Label(info_frame, text="T·ªïng ƒëi·ªÉm: 0 | Hi·ªÉn th·ªã: 0-0", font=("Arial", 9))
    self.info_label.pack(side=tk.LEFT)
    
    # Kh·ªüi t·∫°o bi·ªÉu ƒë·ªì
    self.setup_plot()
    self.update_plot()

def update_points_per_view(self):
    """C·∫≠p nh·∫≠t s·ªë ƒëi·ªÉm hi·ªÉn th·ªã tr√™n view"""
    try:
        new_points = int(self.points_spinbox.get())
        if new_points < 10:
            new_points = 10
        elif new_points > 500:
            new_points = 500
        
        self.points_per_view = new_points
        self.points_spinbox.set(new_points)
        
        # ƒêi·ªÅu ch·ªânh current_start_index ƒë·ªÉ kh√¥ng v∆∞·ª£t qu√° gi·ªõi h·∫°n
        total_points = len(self.backend.plot_data_points)
        if total_points > 0:
            max_start = max(0, total_points - self.points_per_view)
            self.current_start_index = min(self.current_start_index, max_start)
        
        self.update_plot()
        
    except ValueError:
        messagebox.showerror("L·ªói", "S·ªë ƒëi·ªÉm ph·∫£i l√† m·ªôt s·ªë nguy√™n h·ª£p l·ªá", parent=self.chart_window)
        self.points_spinbox.set(self.points_per_view)

def setup_plot(self):
    """Thi·∫øt l·∫≠p bi·ªÉu ƒë·ªì ban ƒë·∫ßu"""
    self.ax.clear()
    self.ax.set_title('D·ªØ li·ªáu C·∫£m bi·∫øn Theo Th·ªùi Gian', fontsize=14, fontweight='bold', pad=20)
    self.ax.set_xlabel('Th·ªùi gian', fontsize=12)
    self.ax.set_ylabel('Gi√° tr·ªã', fontsize=12)
    self.ax.grid(True, alpha=0.3, linestyle='--')
    
    # Thi·∫øt l·∫≠p formatter cho tr·ª•c x
    self.ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
    self.ax.xaxis.set_major_locator(mdates.MinuteLocator(interval=1))
    
    # Xoay nh√£n th·ªùi gian
    plt.setp(self.ax.xaxis.get_majorticklabels(), rotation=45, ha='right')
    
    self.fig.tight_layout()

def update_plot(self):
    """C·∫≠p nh·∫≠t bi·ªÉu ƒë·ªì v·ªõi d·ªØ li·ªáu m·ªõi"""
    if not hasattr(self, 'ax') or not self.chart_window.winfo_exists():
        return
    
    plot_data = list(self.backend.plot_data_points)
    total_points = len(plot_data)
    
    # C·∫≠p nh·∫≠t slider
    self.update_slider_range(total_points)
    
    if total_points == 0:
        self.ax.clear()
        self.setup_plot()
        self.ax.text(0.5, 0.5, 'Ch∆∞a c√≥ d·ªØ li·ªáu', horizontalalignment='center', 
                    verticalalignment='center', transform=self.ax.transAxes, 
                    fontsize=16, alpha=0.5)
        self.canvas.draw()
        return
    
    # T·ª± ƒë·ªông theo d√µi d·ªØ li·ªáu m·ªõi
    if self.auto_follow_var.get() and total_points > self.points_per_view:
        self.current_start_index = total_points - self.points_per_view
        self.position_var.set(100)  # ƒê·∫∑t slider v·ªÅ cu·ªëi
    
    # T√≠nh to√°n ph·∫°m vi hi·ªÉn th·ªã
    start_idx = max(0, self.current_start_index)
    end_idx = min(total_points, start_idx + self.points_per_view)
    
    # ƒêi·ªÅu ch·ªânh start_idx n·∫øu c·∫ßn
    if end_idx - start_idx < self.points_per_view and total_points >= self.points_per_view:
        start_idx = max(0, end_idx - self.points_per_view)
    
    display_data = plot_data[start_idx:end_idx]
    
    if not display_data:
        return
    
    # L·∫•y ƒë∆°n v·ªã chuy·ªÉn ƒë·ªïi
    unit = self.unit_selector_combobox.get()
    conversion_factor = self.CONVERSION_FACTORS.get(unit, 1.0)
    
    # T√°ch th·ªùi gian v√† gi√° tr·ªã
    times = [item[0] for item in display_data]
    values = [item[1] * conversion_factor for item in display_data]
    
    # X√≥a bi·ªÉu ƒë·ªì c≈© v√† v·∫Ω m·ªõi
    self.ax.clear()
    self.setup_plot()
    
    # V·∫Ω ƒë∆∞·ªùng n·ªëi c√°c ƒëi·ªÉm
    self.ax.plot(times, values, marker='o', linestyle='-', linewidth=2, 
                markersize=4, color='#1f77b4', alpha=0.8, label='D·ªØ li·ªáu c·∫£m bi·∫øn')
    
    # V·∫Ω ng∆∞·ª°ng
    if times:
        threshold_value = self.backend.threshold * conversion_factor
        self.ax.axhline(y=threshold_value, color='red', linestyle='--', 
                       linewidth=2, alpha=0.7, label=f'Ng∆∞·ª°ng ({threshold_value:.2f} {unit})')
        
        # Highlight c√°c ƒëi·ªÉm v∆∞·ª£t ng∆∞·ª°ng
        over_threshold_times = []
        over_threshold_values = []
        for t, v in zip(times, values):
            if v > threshold_value:
                over_threshold_times.append(t)
                over_threshold_values.append(v)
        
        if over_threshold_times:
            self.ax.scatter(over_threshold_times, over_threshold_values, 
                          color='red', s=50, zorder=5, alpha=0.8, label='V∆∞·ª£t ng∆∞·ª°ng')
    
    # Thi·∫øt l·∫≠p tr·ª•c y v·ªõi ƒë∆°n v·ªã
    self.ax.set_ylabel(f'Gi√° tr·ªã ({unit})', fontsize=12)
    
    # Thi·∫øt l·∫≠p tr·ª•c x v·ªõi kho·∫£ng c√°ch c·ªë ƒë·ªãnh
    if len(times) > 1:
        time_range = times[-1] - times[0]
        if time_range.total_seconds() > 0:
            # T√≠nh to√°n kho·∫£ng c√°ch tick d·ª±a tr√™n ph·∫°m vi th·ªùi gian
            if time_range.total_seconds() < 300:  # D∆∞·ªõi 5 ph√∫t
                self.ax.xaxis.set_major_locator(mdates.SecondLocator(interval=30))
                self.ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
            elif time_range.total_seconds() < 3600:  # D∆∞·ªõi 1 gi·ªù
                self.ax.xaxis.set_major_locator(mdates.MinuteLocator(interval=5))
                self.ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))
            else:  # Tr√™n 1 gi·ªù
                self.ax.xaxis.set_major_locator(mdates.MinuteLocator(interval=15))
                self.ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))
    
    # Xoay nh√£n th·ªùi gian
    plt.setp(self.ax.xaxis.get_majorticklabels(), rotation=45, ha='right')
    
    # Th√™m legend
    self.ax.legend(loc='upper left', framealpha=0.9)
    
    # C·∫≠p nh·∫≠t th√¥ng tin hi·ªÉn th·ªã
    self.info_label.config(text=f"T·ªïng ƒëi·ªÉm: {total_points} | Hi·ªÉn th·ªã: {start_idx+1}-{end_idx} | ƒê∆°n v·ªã: {unit}")
    
    # Tight layout v√† v·∫Ω
    self.fig.tight_layout()
    self.canvas.draw()

def update_slider_range(self, total_points):
    """C·∫≠p nh·∫≠t ph·∫°m vi c·ªßa slider"""
    if total_points <= self.points_per_view:
        self.position_scale.config(state="disabled")
        self.slider_label.config(text="V·ªã tr√≠ xem: T·∫•t c·∫£")
    else:
        self.position_scale.config(state="normal")
        max_start_index = total_points - self.points_per_view
        current_percentage = (self.current_start_index / max_start_index * 100) if max_start_index > 0 else 0
        
        if not self.auto_follow_var.get():  # Ch·ªâ c·∫≠p nh·∫≠t n·∫øu kh√¥ng ·ªü ch·∫ø ƒë·ªô t·ª± ƒë·ªông
            self.position_var.set(current_percentage)
        
        self.slider_label.config(text=f"V·ªã tr√≠ xem: {self.current_start_index + 1}-{self.current_start_index + self.points_per_view}")

def on_slider_change(self, value):
    """X·ª≠ l√Ω khi thanh tr∆∞·ª£t thay ƒë·ªïi"""
    if self.auto_follow_var.get():  # T·∫Øt t·ª± ƒë·ªông theo d√µi khi user k√©o slider
        self.auto_follow_var.set(False)
    
    total_points = len(self.backend.plot_data_points)
    if total_points <= self.points_per_view:
        return
    
    max_start_index = total_points - self.points_per_view
    percentage = float(value)
    self.current_start_index = int((percentage / 100) * max_start_index)
    
    self.update_plot()

def move_view_backward(self):
    """Di chuy·ªÉn view v·ªÅ ph√≠a tr∆∞·ªõc (d·ªØ li·ªáu c≈© h∆°n)"""
    self.auto_follow_var.set(False)  # T·∫Øt t·ª± ƒë·ªông theo d√µi
    
    step = max(1, self.points_per_view // 4)  # Di chuy·ªÉn 1/4 view
    self.current_start_index = max(0, self.current_start_index - step)
    self.update_plot()

def move_view_forward(self):
    """Di chuy·ªÉn view v·ªÅ ph√≠a sau (d·ªØ li·ªáu m·ªõi h∆°n)"""
    total_points = len(self.backend.plot_data_points)
    max_start_index = max(0, total_points - self.points_per_view)
    
    step = max(1, self.points_per_view // 4)  # Di chuy·ªÉn 1/4 view
    self.current_start_index = min(max_start_index, self.current_start_index + step)
    
    # N·∫øu ƒë√£ ƒë·∫øn cu·ªëi, b·∫≠t l·∫°i t·ª± ƒë·ªông theo d√µi
    if self.current_start_index >= max_start_index:
        self.auto_follow_var.set(True)
    
    self.update_plot()

def go_to_latest(self):
    """Chuy·ªÉn v·ªÅ d·ªØ li·ªáu m·ªõi nh·∫•t"""
    self.auto_follow_var.set(True)
    total_points = len(self.backend.plot_data_points)
    if total_points > self.points_per_view:
        self.current_start_index = total_points - self.points_per_view
    else:
        self.current_start_index = 0
    self.update_plot()

def on_chart_close(self):
    """X·ª≠ l√Ω khi ƒë√≥ng c·ª≠a s·ªï bi·ªÉu ƒë·ªì"""
    self.chart_window.destroy()
    self.chart_window = None
    
# ==============================================================================
# KH·ªêI ƒêI·ªÄU KHI·ªÇN CH√çNH (MAIN CONTROLLER)
# ==============================================================================
class MainController:
    def __init__(self, backend, command_queue):
        self.backend = backend
        self.command_queue = command_queue
        self.app_instance = None
        self.root = ttk.Window()
        self.root.withdraw()

    def run(self):
        self.check_for_commands()
        self.root.mainloop()

    def check_for_commands(self):
        try:
            command = self.command_queue.get_nowait()
            if command == 'show': self.create_gui_window()
            elif command == 'exit': self.handle_shutdown()
            elif command == 'restart': self.handle_restart()
        except queue.Empty: pass
        finally:
            if not self.backend.exiting: self.root.after(100, self.check_for_commands)

    def create_gui_window(self):
        if self.app_instance and self.app_instance.root.winfo_exists():
            print("Giao di·ªán ƒë√£ ƒëang ch·∫°y r·ªìi."); self.app_instance.root.lift(); return
        print("ƒêang kh·ªüi ƒë·ªông giao di·ªán ng∆∞·ªùi d√πng...")
        toplevel_window = tk.Toplevel(self.root)
        self.app_instance = AppGUI(toplevel_window, self.backend, self.on_gui_close)

    def on_gui_close(self, shutdown=False):
        self.app_instance = None
        if shutdown: self.handle_shutdown()

    def handle_shutdown(self, silent=False):
        if not silent: print(" -> Nh·∫≠n l·ªánh tho√°t...")
        if self.app_instance: self.app_instance.destroy_all_windows(); self.app_instance = None
        self.backend.shutdown(silent=silent)
        self.root.destroy()

    def handle_restart(self):
        print(" -> Nh·∫≠n l·ªánh kh·ªüi ƒë·ªông l·∫°i...")
        global needs_restart; needs_restart = True
        self.backend.save_session_data(silent=True)
        self.handle_shutdown(silent=True)

# ==============================================================================
# KH·ªêI TH·ª∞C THI CH√çNH
# ==============================================================================
needs_restart = False
command_queue = queue.Queue()

def console_input_listener(cmd_queue):
    while True:
        try:
            command = input().strip().lower()
            if command: cmd_queue.put(command)
            if command in ['exit', 'restart']: break
        except (EOFError, KeyboardInterrupt):
            cmd_queue.put('exit'); break

def signal_handler(signum, frame):
    print("\nNh·∫≠n t√≠n hi·ªáu ng·∫Øt (Ctrl+C), ƒëang tho√°t...")
    command_queue.put('exit')

if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal_handler)
    backend_instance = Backend()
    backend_instance.start_background_tasks()
    console_thread = threading.Thread(target=console_input_listener, args=(command_queue,), daemon=True)
    console_thread.start()
    print("Ch∆∞∆°ng tr√¨nh ƒë√£ s·∫µn s√†ng.")
    print("G√µ 'show' ƒë·ªÉ m·ªü giao di·ªán, 'exit' ƒë·ªÉ tho√°t, 'restart' ƒë·ªÉ kh·ªüi ƒë·ªông l·∫°i.")
    main_controller = MainController(backend_instance, command_queue)
    command_queue.put('show')
    main_controller.run()
    if needs_restart:
        print("\n" + "="*50); print("KH·ªûI ƒê·ªòNG L·∫†I CH∆Ø∆†NG TR√åNH..."); print("="*50 + "\n")
        try: os.execv(sys.executable, ['python'] + sys.argv)
        except Exception as e: print(f"L·ªñI KH√îNG TH·ªÇ KH·ªûI ƒê·ªòNG L·∫†I: {e}")
    else: print("Ch∆∞∆°ng tr√¨nh ƒë√£ k·∫øt th√∫c.")
