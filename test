import tkinter as tk
from tkinter import messagebox, filedialog, Toplevel
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tksheet import Sheet
import paho.mqtt.client as mqtt
import json
from datetime import datetime
import threading
import time
import warnings
import configparser
import signal
import os
import sys
import queue
from collections import deque
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt
import numpy as np
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1"
import pygame
import RPi.GPIO as GPIO

# --- C√ÅC H·∫∞NG S·ªê TO√ÄN C·ª§C ---
warnings.filterwarnings("ignore", category=DeprecationWarning)
CONFIG_FILE = 'config.ini'
SESSION_FILE = "session.json"
DATA_CLEAR_SIGNAL = "CLEAR_ALL_DATA"
LED1_PIN = 3
LED2_PIN = 27
MAX_PLOT_POINTS = 10000
SOUNDS_DIR = "/home/vippro123/Desktop/code/sounds"

# --- D·ªÆ LI·ªÜU B·∫¢NG CRUDEN (1996) M·∫∂C ƒê·ªäNH ---
# Gi√° tr·ªã ƒë∆∞·ª£c l∆∞u tr·ªØ d∆∞·ªõi d·∫°ng ƒë∆°n v·ªã c∆° s·ªü: m/gi√¢y
DEFAULT_VELOCITY_THRESHOLDS = {
    'nguy_cap': 5.0,
    'rat_nhanh': 0.05,
    'nhanh': 0.0005,
    'trung_binh': 0.000005,
    'cham': 5e-09,
    'rat_cham': 5.5e-10,
}

# C√°c m·ª©c ph√¢n lo·∫°i v√† t√™n hi·ªÉn th·ªã
VELOCITY_CLASSIFICATION = [
    ("nguy_cap", "Nguy c·∫•p"),
    ("rat_nhanh", "R·∫•t nhanh"),
    ("nhanh", "Nhanh"),
    ("trung_binh", "Trung b√¨nh"),
    ("cham", "Ch·∫≠m"),
    ("rat_cham", "R·∫•t ch·∫≠m")
]

# ==============================================================================
# L·ªöP LOGIC N·ªÄN (BACKEND) - Logic c·∫£nh b√°o ƒëa c·∫•p
# ==============================================================================
class Backend:
    def __init__(self):
        self.listening = False
        self.exiting = False
        self.status_text = "Tr·∫°ng th√°i: TH·ª¶ C√îNG"
        self.status_color = "red"
        self.config = configparser.ConfigParser()
        self.broker, self.port, self.username, self.password = "aitogy.xyz", 1883, "abc", "xyz"
        self.publish_topic = ""
        self.subscribe_topics = []

        # Ng∆∞·ª°ng cho M·ª±c n∆∞·ªõc
        self.water_level_warning_threshold = 1.0
        self.water_level_critical_threshold = 1.2

        # Ng∆∞·ª°ng cho GNSS (t·ªëc ƒë·ªô) - s·∫Ω ƒë∆∞·ª£c t·∫£i t·ª´ config
        self.velocity_thresholds = {}
        self.velocity_display_options = {}
        self.last_gnss_reading = {'timestamp': None, 'value': None}


        self.led1_pin, self.led2_pin = LED1_PIN, LED2_PIN
        self.warning_sound = None
        self.critical_sound = None
        self.siren_sound = None
        self.decreasing_sound = None
        self.safe_sound_1 = None
        self.safe_sound_2 = None
        self.alert_thread = None
        self.mixer_initialized = False
        self.current_alert_level = 0
        self.safe_readings_count = 0
        self.warning_readings_count = 0
        self.decreasing_warning_count = 0
        self.was_in_high_level_state = False
        self.initial_safe_played = False
        self.safe_return_phase = 0
        self.sensor_data = []
        self.plot_data_points = deque(maxlen=MAX_PLOT_POINTS)
        self.gui_update_queue = queue.Queue()
        self.client = mqtt.Client(protocol=mqtt.MQTTv311)
        self.client.on_connect = self.on_connect
        self.client.on_disconnect = self.on_disconnect
        self.client.on_message = self.on_message
        self.stop_event = threading.Event()
        self.setup_audio_mixer()
        self.setup_gpio()
        self.load_config()

    def setup_audio_mixer(self):
        try:
            pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=4096)
            self.mixer_initialized = True
        except Exception as e:
            print(f"L·ªñI: Kh√¥ng th·ªÉ kh·ªüi t·∫°o pygame mixer: {e}")
            self.mixer_initialized = False

    def _load_audio_files(self):
        if not self.mixer_initialized: return
        # ... (Ph·∫ßn code n√†y kh√¥ng thay ƒë·ªïi)
        if not self.mixer_initialized: return
        SIREN_FILE = os.path.join(SOUNDS_DIR, "coi1.mp3")
        WARNING_FILE = os.path.join(SOUNDS_DIR, "warning.mp3")
        DANGER_FILE = os.path.join(SOUNDS_DIR, "danger.mp3")
        DECREASE_FILE = os.path.join(SOUNDS_DIR, "decrease.mp3")
        SAFE_FILE_1 = os.path.join(SOUNDS_DIR, "safe.mp3")
        SAFE_FILE_2 = os.path.join(SOUNDS_DIR, "safe2.mp3")
        try:
            if os.path.exists(SIREN_FILE): self.siren_sound = pygame.mixer.Sound(SIREN_FILE)
            else: print(f"C·∫¢NH B√ÅO: Kh√¥ng t√¨m th·∫•y file {SIREN_FILE}")
            if os.path.exists(WARNING_FILE): self.warning_sound = pygame.mixer.Sound(WARNING_FILE)
            else: print(f"C·∫¢NH B√ÅO: Kh√¥ng t√¨m th·∫•y file {WARNING_FILE}")
            if os.path.exists(DANGER_FILE): self.critical_sound = pygame.mixer.Sound(DANGER_FILE)
            else: print(f"C·∫¢NH B√ÅO: Kh√¥ng t√¨m th·∫•y file {DANGER_FILE}")
            if os.path.exists(DECREASE_FILE): self.decreasing_sound = pygame.mixer.Sound(DECREASE_FILE)
            else: print(f"C·∫¢NH B√ÅO: Kh√¥ng t√¨m th·∫•y file {DECREASE_FILE}")
            if os.path.exists(SAFE_FILE_1): self.safe_sound_1 = pygame.mixer.Sound(SAFE_FILE_1)
            else: print(f"C·∫¢NH B√ÅO: Kh√¥ng t√¨m th·∫•y file {SAFE_FILE_1}")
            if os.path.exists(SAFE_FILE_2): self.safe_sound_2 = pygame.mixer.Sound(SAFE_FILE_2)
            else: print(f"C·∫¢NH B√ÅO: Kh√¥ng t√¨m th·∫•y file {SAFE_FILE_2}")
        except Exception as e:
            print(f"L·ªñI khi t·∫£i file √¢m thanh: {e}")


    def on_message(self, client, userdata, msg):
        if not self.listening or self.exiting: return
        try:
            data = json.loads(msg.payload.decode())
            name = data.get("sensorname", msg.topic.split('/')[-1])
            value = float(data.get("value"))
            ts = float(data.get("timestamp", time.time()))

            new_level = 0
            status_text = "AN TOAN"

            # Ph√¢n lu·ªìng logic: GNSS d√πng t·ªëc ƒë·ªô, c√°c lo·∫°i kh√°c d√πng ng∆∞·ª°ng tƒ©nh
            if "gnss" in name.lower():
                # --- LOGIC C·∫¢NH B√ÅO D·ª∞A TR√äN T·ªêC ƒê·ªò CHO GNSS ---
                if self.last_gnss_reading['timestamp'] is None:
                    # ƒê√¢y l√† ƒëi·ªÉm d·ªØ li·ªáu ƒë·∫ßu ti√™n, ch·ªâ l∆∞u l·∫°i v√† tho√°t
                    self.last_gnss_reading = {'timestamp': ts, 'value': value}
                    return

                delta_time = ts - self.last_gnss_reading['timestamp']
                if delta_time <= 0: # Tr√°nh chia cho 0 ho·∫∑c du h√†nh th·ªùi gian
                    return

                delta_value = value - self.last_gnss_reading['value']
                velocity_mps = abs(delta_value / delta_time) # T·ªëc ƒë·ªô m/s

                # So s√°nh v·ªõi ng∆∞·ª°ng t·ªëc ƒë·ªô t·ª´ cao ƒë·∫øn th·∫•p
                for key, classification_name in VELOCITY_CLASSIFICATION:
                    if velocity_mps >= self.velocity_thresholds.get(key, 999):
                        status_text = classification_name.upper()
                        if key in ['nguy_cap', 'rat_nhanh', 'nhanh']:
                            new_level = 2 if key == 'nguy_cap' else 1
                        break
                
                self.last_gnss_reading = {'timestamp': ts, 'value': value}

            else:
                # --- LOGIC C·∫¢NH B√ÅO Tƒ®NH CHO C√ÅC C·∫¢M BI·∫æN KH√ÅC (Vd: M·ª±c n∆∞·ªõc) ---
                if value >= self.water_level_critical_threshold:
                    new_level = 2
                    status_text = "NGUY HIEM"
                elif value >= self.water_level_warning_threshold:
                    new_level = 1
                    status_text = "CANH BAO"
                else:
                    new_level = 0
                    status_text = "AN TOAN"

            # --- PH·∫¶N X·ª¨ L√ù √ÇM THANH V√Ä TR·∫†NG TH√ÅI CHUNG ---
            # (Ph·∫ßn n√†y gi·ªØ nguy√™n logic ph·ª©c t·∫°p v·ªÅ √¢m thanh c·ªßa b·∫°n)
            previous_level = self.current_alert_level
            # ... (To√†n b·ªô logic if/elif/else cho new_level, safe_readings_count, was_in_high_level_state... c·ªßa b·∫°n ƒë∆∞·ª£c ƒë·∫∑t ·ªü ƒë√¢y)
            # V√≠ d·ª• m·ªôt logic ƒë∆°n gi·∫£n h√≥a ƒë·ªÉ thay th·∫ø:
            if new_level != previous_level:
                 print(f"Chuy·ªÉn tr·∫°ng th√°i t·ª´ {previous_level} -> {new_level}")
                 if new_level == 2:
                     self._play_sequence_in_thread([self.siren_sound, self.critical_sound])
                 elif new_level == 1:
                     self._play_sequence_in_thread([self.siren_sound, self.warning_sound])

            self.current_alert_level = new_level
            dt_object = datetime.fromtimestamp(ts)
            record = (name, str(value), status_text, dt_object.strftime("%H:%M:%S %d-%m"))
            
            self.sensor_data.append(record)
            self.plot_data_points.append((dt_object, value))
            self.gui_update_queue.put(record)
            
            # Flash LED
            threading.Thread(target=self.flash_led, args=(self.led1_pin,), daemon=True).start()
            if new_level > 0:
                threading.Thread(target=self.flash_led, args=(self.led2_pin,), daemon=True).start()

            # Publish
            if self.publish_topic:
                payload_out_str = f"{name},{value},{status_text},{ts}"
                self.client.publish(self.publish_topic, payload_out_str)

        except (json.JSONDecodeError, ValueError, KeyError) as e:
            print(f"L·ªói x·ª≠ l√Ω message: {e}")


    def stop_all_alerts(self):
        # ... (Kh√¥ng thay ƒë·ªïi)
        if self.mixer_initialized:
            pygame.mixer.stop()

    def _play_sequence_in_thread(self, sound_list):
        # ... (Kh√¥ng thay ƒë·ªïi)
        self.stop_all_alerts()
        if self.alert_thread and self.alert_thread.is_alive():
            pass

        def target():
            if not self.mixer_initialized: return
            for sound in sound_list:
                if sound:
                    if threading.current_thread() != self.alert_thread:
                        return
                    print(f" -> ƒêang ph√°t m·ªôt √¢m thanh trong chu·ªói...")
                    sound.play()
                    while pygame.mixer.get_busy():
                        if threading.current_thread() != self.alert_thread:
                            pygame.mixer.stop()
                            return
                        time.sleep(0.1)
                else:
                    print("C·∫¢NH B√ÅO: B·ªè qua file √¢m thanh kh√¥ng t·ªìn t·∫°i trong chu·ªói.")
                time.sleep(0.2)
        self.alert_thread = threading.Thread(target=target, daemon=True)
        self.alert_thread.start()

    def update_and_reconnect(self, settings: dict):
        self.broker, self.port = settings['broker'], int(settings['port'])
        self.username, self.password = settings['username'], settings['password']
        self.publish_topic = settings['publish']
        self.subscribe_topics = [t for t in settings['topics'].splitlines() if t]
        
        # C·∫≠p nh·∫≠t ng∆∞·ª°ng M·ª±c n∆∞·ªõc
        self.water_level_warning_threshold = float(settings['water_level_warning_threshold'])
        self.water_level_critical_threshold = float(settings['water_level_critical_threshold'])
        
        # C·∫≠p nh·∫≠t ng∆∞·ª°ng T·ªëc ƒë·ªô GNSS
        self.velocity_thresholds = settings['velocity_thresholds']
        self.velocity_display_options = settings['velocity_display_options']

        self.save_config()
        if self.listening:
            self.toggle_off()
            time.sleep(1)
            self.toggle_on()

    def load_config(self):
        if not os.path.exists(CONFIG_FILE):
            # N·∫øu kh√¥ng c√≥ file config, s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh
            self.velocity_thresholds = DEFAULT_VELOCITY_THRESHOLDS.copy()
            self.velocity_display_options = {
                'm/nƒÉm': True, 'm/th√°ng': True, 'm/ng√†y': True, 'm/gi·ªù': True,
                'm/ph√∫t': True, 'm/gi√¢y': True, 'mm/gi√¢y': True
            }
            self._load_audio_files()
            return
            
        try:
            self.config.read(CONFIG_FILE)
            # MQTT
            if "MQTT" in self.config:
                mqtt_cfg = self.config["MQTT"]
                self.broker = mqtt_cfg.get("broker", self.broker)
                self.port = mqtt_cfg.getint("port", self.port)
                self.username = mqtt_cfg.get("username", self.username)
                self.password = mqtt_cfg.get("password", self.password)
                self.subscribe_topics = [t for t in mqtt_cfg.get("topics", "").splitlines() if t]
                self.publish_topic = mqtt_cfg.get("publish", self.publish_topic)
            
            # M·ª±c n∆∞·ªõc
            if "WaterLevelSettings" in self.config:
                wl_cfg = self.config["WaterLevelSettings"]
                self.water_level_warning_threshold = wl_cfg.getfloat("warning_threshold", self.water_level_warning_threshold)
                self.water_level_critical_threshold = wl_cfg.getfloat("critical_threshold", self.water_level_critical_threshold)

            # GNSS Velocity Thresholds
            if "GNSS_Velocity" in self.config:
                gnss_cfg = self.config["GNSS_Velocity"]
                for key, _ in VELOCITY_CLASSIFICATION:
                    default_val = DEFAULT_VELOCITY_THRESHOLDS.get(key)
                    self.velocity_thresholds[key] = gnss_cfg.getfloat(key, default_val)
            else: # Fallback to defaults if section is missing
                 self.velocity_thresholds = DEFAULT_VELOCITY_THRESHOLDS.copy()

            # GNSS Display Options
            if "GNSS_Display" in self.config:
                disp_cfg = self.config["GNSS_Display"]
                self.velocity_display_options['m/nƒÉm'] = disp_cfg.getboolean('show_year', True)
                self.velocity_display_options['m/th√°ng'] = disp_cfg.getboolean('show_month', True)
                self.velocity_display_options['m/ng√†y'] = disp_cfg.getboolean('show_day', True)
                self.velocity_display_options['m/gi·ªù'] = disp_cfg.getboolean('show_hour', True)
                self.velocity_display_options['m/ph√∫t'] = disp_cfg.getboolean('show_minute', True)
                self.velocity_display_options['m/gi√¢y'] = disp_cfg.getboolean('show_second', True)
                self.velocity_display_options['mm/gi√¢y'] = disp_cfg.getboolean('show_mm_second', True)
            else: # Fallback
                self.velocity_display_options = {k: True for k in ['m/nƒÉm', 'm/th√°ng', 'm/ng√†y', 'm/gi·ªù', 'm/ph√∫t', 'm/gi√¢y', 'mm/gi√¢y']}


            print("ƒê√£ t·∫£i c·∫•u h√¨nh.")
            self._load_audio_files()
        except Exception as e:
            print(f"L·ªói khi t·∫£i c·∫•u h√¨nh t·ª´ {CONFIG_FILE}: {e}")

    def save_config(self):
        self.config['MQTT'] = {
            'broker': self.broker, 'port': self.port, 'username': self.username,
            'password': self.password, 'topics': "\n".join(self.subscribe_topics),
            'publish': self.publish_topic
        }
        self.config['WaterLevelSettings'] = {
            'warning_threshold': self.water_level_warning_threshold,
            'critical_threshold': self.water_level_critical_threshold
        }
        # L∆∞u c√°c ng∆∞·ª°ng t·ªëc ƒë·ªô (ƒë∆°n v·ªã m/s)
        self.config['GNSS_Velocity'] = {key: str(val) for key, val in self.velocity_thresholds.items()}
        
        # L∆∞u c√°c t√πy ch·ªçn hi·ªÉn th·ªã
        self.config['GNSS_Display'] = {
            'show_year': str(self.velocity_display_options.get('m/nƒÉm', True)),
            'show_month': str(self.velocity_display_options.get('m/th√°ng', True)),
            'show_day': str(self.velocity_display_options.get('m/ng√†y', True)),
            'show_hour': str(self.velocity_display_options.get('m/gi·ªù', True)),
            'show_minute': str(self.velocity_display_options.get('m/ph√∫t', True)),
            'show_second': str(self.velocity_display_options.get('m/gi√¢y', True)),
            'show_mm_second': str(self.velocity_display_options.get('mm/gi√¢y', True)),
        }

        try:
            with open(CONFIG_FILE, 'w') as f: self.config.write(f)
            print("ƒê√£ l∆∞u c·∫•u h√¨nh.")
        except IOError as e:
            print(f"L·ªói L∆∞u File: {e}")

    # ... (C√°c h√†m c√≤n l·∫°i c·ªßa Backend nh∆∞ shutdown, setup_gpio, flash_led, on_connect,... gi·ªØ nguy√™n)
    def shutdown(self, silent=False):
        if self.exiting: return
        if not silent: print("\nB·∫Øt ƒë·∫ßu qu√° tr√¨nh d·ªçn d·∫πp ƒë·ªÉ tho√°t...")
        self.exiting = True
        self.stop_event.set()
        self.stop_all_alerts()
        self.alert_thread = None
        try:
            self.client.loop_stop(force=True)
            self.client.disconnect()
        except Exception: pass
        GPIO.cleanup()
        if not silent: print(" -> Backend ƒë√£ d·ª´ng.")

    def setup_gpio(self):
        try:
            GPIO.setmode(GPIO.BCM)
            GPIO.setwarnings(False)
            GPIO.setup(self.led1_pin, GPIO.OUT, initial=GPIO.LOW)
            GPIO.setup(self.led2_pin, GPIO.OUT, initial=GPIO.LOW)
            print("GPIO setup successful.")
        except Exception as e:
            print(f"L·ªói khi c√†i ƒë·∫∑t GPIO: {e}")

    def start_background_tasks(self):
        self.load_session_data()
        threading.Thread(target=self.auto_clear_scheduler, daemon=True).start()
        print("ƒê√£ kh·ªüi ch·∫°y c√°c t√°c v·ª• n·ªÅn.")

    def flash_led(self, pin, duration=0.3):
        try:
            GPIO.output(pin, GPIO.HIGH)
            time.sleep(duration)
            GPIO.output(pin, GPIO.LOW)
        except Exception as e:
            print(f"L·ªói nh√°y LED tr√™n pin {pin}: {e}")

    def on_connect(self, client, userdata, flags, rc):
        if self.exiting: return
        if rc == 0:
            print("MQTT Connected successfully.")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: T·ª∞ ƒê·ªòNG", "green"
            for t in self.subscribe_topics:
                client.subscribe(t)
                print(f"Subscribed: {t}")
            if not self.subscribe_topics:
                self.status_text = "Tr·∫°ng th√°i: T·ª∞ ƒê·ªòNG (Kh√¥ng c√≥ topic)"
        else:
            print(f"Failed to connect, return code {rc}")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: L·ªñI K·∫æT N·ªêI", "red"
            self.listening = False

    def on_disconnect(self, client, userdata, rc):
        if not self.exiting and self.listening:
            print("M·∫•t k·∫øt n·ªëi MQTT...")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: M·∫§T K·∫æT N·ªêI", "orange"

    def get_gui_updates(self):
        updates = []
        while not self.gui_update_queue.empty():
            try:
                updates.append(self.gui_update_queue.get_nowait())
            except queue.Empty:
                break
        return updates

    def toggle_on(self):
        if self.listening: return
        self.listening = True
        self.status_text, self.status_color = "Tr·∫°ng th√°i: ƒêANG K·∫æT N·ªêI...", "orange"
        if not self.broker:
            self.listening = False
            self.status_text, self.status_color = "Tr·∫°ng th√°i: TH·ª¶ C√îNG (L·ªói Broker)", "red"
            return

        self.client.username_pw_set(self.username, self.password)
        try:
            print(f"ƒêang k·∫øt n·ªëi t·ªõi MQTT broker: {self.broker}:{self.port}...")
            self.client.connect_async(self.broker, self.port, 60)
            self.client.loop_start()
        except Exception as e:
            self.listening = False
            self.status_text, self.status_color = "Tr·∫°ng th√°i: L·ªñI K·∫æT N·ªêI", "red"
            print(f"L·ªói k·∫øt n·ªëi MQTT: {e}")

    def toggle_off(self):
        if not self.listening: return
        self.listening = False
        try:
            self.client.loop_stop()
            self.client.disconnect()
            print("ƒê√£ ng·∫Øt k·∫øt n·ªëi MQTT.")
        except Exception: pass
        self.status_text, self.status_color = "Tr·∫°ng th√°i: TH·ª¶ C√îNG", "red"

    def check_leds(self):
        if self.listening:
            print("Kh√¥ng th·ªÉ ki·ªÉm tra LED ·ªü ch·∫ø ƒë·ªô T·ª∞ ƒê·ªòNG.")
            return False
        threading.Thread(target=self._run_led_check, daemon=True).start()
        return True

    def _run_led_check(self):
        print("Ki·ªÉm tra LED...")
        self.flash_led(self.led1_pin, duration=0.5)
        time.sleep(0.1)
        self.flash_led(self.led2_pin, duration=0.5)

    def auto_clear_scheduler(self):
        while not self.stop_event.is_set():
            now = datetime.now()
            if now.hour == 0 and now.minute == 0:
                print("ƒê√£ ƒë·∫øn 00:00, t·ª± ƒë·ªông x√≥a d·ªØ li·ªáu...")
                self.clear_all_data()
                time.sleep(61)
            else:
                time.sleep(30)

    def clear_all_data(self):
        self.sensor_data.clear()
        self.plot_data_points.clear()
        self.gui_update_queue.put(DATA_CLEAR_SIGNAL)
        self.last_gnss_reading = {'timestamp': None, 'value': None} # Reset c·∫£ ƒëi·ªÉm GNSS cu·ªëi
        print("ƒê√£ x√≥a d·ªØ li·ªáu n·ªÅn.")

    def save_session_data(self, silent=False):
        # ... (Kh√¥ng thay ƒë·ªïi)
        if not silent: print(" -> ƒêang l∆∞u tr·∫°ng th√°i hi·ªán t·∫°i v√†o file...")
        try:
            plot_data_serializable = [(dt.isoformat(), val) for dt, val in self.plot_data_points]
            session = {"sensor_data": self.sensor_data, "plot_data_points": plot_data_serializable}
            with open(SESSION_FILE, "w") as f: json.dump(session, f)
            if not silent: print(f" -> ƒê√£ l∆∞u tr·∫°ng th√°i v√†o {SESSION_FILE}")
        except Exception as e:
            print(f" -> L·ªói khi l∆∞u tr·∫°ng th√°i: {e}")

    def load_session_data(self):
        # ... (Kh√¥ng thay ƒë·ªïi)
        if not os.path.exists(SESSION_FILE): return
        print(f" -> T√¨m th·∫•y file tr·∫°ng th√°i {SESSION_FILE}, ƒëang t·∫£i l·∫°i d·ªØ li·ªáu...")
        try:
            with open(SESSION_FILE, "r") as f: session = json.load(f)
            self.sensor_data = session.get("sensor_data", [])
            plot_data_serializable = session.get("plot_data_points", [])
            self.plot_data_points.clear()
            for dt_str, val in plot_data_serializable:
                self.plot_data_points.append((datetime.fromisoformat(dt_str), val))
            for record in self.sensor_data: self.gui_update_queue.put(record)
            print(" -> ƒê√£ t·∫£i l·∫°i d·ªØ li·ªáu th√†nh c√¥ng.")
        except Exception as e:
            print(f" -> L·ªói khi t·∫£i tr·∫°ng th√°i: {e}")
        finally:
            if os.path.exists(SESSION_FILE): os.remove(SESSION_FILE)


# ==============================================================================
# L·ªöP GIAO DI·ªÜN NG∆Ø·ªúI D√ôNG (GUI)
# ==============================================================================
class AppGUI:
    def __init__(self, root: tk.Toplevel, backend: Backend, on_close_callback):
        self.root = root
        self.backend = backend
        self.on_close_callback = on_close_callback
        self.root.title("Giao di·ªán C·∫£m bi·∫øn & ƒêi·ªÅu khi·ªÉn LED")
        self.root.geometry(f"{self.root.winfo_screenwidth()}x{self.root.winfo_screenheight()-70}+0+0")
        self.chart_window = None
        self.settings_window = None
        
        # Bi·∫øn cho tab M·ª±c n∆∞·ªõc
        self.water_level_warning_var = tk.StringVar()
        self.water_level_critical_var = tk.StringVar()

        # C√°c h·∫±ng s·ªë chuy·ªÉn ƒë·ªïi t·ªëc ƒë·ªô (BASE UNIT: m/s)
        self._VELOCITY_CONVERSION_FACTORS = {
            "m/gi√¢y": 1,
            "mm/gi√¢y": 1000,
            "m/ph√∫t": 60,
            "m/gi·ªù": 3600,
            "m/ng√†y": 86400,
            "m/th√°ng": 2628000,  # Trung b√¨nh 30.42 ng√†y
            "m/nƒÉm": 31536000, # Trung b√¨nh 365 ng√†y
        }
        self._is_updating_gnss_sheet = False

        self.CONVERSION_FACTORS = {"m": 1.0, "cm": 100.0, "mm": 1000.0, "ft": 3.28084}
        self.points_per_view = 40
        self.current_start_index = 0
        self.last_highlighted_row = None
        self._is_updating_slider = False
        self._slider_after_id = None
        self.create_widgets()
        self.load_initial_data()
        self.root.after(250, self.periodic_update)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close_window)

    def create_left_panel(self, parent):
        # ... (Kh√¥ng thay ƒë·ªïi)
        left = ttk.LabelFrame(parent, text="C√†i ƒë·∫∑t MQTT", padding=10)
        left.grid(row=0, column=0, sticky="nsw", padx=(0, 15))
        left.grid_rowconfigure(6, weight=1) # Cho ph√©p text box m·ªü r·ªông

        def add_labeled_entry(frame, label, row, show=None):
            ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w", pady=3)
            entry = ttk.Entry(frame, show=show)
            entry.grid(row=row, column=1, sticky="ew", pady=3, columnspan=2)
            return entry

        self.broker_entry = add_labeled_entry(left, "MQTT Broker:", 0)
        self.port_entry = add_labeled_entry(left, "Port:", 1)
        self.user_entry = add_labeled_entry(left, "Username:", 2)
        self.pass_entry = add_labeled_entry(left, "Password:", 3, show="*")
        show_btn = ttk.Button(left, text="üëÅ", command=self.toggle_pass, width=2, bootstyle="light")
        show_btn.grid(row=3, column=2, sticky="e")
        self.pub_entry = add_labeled_entry(left, "Publish Topic:", 4)

        ttk.Label(left, text="Subscribe Topics:").grid(row=5, column=0, columnspan=3, sticky="w", pady=(10, 2))
        self.topic_input = tk.Text(left, height=8, width=35, relief="solid", borderwidth=1)
        self.topic_input.grid(row=6, column=0, columnspan=3, pady=(0, 5), sticky="nsew")

        ttk.Button(left, text="C√†i ƒë·∫∑t N√¢ng cao", command=self.open_settings_window, bootstyle="secondary").grid(row=7, column=0, columnspan=3, sticky="ew", pady=(10, 5))

        ttk.Button(left, text="L∆∞u & √Åp d·ª•ng", command=self.apply_and_save_config, bootstyle="primary").grid(row=8, column=0, columnspan=3, sticky="ew", pady=(5,0))


    def open_settings_window(self):
        if self.settings_window and self.settings_window.winfo_exists():
            self.settings_window.lift()
            return

        self.settings_window = Toplevel(self.root)
        self.settings_window.title("C√†i ƒë·∫∑t N√¢ng cao")
        self.settings_window.geometry("800x600")
        self.settings_window.transient(self.root)

        notebook = ttk.Notebook(self.settings_window)
        notebook.pack(pady=10, padx=10, fill="both", expand=True)

        # Tab 1: GNSS - ƒê√£ ƒë∆∞·ª£c thi·∫øt k·∫ø l·∫°i ho√†n to√†n
        gnss_frame = ttk.Frame(notebook, padding="10")
        notebook.add(gnss_frame, text='Ph√¢n lo·∫°i T·ªëc ƒë·ªô (GNSS)')
        self._setup_gnss_tab(gnss_frame)

        # Tab 2: M·ª±c n∆∞·ªõc
        water_level_frame = ttk.Frame(notebook, padding="10")
        notebook.add(water_level_frame, text='M·ª±c n∆∞·ªõc')
        self._setup_water_level_tab(water_level_frame)
        
        # Load d·ªØ li·ªáu v√†o c√°c tab
        self.load_settings_to_gui()
        
        # N√∫t ƒë·ªÉ ƒë√≥ng c·ª≠a s·ªï c√†i ƒë·∫∑t
        ttk.Button(self.settings_window, text="ƒê√≥ng", command=self.settings_window.destroy).pack(pady=10)

    def _setup_water_level_tab(self, parent_frame):
        def add_labeled_entry_settings(frame, label, row, textvariable):
            ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w", pady=5, padx=5)
            entry = ttk.Entry(frame, textvariable=textvariable)
            entry.grid(row=row, column=1, sticky="ew", pady=5, padx=5)
            frame.grid_columnconfigure(1, weight=1)

        add_labeled_entry_settings(parent_frame, "Ng∆∞·ª°ng C·∫£nh B√°o (m):", 0, self.water_level_warning_var)
        add_labeled_entry_settings(parent_frame, "Ng∆∞·ª°ng Nguy Hi·ªÉm (m):", 1, self.water_level_critical_var)


    def _setup_gnss_tab(self, parent_frame):
        # Khu v·ª±c t√πy ch·ªçn hi·ªÉn th·ªã c·ªôt
        display_options_frame = ttk.LabelFrame(parent_frame, text="T√πy ch·ªçn Hi·ªÉn th·ªã C·ªôt", padding=10)
        display_options_frame.pack(fill="x", pady=(0, 10))

        self.gnss_display_vars = {}
        column_map = {
            'm/nƒÉm': 'm/nƒÉm', 'm/th√°ng': 'm/th√°ng', 'm/ng√†y': 'm/ng√†y', 'm/gi·ªù': 'm/gi·ªù',
            'm/ph√∫t': 'm/ph√∫t', 'm/gi√¢y': 'm/gi√¢y', 'mm/gi√¢y': 'mm/gi√¢y'
        }
        for i, (text, key) in enumerate(column_map.items()):
            var = tk.BooleanVar()
            cb = ttk.Checkbutton(display_options_frame, text=text, variable=var, command=self._update_gnss_table_visibility)
            cb.grid(row=0, column=i, padx=5, sticky="w")
            self.gnss_display_vars[key] = var

        # Khu v·ª±c b·∫£ng
        table_frame = ttk.LabelFrame(parent_frame, text="B·∫£ng Ph√¢n lo·∫°i T·ªëc ƒë·ªô D·ªãch chuy·ªÉn [Cruden, 1996]", padding=10)
        table_frame.pack(fill="both", expand=True)

        self.gnss_sheet = Sheet(table_frame, show_row_index=False, headers=["Ph√¢n lo·∫°i"])
        self.gnss_sheet.enable_bindings("single_select", "edit_cell")
        self.gnss_sheet.pack(fill="both", expand=True)
        self.gnss_sheet.extra_bindings([("cell_edit", self._on_gnss_sheet_edit)])
    
    def _update_gnss_table_visibility(self):
        if not hasattr(self, 'gnss_sheet'): return

        self._is_updating_gnss_sheet = True # NgƒÉn trigger s·ª± ki·ªán edit
        
        # L·∫•y d·ªØ li·ªáu hi·ªán t·∫°i t·ª´ b·∫£ng
        current_data = self.gnss_sheet.get_sheet_data()
        current_headers = self.gnss_sheet.headers()

        # T·∫°o map t·ª´ header ƒë·∫øn index ƒë·ªÉ l·∫•y ƒë√∫ng d·ªØ li·ªáu
        header_map = {h: i for i, h in enumerate(current_headers)}
        
        # X√°c ƒë·ªãnh header m·ªõi
        new_headers = ["Ph√¢n lo·∫°i"]
        for header, var in self.gnss_display_vars.items():
            if var.get():
                new_headers.append(header)
        
        # T·∫°o d·ªØ li·ªáu m·ªõi d·ª±a tr√™n header m·ªõi
        new_data = []
        for row_idx, (key, name) in enumerate(VELOCITY_CLASSIFICATION):
            new_row = [name]
            # L·∫•y gi√° tr·ªã c∆° s·ªü (m/s) t·ª´ backend
            base_value_mps = self.backend.velocity_thresholds.get(key, 0)
            
            for header in new_headers:
                if header == "Ph√¢n lo·∫°i":
                    continue
                # T√≠nh to√°n l·∫°i gi√° tr·ªã cho t·ª´ng c·ªôt hi·ªÉn th·ªã
                factor = self._VELOCITY_CONVERSION_FACTORS.get(header, 1)
                new_val = base_value_mps * factor
                
                # ƒê·ªãnh d·∫°ng s·ªë khoa h·ªçc cho gi√° tr·ªã r·∫•t nh·ªè
                if 0 < new_val < 1e-4:
                     new_row.append(f"{new_val:.2E}")
                else:
                     new_row.append(f"{new_val:.6f}".rstrip('0').rstrip('.'))

            new_data.append(new_row)

        self.gnss_sheet.set_sheet_data(data=new_data, headers=new_headers)
        self.gnss_sheet.set_all_column_widths()
        self.gnss_sheet.column_width(0, 100)
        self.gnss_sheet.readonly_columns([0]) # C·ªôt "Ph√¢n lo·∫°i" kh√¥ng th·ªÉ s·ª≠a

        self._is_updating_gnss_sheet = False

    def _on_gnss_sheet_edit(self, event):
        if self._is_updating_gnss_sheet:
            return
            
        self._is_updating_gnss_sheet = True

        row, col, _, new_value_str, *_ = event
        
        try:
            new_value = float(new_value_str)
        except (ValueError, TypeError):
            self._is_updating_gnss_sheet = False
            return # B·ªè qua n·∫øu gi√° tr·ªã nh·∫≠p v√†o kh√¥ng ph·∫£i l√† s·ªë

        edited_header = self.gnss_sheet.headers()[col]
        
        # 1. Chuy·ªÉn gi√° tr·ªã ƒë√£ s·ª≠a v·ªÅ ƒë∆°n v·ªã c∆° s·ªü (m/s)
        conversion_factor = self._VELOCITY_CONVERSION_FACTORS.get(edited_header, 1)
        base_value_mps = new_value / conversion_factor
        
        # C·∫≠p nh·∫≠t gi√° tr·ªã c∆° s·ªü n√†y trong backend
        classification_key = VELOCITY_CLASSIFICATION[row][0]
        self.backend.velocity_thresholds[classification_key] = base_value_mps

        # 2. C·∫≠p nh·∫≠t l·∫°i t·∫•t c·∫£ c√°c √¥ trong c√πng m·ªôt h√†ng
        for c_idx, header in enumerate(self.gnss_sheet.headers()):
            if c_idx == col or c_idx == 0: # B·ªè qua c·ªôt v·ª´a s·ª≠a v√† c·ªôt t√™n
                continue
            
            factor = self._VELOCITY_CONVERSION_FACTORS.get(header, 1)
            recalculated_value = base_value_mps * factor
            
            # ƒê·ªãnh d·∫°ng l·∫°i gi√° tr·ªã ƒë·ªÉ hi·ªÉn th·ªã
            if 0 < recalculated_value < 1e-4:
                display_val = f"{recalculated_value:.2E}"
            else:
                display_val = f"{recalculated_value:.6f}".rstrip('0').rstrip('.')

            self.gnss_sheet.set_cell_data(row, c_idx, display_val)

        self._is_updating_gnss_sheet = False
        
    def load_initial_data(self):
        # Load d·ªØ li·ªáu MQTT
        self.broker_entry.insert(0, self.backend.broker)
        self.port_entry.insert(0, str(self.backend.port))
        self.user_entry.insert(0, self.backend.username)
        self.pass_entry.insert(0, self.backend.password)
        self.pub_entry.insert(0, self.backend.publish_topic)
        self.topic_input.insert("1.0", "\n".join(self.backend.subscribe_topics))
    
    def load_settings_to_gui(self):
        # Load d·ªØ li·ªáu ng∆∞·ª°ng m·ª±c n∆∞·ªõc
        self.water_level_warning_var.set(str(self.backend.water_level_warning_threshold))
        self.water_level_critical_var.set(str(self.backend.water_level_critical_threshold))
        
        # Load tr·∫°ng th√°i c√°c checkbox c·ªßa GNSS
        for key, var in self.gnss_display_vars.items():
            is_checked = self.backend.velocity_display_options.get(key, True)
            var.set(is_checked)
        
        # C·∫≠p nh·∫≠t b·∫£ng GNSS d·ª±a tr√™n d·ªØ li·ªáu ƒë√£ load
        self._update_gnss_table_visibility()


    def _save_settings_from_gui(self) -> dict:
        """L·∫•y t·∫•t c·∫£ c√†i ƒë·∫∑t t·ª´ GUI ƒë·ªÉ chu·∫©n b·ªã l∆∞u."""
        settings = {}
        # Ng∆∞·ª°ng m·ª±c n∆∞·ªõc
        settings['water_level_warning_threshold'] = self.water_level_warning_var.get()
        settings['water_level_critical_threshold'] = self.water_level_critical_var.get()
        
        # Ng∆∞·ª°ng t·ªëc ƒë·ªô GNSS (ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t v√†o backend m·ªói khi s·ª≠a)
        settings['velocity_thresholds'] = self.backend.velocity_thresholds.copy()

        # T√πy ch·ªçn hi·ªÉn th·ªã GNSS
        settings['velocity_display_options'] = {key: var.get() for key, var in self.gnss_display_vars.items()}
        
        return settings

    def apply_and_save_config(self, show_message=True):
        try:
            # L·∫•y c√†i ƒë·∫∑t chung
            settings = {
                'broker': self.broker_entry.get(),
                'port': self.port_entry.get(),
                'username': self.user_entry.get(),
                'password': self.pass_entry.get(),
                'topics': self.topic_input.get("1.0", "end").strip(),
                'publish': self.pub_entry.get()
            }
            
            # N·∫øu c·ª≠a s·ªï c√†i ƒë·∫∑t ƒëang m·ªü, l·∫•y d·ªØ li·ªáu t·ª´ ƒë√≥, n·∫øu kh√¥ng d√πng d·ªØ li·ªáu hi·ªán c√≥ trong backend
            if self.settings_window and self.settings_window.winfo_exists():
                advanced_settings = self._save_settings_from_gui()
                settings.update(advanced_settings)
            else:
                 settings['water_level_warning_threshold'] = self.backend.water_level_warning_threshold
                 settings['water_level_critical_threshold'] = self.backend.water_level_critical_threshold
                 settings['velocity_thresholds'] = self.backend.velocity_thresholds
                 settings['velocity_display_options'] = self.backend.velocity_display_options
                 
            # X√°c th·ª±c d·ªØ li·ªáu
            float(settings['water_level_warning_threshold'])
            float(settings['water_level_critical_threshold'])
            
            # C·∫≠p nh·∫≠t backend
            self.backend.update_and_reconnect(settings)
            
            if show_message:
                messagebox.showinfo("Th√†nh c√¥ng", "ƒê√£ l∆∞u v√† √°p d·ª•ng c·∫•u h√¨nh.", parent=self.root)
        except ValueError:
            messagebox.showerror("L·ªói", "Gi√° tr·ªã ng∆∞·ª°ng kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë.", parent=self.root)
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ √°p d·ª•ng c·∫•u h√¨nh: {e}", parent=self.root)

    # ... (C√°c h√†m c√≤n l·∫°i c·ªßa AppGUI nh∆∞ periodic_update, on_close_window,... gi·ªØ nguy√™n)
    def periodic_update(self):
        if not self.root.winfo_exists(): return
        self.update_status_label()
        new_updates = self.backend.get_gui_updates()
        if new_updates:
            if DATA_CLEAR_SIGNAL in new_updates:
                self.sheet.set_sheet_data([])
                if self.chart_window and self.chart_window.winfo_exists(): self.clear_chart_data()
                print("GUI ƒë√£ nh·∫≠n t√≠n hi·ªáu v√† x√≥a b·∫£ng.")
            else:
                valid_records = [rec for rec in new_updates if isinstance(rec, tuple)]
                if valid_records:
                    self.sheet.insert_rows(valid_records)
                    self.sheet.dehighlight_all()
                    last_row_index = self.sheet.get_total_rows() - 1
                    if last_row_index >= 0:
                        self.sheet.see(row=last_row_index)
                        self.sheet.deselect()
                        last_record = valid_records[-1]
                        status = last_record[2]
                        if "NGUY" in status:
                            highlight_color = "#F8D7DA"
                        elif "CANH BAO" in status or "NHANH" in status :
                            highlight_color = "#FFF3CD"
                        else:
                            highlight_color = "#D4EDDA"
                        self.sheet.highlight_rows(rows=[last_row_index], bg=highlight_color, fg="black")
            if self.chart_window and self.chart_window.winfo_exists(): self.update_plot()
        self.root.after(250, self.periodic_update)

    def destroy_all_windows(self):
        if self.settings_window and self.settings_window.winfo_exists(): self.settings_window.destroy()
        if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.destroy()
        if self.root and self.root.winfo_exists(): self.root.destroy()

    def on_close_window(self):
        print("ƒê√£ ƒë√≥ng c·ª≠a s·ªï giao di·ªán. G√µ 'show' trong terminal ƒë·ªÉ m·ªü l·∫°i.")
        self.on_close_callback()
        self.destroy_all_windows()

    def exit_program_graceful(self):
        if messagebox.askokcancel("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën tho√°t ho√†n to√†n ch∆∞∆°ng tr√¨nh?", parent=self.root):
            print("T·ª± ƒë·ªông l∆∞u c·∫•u h√¨nh hi·ªán t·∫°i tr∆∞·ªõc khi tho√°t...")
            self.apply_and_save_config(show_message=False) # L∆∞u l·∫°i c√°c thay ƒë·ªïi cu·ªëi c√πng
            self.on_close_callback(shutdown=True)

    def create_widgets(self):
        main = ttk.Frame(self.root, padding=10)
        main.pack(fill="both", expand=True)
        main.grid_columnconfigure(1, weight=1)
        main.grid_columnconfigure(0, weight=0)
        main.grid_rowconfigure(0, weight=1)
        self.create_left_panel(main)
        self.create_right_panel(main)

    def create_right_panel(self, parent):
        right = ttk.Frame(parent)
        right.grid(row=0, column=1, sticky="nsew")
        right.grid_rowconfigure(1, weight=1)
        right.grid_columnconfigure(0, weight=1)
        self.status_label = ttk.Label(right, text="", font=("Arial", 11, "bold"))
        self.status_label.grid(row=0, column=0, sticky="ew", pady=(0, 5))
        sheet_frame = ttk.Frame(right)
        sheet_frame.grid(row=1, column=0, sticky="nsew")
        self.sheet = Sheet(sheet_frame, headers=["T√™n", "Gi√° tr·ªã", "Tr·∫°ng th√°i", "Th·ªùi gian"], show_row_index=True)
        self.sheet.pack(fill=tk.BOTH, expand=True)
        self.sheet.disable_bindings()
        self.sheet.set_options(font=("Arial", 10, "normal"), header_font=("Arial", 10, "bold"), align="center")
        self.sheet.column_widths({0:150, 1:120, 2:150, 3:200})
        self.create_control_panel(right)

    def create_control_panel(self, parent_frame):
        bottom_part = ttk.Frame(parent_frame)
        bottom_part.grid(row=2, column=0, sticky="ew", pady=(10, 0))
        ctrl = ttk.Frame(bottom_part)
        ctrl.pack(side=tk.TOP, fill=tk.X, expand=True)
        for i in range(5): ctrl.grid_columnconfigure(i, weight=1)
        ttk.Button(ctrl, text="T·ª± ƒë·ªông (ON)", command=self.backend.toggle_on, bootstyle="success").grid(row=0, column=0, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Th·ªß c√¥ng (OFF)", command=self.backend.toggle_off, bootstyle="danger").grid(row=0, column=1, padx=2, sticky="ew")
        self.save_csv_button = ttk.Button(ctrl, text="L∆∞u CSV", command=self.save_to_csv, bootstyle="info")
        self.save_csv_button.grid(row=0, column=2, padx=2, sticky="ew")
        ttk.Button(ctrl, text="X√≥a D·ªØ Li·ªáu", command=self.clear_table_gui, bootstyle="warning").grid(row=0, column=3, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Xem Bi·ªÉu ƒê·ªì", command=self.show_chart_window, bootstyle="primary").grid(row=0, column=4, padx=2, sticky="ew")
        led_panel = ttk.LabelFrame(bottom_part, text="Ki·ªÉm tra Thi·∫øt b·ªã", padding=5)
        led_panel.pack(side=tk.TOP, fill=tk.X, expand=True, pady=(10, 0))
        led_panel.grid_columnconfigure(0, weight=3)
        led_panel.grid_columnconfigure(1, weight=1)
        ttk.Button(led_panel, text="Ki·ªÉm tra LED", command=self.on_check_led_click).grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        ttk.Button(led_panel, text="Tho√°t", command=self.exit_program_graceful, bootstyle="secondary-outline").grid(row=0, column=1, padx=5, pady=5, sticky="ew")

    def update_status_label(self):
        if self.status_label.cget("text") != self.backend.status_text or self.status_label.cget("foreground") != self.backend.status_color:
            self.status_label.config(text=self.backend.status_text, foreground=self.backend.status_color)

    def toggle_pass(self): self.pass_entry.config(show="" if self.pass_entry.cget("show") else "*")

    def on_check_led_click(self):
        if not self.backend.check_leds(): messagebox.showwarning("C·∫£nh b√°o", "Ch·ªâ c√≥ th·ªÉ ki·ªÉm tra LED ·ªü ch·∫ø ƒë·ªô TH·ª¶ C√îNG (OFF).", parent=self.root)

    def clear_table_gui(self):
        if messagebox.askokcancel("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô d·ªØ li·ªáu hi·ªán t·∫°i?", parent=self.root): self.backend.clear_all_data()

    def save_to_csv(self):
        if not self.backend.sensor_data: messagebox.showinfo("Th√¥ng b√°o", "Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ l∆∞u.", parent=self.root); return
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")], title="L∆∞u file CSV", parent=self.root)
        if path:
            self.save_csv_button.config(state="disabled")
            threading.Thread(target=self._write_csv_in_background, args=(path, list(self.backend.sensor_data)), daemon=True).start()

    def _write_csv_in_background(self, path, data_to_save):
        try:
            import csv
            with open(path, "w", newline="", encoding='utf-8-sig') as f:
                writer = csv.writer(f)
                writer.writerow(self.sheet.headers())
                writer.writerows(data_to_save)
            if self.root.winfo_exists():
                self.root.after(0, lambda p=path: messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ l∆∞u d·ªØ li·ªáu v√†o {os.path.basename(p)}", parent=self.root))
        except Exception as e:
            if self.root.winfo_exists():
                self.root.after(0, lambda err=e: messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ l∆∞u file:\n\n{err}", parent=self.root))
        finally:
            if self.root.winfo_exists():
                self.root.after(0, lambda: self.save_csv_button.config(state="normal"))

    def show_chart_window(self):
        if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.lift(); return
        self.chart_window = tk.Toplevel(self.root)
        self.chart_window.title("Bi·ªÉu ƒë·ªì D·ªØ li·ªáu C·∫£m bi·∫øn")
        self.chart_window.geometry("900x650")
        self.chart_window.protocol("WM_DELETE_WINDOW", self.on_chart_close)
        top_frame = ttk.Frame(self.chart_window, padding=(10, 5))
        top_frame.pack(side=tk.TOP, fill=tk.X)
        ttk.Label(top_frame, text="Ch·ªçn ƒë∆°n v·ªã:").pack(side=tk.LEFT, padx=(0, 5))
        self.unit_selector = ttk.Combobox(top_frame, state="readonly", values=list(self.CONVERSION_FACTORS.keys()))
        self.unit_selector.set("m"); self.unit_selector.pack(side=tk.LEFT, padx=5)
        self.unit_selector.bind("<<ComboboxSelected>>", lambda e: self.update_plot())
        self.auto_follow_var = tk.BooleanVar(value=True)
        auto_follow_check = ttk.Checkbutton(top_frame, text="T·ª± ƒë·ªông theo d√µi", variable=self.auto_follow_var, command=self.on_auto_follow_toggle)
        auto_follow_check.pack(side=tk.LEFT, padx=20)
        self.current_start_index = 0
        chart_frame = ttk.Frame(self.chart_window, padding=(10, 5))
        chart_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.fig = Figure(figsize=(9, 4.5), dpi=100)
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=chart_frame)
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        slider_frame = ttk.Frame(self.chart_window, padding=10)
        slider_frame.pack(side=tk.BOTTOM, fill=tk.X)
        self.position_var = tk.DoubleVar()
        self.position_scale = ttk.Scale(slider_frame, from_=0, to=100, orient=tk.HORIZONTAL, variable=self.position_var, command=self.on_slider_change)
        self.position_scale.pack(side=tk.TOP, fill=tk.X, expand=True)
        self.info_label = ttk.Label(slider_frame, text="T·ªïng ƒëi·ªÉm: 0 | Hi·ªÉn th·ªã: 0-0", font=("Arial", 9))
        self.info_label.pack(side=tk.TOP, pady=(5, 0))
        self.update_plot()

    def clear_chart_data(self):
        self.current_start_index = 0
        if hasattr(self, 'auto_follow_var'):
            self.auto_follow_var.set(True)
        self.update_plot()

    def update_plot(self):
        if not (self.chart_window and self.chart_window.winfo_exists()): return
        all_data = list(self.backend.plot_data_points)
        total_points = len(all_data)
        if total_points > self.points_per_view:
            max_start = total_points - self.points_per_view
            self.current_start_index = min(self.current_start_index, max_start)
        start, end = self._update_slider_and_indices(total_points)
        display_data_slice = all_data[start:end]
        self.ax.clear()
        
        if not display_data_slice:
            self.ax.text(0.5, 0.5, 'Ch∆∞a c√≥ d·ªØ li·ªáu', ha='center', va='center', transform=self.ax.transAxes, fontsize=16, color='gray')
            self.info_label.config(text="T·ªïng ƒëi·ªÉm: 0 | Hi·ªÉn th·ªã: 0-0")
        else:
            indices, values, times, unit, warning_thresh, critical_thresh = self._prepare_plot_data(display_data_slice, start)
            self._setup_plot_style(unit)
            self._draw_plot_elements(indices, values, warning_thresh, critical_thresh, unit)
            self._configure_plot_axes(start, end, total_points, indices, times)
        self.canvas.draw()

    def _update_slider_and_indices(self, total_points):
        if total_points <= self.points_per_view:
            self.position_scale.config(state="disabled")
            self.current_start_index = 0
            self._is_updating_slider = True
            self.position_scale.set(0)
            self._is_updating_slider = False
        else:
            self.position_scale.config(state="normal")
            if self.auto_follow_var.get():
                self.current_start_index = max(0, total_points - self.points_per_view)
        if total_points > self.points_per_view:
            max_start_idx = max(0, total_points - self.points_per_view)
            pos_percent = (self.current_start_index / max_start_idx) * 100 if max_start_idx > 0 else 100
        else:
            pos_percent = 100
        self._is_updating_slider = True
        self.position_scale.set(pos_percent)
        self._is_updating_slider = False
        start = self.current_start_index
        end = min(total_points, start + self.points_per_view)
        return start, end

    def _prepare_plot_data(self, data_slice, start_index):
        unit = self.unit_selector.get()
        conversion_factor = self.CONVERSION_FACTORS.get(unit, 1.0)
        indices = range(start_index, start_index + len(data_slice))
        values = [item[1] * conversion_factor for item in data_slice]
        times = [item[0] for item in data_slice]
        # Ch√∫ √Ω: bi·ªÉu ƒë·ªì v·∫´n d√πng ng∆∞·ª°ng M·ª±c n∆∞·ªõc c≈©, c√≥ th·ªÉ c·∫ßn ƒëi·ªÅu ch·ªânh n·∫øu mu·ªën bi·ªÉu ƒë·ªì ƒë·ªông
        warning_thresh = self.backend.water_level_warning_threshold * conversion_factor
        critical_thresh = self.backend.water_level_critical_threshold * conversion_factor
        return indices, values, times, unit, warning_thresh, critical_thresh

    def _setup_plot_style(self, unit='Gi√° tr·ªã'):
        self.ax.set_title('D·ªØ li·ªáu C·∫£m bi·∫øn Theo Th·ªùi Gian', fontsize=14, fontweight='bold')
        self.ax.set_xlabel('Th·ªùi gian', fontsize=12)
        self.ax.set_ylabel(f'Gi√° tr·ªã ({unit})', fontsize=12)
        self.ax.grid(True, which='major', linestyle='--', alpha=0.6)

    def _draw_plot_elements(self, indices, values, warning_thresh, critical_thresh, unit):
        # ... (ph·∫ßn n√†y c√≥ th·ªÉ c·∫ßn s·ª≠a ƒë·ªÉ ph√π h·ª£p logic m·ªõi n·∫øu mu·ªën)
        self.ax.plot(indices, values, color='blue', linestyle='-', linewidth=1.5, marker='o', markersize=4, zorder=3)
        self.ax.axhline(y=warning_thresh, color='gold', linestyle='--', linewidth=2, alpha=0.9, label=f'Ng∆∞·ª°ng C·∫£nh b√°o ({warning_thresh:.2f} {unit})')
        self.ax.axhline(y=critical_thresh, color='darkorange', linestyle='--', linewidth=2, alpha=0.9, label=f'Ng∆∞·ª°ng Nguy hi·ªÉm ({critical_thresh:.2f} {unit})')

    def _configure_plot_axes(self, start, end, total_points, indices, times):
        self.ax.set_xlim(left=start - 0.5, right=start + self.points_per_view - 0.5)
        num_ticks = min(len(indices), 8)
        if num_ticks > 1:
            tick_indices_in_slice = np.linspace(0, len(indices) - 1, num_ticks, dtype=int)
            self.ax.set_xticks([indices[i] for i in tick_indices_in_slice])
            self.ax.set_xticklabels([times[i].strftime('%H:%M:%S') for i in tick_indices_in_slice], rotation=45, ha='right')
        elif len(indices) == 1:
            self.ax.set_xticks(indices); self.ax.set_xticklabels([t.strftime('%H:%M:%S') for t in times])
        handles, labels = self.ax.get_legend_handles_labels()
        by_label = dict(zip(labels, handles))
        self.ax.legend(by_label.values(), by_label.keys(), loc='upper left')
        self.info_label.config(text=f"T·ªïng ƒëi·ªÉm: {total_points} | Hi·ªÉn th·ªã: {start+1}-{end}")
        try:
            self.fig.tight_layout()
        except (RecursionError, RuntimeError):
            print("C·∫£nh b√°o: L·ªói t·∫°m th·ªùi khi t√≠nh to√°n layout bi·ªÉu ƒë·ªì.")

    def on_auto_follow_toggle(self):
        if self.auto_follow_var.get():
            total_points = len(self.backend.plot_data_points)
            if total_points > self.points_per_view:
                self.current_start_index = max(0, total_points - self.points_per_view)
            else:
                self.current_start_index = 0
            self.update_plot()

    def on_slider_change(self, value_str):
        if self._is_updating_slider: return
        if self._slider_after_id:
            self.root.after_cancel(self._slider_after_id)
        self._slider_after_id = self.root.after(100, lambda v=value_str: self._perform_slider_update(v))

    def _perform_slider_update(self, value_str):
        self._slider_after_id = None
        if self.auto_follow_var.get():
            self.auto_follow_var.set(False)
        total_points = len(self.backend.plot_data_points)
        if total_points <= self.points_per_view:
            return
        max_start_index = total_points - self.points_per_view
        self.current_start_index = int((float(value_str) / 100) * max_start_index)
        self.update_plot()

    def on_chart_close(self):
        if self._slider_after_id:
            self.root.after_cancel(self._slider_after_id)
            self._slider_after_id = None
        plt.close(self.fig)
        self.chart_window.destroy()
        self.chart_window = None


# ==============================================================================
# KH·ªêI ƒêI·ªÄU KHI·ªÇN CH√çNH (MAIN CONTROLLER)
# ==============================================================================
class MainController:
    # ... (Kh√¥ng thay ƒë·ªïi)
    def __init__(self, backend, command_queue):
        self.backend = backend
        self.command_queue = command_queue
        self.app_instance = None
        self.root = ttk.Window()
        self.root.withdraw()

    def run(self):
        self.check_for_commands()
        self.root.mainloop()

    def check_for_commands(self):
        try:
            command = self.command_queue.get_nowait()
            if command == 'show': self.create_gui_window()
            elif command == 'exit': self.handle_shutdown()
            elif command == 'restart': self.handle_restart()
        except queue.Empty: pass
        finally:
            if not self.backend.exiting and self.root.winfo_exists():
                self.root.after(100, self.check_for_commands)

    def create_gui_window(self):
        if self.app_instance and self.app_instance.root.winfo_exists():
            print("Giao di·ªán ƒë√£ ƒëang ch·∫°y."); self.app_instance.root.lift();
            return
        print("ƒêang kh·ªüi ƒë·ªông giao di·ªán ng∆∞·ªùi d√πng...")
        toplevel_window = tk.Toplevel(self.root)
        self.app_instance = AppGUI(toplevel_window, self.backend, self.on_gui_close)

    def on_gui_close(self, shutdown=False):
        self.app_instance = None
        if shutdown: self.command_queue.put('exit')

    def handle_shutdown(self, silent=False):
        if not silent: print(" -> Nh·∫≠n l·ªánh tho√°t...")
        if self.app_instance: self.app_instance.destroy_all_windows(); self.app_instance = None
        self.backend.shutdown(silent=silent)
        if self.root.winfo_exists(): self.root.destroy()

    def handle_restart(self):
        print(" -> Nh·∫≠n l·ªánh kh·ªüi ƒë·ªông l·∫°i...")
        global needs_restart; needs_restart = True
        self.backend.save_session_data(silent=True)
        self.handle_shutdown(silent=True)

# ==============================================================================
# KH·ªêI TH·ª∞C THI CH√çNH (MAIN)
# ==============================================================================
needs_restart = False
command_queue = queue.Queue()
def console_input_listener(cmd_queue: queue.Queue):
    # ... (Kh√¥ng thay ƒë·ªïi)
    while True:
        try:
            command = input().strip().lower()
            if command: cmd_queue.put(command)
            if command in ['exit', 'restart']: break
        except (EOFError, KeyboardInterrupt):
            cmd_queue.put('exit'); break

def signal_handler(signum, frame):
    # ... (Kh√¥ng thay ƒë·ªïi)
    print("\nNh·∫≠n t√≠n hi·ªáu ng·∫Øt (Ctrl+C), ƒëang tho√°t...")
    if not command_queue.empty():
        try: command_queue.get_nowait()
        except queue.Empty: pass
    command_queue.put('exit')

if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal_handler)
    backend_instance = Backend()
    backend_instance.start_background_tasks()
    console_thread = threading.Thread(target=console_input_listener, args=(command_queue,), daemon=True)
    console_thread.start()
    print("Ch∆∞∆°ng tr√¨nh ƒë√£ s·∫µn s√†ng.")
    print("G√µ 'show' ƒë·ªÉ m·ªü giao di·ªán, 'exit' ƒë·ªÉ tho√°t, 'restart' ƒë·ªÉ kh·ªüi ƒë·ªông l·∫°i.")
    main_controller = MainController(backend_instance, command_queue)
    command_queue.put('show')
    main_controller.run()
    if needs_restart:
        print("\n" + "="*50); print("KH·ªûI ƒê·ªòNG L·∫†I CH∆Ø∆†NG TR√åNH..."); print("="*50 + "\n")
        try: os.execv(sys.executable, ['python'] + sys.argv)
        except Exception as e: print(f"L·ªñI KH√îNG TH·ªÇ KH·ªûI ƒê·ªòNG L·∫†I: {e}")
    else: print("Ch∆∞∆°ng tr√¨nh ƒë√£ k·∫øt th√∫c.")
