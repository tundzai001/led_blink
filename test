import tkinter as tk
from tkinter import messagebox, filedialog, Toplevel
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tksheet import Sheet
import paho.mqtt.client as mqtt
import json
from datetime import datetime, timedelta
import threading
import time
import warnings
import configparser
import signal
import os
import sys
import queue
from collections import deque
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt
import numpy as np
import logging
import atexit
import subprocess
# B·ªè qua c·∫£nh b√°o kh√¥ng c·∫ßn thi·∫øt v√† thi·∫øt l·∫≠p m√¥i tr∆∞·ªùng
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1"
warnings.filterwarnings("ignore", category=DeprecationWarning)

# --- C√ÅC TH∆Ø VI·ªÜN ƒê·∫∂C TH√ô PI ---
import RPi.GPIO as GPIO
import pygame

logger = logging.getLogger()
logger.setLevel(logging.INFO) 
file_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
console_formatter = logging.Formatter('%(message)s')

file_handler = logging.FileHandler('sensor_monitor.log', encoding='utf-8')
file_handler.setLevel(logging.INFO) 
file_handler.setFormatter(file_formatter)
logger.addHandler(file_handler)

console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO) 
console_handler.setFormatter(console_formatter) 
logger.addHandler(console_handler)

# ==============================================================================
# QU·∫¢N L√ù H·∫∞NG S·ªê
# ==============================================================================
class Constants:
    # File paths
    CONFIG_FILE = 'config.ini'
    SESSION_FILE = "session.json"
    SOUNDS_DIR = "/home/vippro123/Desktop/code/sounds" 

    # GPIO pins
    LED1_PIN = 3
    LED2_PIN = 27

    # Data & UI limits
    MAX_PLOT_POINTS = 10000
    MAX_SENSOR_RECORDS = 10000
    CHART_POINTS_PER_VIEW = 40

    # MQTT defaults
    DEFAULT_BROKER = "aitogy.xyz"
    DEFAULT_PORT = 1883
    DEFAULT_USER = "abc"
    DEFAULT_PASS = "xyz"

    # Alert thresholds & logic
    DEFAULT_WARN_THRESHOLD = 1.0
    DEFAULT_CRIT_THRESHOLD = 1.2
    SAFE_READINGS_REQUIRED_INITIAL = 10
    SAFE_READINGS_REQUIRED_RETURN_1 = 10
    SAFE_READINGS_REQUIRED_RETURN_2 = 15
    WARNING_REPEAT_INTERVAL = 6
    DECREASING_REPEAT_INTERVAL = 10

    # GUI Signals
    DATA_CLEAR_SIGNAL = "CLEAR_ALL_DATA"

# ==============================================================================
# C·∫¢NH B√ÅO 
# ==============================================================================
class AlertManager:
    def __init__(self, backend_ref):
        self.backend = backend_ref
        self.current_level = 0
        self.safe_readings_count = 0
        self.warning_readings_count = 0
        self.decreasing_warning_count = 0
        self.was_in_high_level_state = False
        self.initial_safe_played = False
        self.safe_return_phase = 0
        self.alert_thread = None

    def _play_sequence_in_thread(self, sound_list):
        self.stop_all_alerts()
        if self.alert_thread and self.alert_thread.is_alive():
            pass

        def target():
            if not self.backend.mixer_initialized: return
            for sound in sound_list:
                if sound:
                    if threading.current_thread() != self.alert_thread:
                        return
                    logger.info(f" -> ƒêang ph√°t √¢m thanh...")
                    sound.play()
                    while pygame.mixer.get_busy():
                        if threading.current_thread() != self.alert_thread:
                            pygame.mixer.stop()
                            return
                        time.sleep(0.1)
                else:
                    logger.warning("B·ªè qua file √¢m thanh kh√¥ng t·ªìn t·∫°i trong chu·ªói.")
                time.sleep(0.2)
        
        self.alert_thread = threading.Thread(target=target, daemon=True)
        self.alert_thread.start()

    def stop_all_alerts(self):
        if self.backend.mixer_initialized:
            pygame.mixer.stop()
        self.alert_thread = None

    def process_new_value(self, value):
        previous_level = self.current_level
        new_level = self._calculate_alert_level(value)

        if new_level == 0:
            self._handle_safe_state()
        elif new_level == 1:
            self._handle_warning_state(previous_level)
        elif new_level == 2:
            self._handle_critical_state()

        if new_level != previous_level:
            if new_level == 0 and previous_level > 0:
                self.safe_readings_count = 1
            logger.info(f"Chuy·ªÉn tr·∫°ng th√°i t·ª´ {previous_level} -> {new_level}")

        self.current_level = new_level
        return new_level

    def _calculate_alert_level(self, value):
        if value >= self.backend.critical_threshold:
            return 2
        elif value >= self.backend.warning_threshold:
            return 1
        return 0

    def _handle_safe_state(self):
        self.warning_readings_count = 0
        self.decreasing_warning_count = 0
        self.safe_readings_count += 1

        if not self.was_in_high_level_state:
            if not self.initial_safe_played and self.safe_readings_count == Constants.SAFE_READINGS_REQUIRED_INITIAL:
                logger.info(f"An to√†n ban ƒë·∫ßu: ƒê·ªß {Constants.SAFE_READINGS_REQUIRED_INITIAL} l·∫ßn, ph√°t 'safe.mp3'.")
                self._play_sequence_in_thread([self.backend.safe_sound_1])
                self.initial_safe_played = True
        else:
            if self.safe_return_phase == 0:
                 self.safe_return_phase = 1
            
            if self.safe_return_phase == 1 and self.safe_readings_count == Constants.SAFE_READINGS_REQUIRED_RETURN_1:
                logger.info(f"V·ªÅ an to√†n: ƒê·ªß {Constants.SAFE_READINGS_REQUIRED_RETURN_1} l·∫ßn, ph√°t 'safe2.mp3'.")
                self._play_sequence_in_thread([self.backend.safe_sound_2])
                self.safe_return_phase = 2
            elif self.safe_return_phase == 2 and self.safe_readings_count == Constants.SAFE_READINGS_REQUIRED_RETURN_2:
                logger.info(f"V·ªÅ an to√†n: ƒê·ªß {Constants.SAFE_READINGS_REQUIRED_RETURN_2} l·∫ßn, ph√°t 'safe2.mp3' l·∫ßn cu·ªëi.")
                self._play_sequence_in_thread([self.backend.safe_sound_2])
                self.safe_return_phase = 3
                self.was_in_high_level_state = False
                self.initial_safe_played = True

    def _handle_warning_state(self, previous_level):
        self.safe_readings_count = 0
        self.safe_return_phase = 0
        if not self.was_in_high_level_state:
            self.was_in_high_level_state = True
            
        if previous_level == 0:
            logger.info("TƒÇNG l√™n C·∫£nh b√°o. Ph√°t 'coi1' -> 'warning'.")
            self._play_sequence_in_thread([self.backend.siren_sound, self.backend.warning_sound])
            self.warning_readings_count = 1
            self.decreasing_warning_count = 0
        elif previous_level == 2:
            logger.info("GI·∫¢M t·ª´ Nguy hi·ªÉm xu·ªëng C·∫£nh b√°o. Ph√°t 'decrease'.")
            self._play_sequence_in_thread([self.backend.decreasing_sound])
            self.decreasing_warning_count = 1
            self.warning_readings_count = 0
        elif previous_level == 1:
            if self.warning_readings_count > 0:
                self.warning_readings_count += 1
                logger.info(f"Duy tr√¨ C·∫£nh b√°o (tƒÉng), l·∫ßn {self.warning_readings_count}.")
                if self.warning_readings_count % Constants.WARNING_REPEAT_INTERVAL == 0:
                     logger.info("Ph√°t l·∫°i c·∫£nh b√°o tƒÉng: 'coi1' -> 'warning'.")
                     self._play_sequence_in_thread([self.backend.siren_sound, self.backend.warning_sound])
            elif self.decreasing_warning_count > 0:
                self.decreasing_warning_count += 1
                logger.info(f"Duy tr√¨ C·∫£nh b√°o (gi·∫£m), l·∫ßn {self.decreasing_warning_count}.")
                if self.decreasing_warning_count % Constants.DECREASING_REPEAT_INTERVAL == 0:
                    logger.info("Ph√°t l·∫°i c·∫£nh b√°o gi·∫£m: 'decrease'.")
                    self._play_sequence_in_thread([self.backend.decreasing_sound])

    def _handle_critical_state(self):
        self.safe_readings_count = 0
        self.warning_readings_count = 0
        self.decreasing_warning_count = 0
        self.safe_return_phase = 0
        if not self.was_in_high_level_state:
            self.was_in_high_level_state = True
        logger.warning("NGUY HI·ªÇM! Ph√°t chu·ªói √¢m thanh nguy hi·ªÉm.")
        self._play_sequence_in_thread([self.backend.siren_sound, self.backend.critical_sound, self.backend.siren_sound])

# ==============================================================================
# L·ªöP LOGIC N·ªÄN (BACKEND)
# ==============================================================================
class Backend:
    def __init__(self):
        self.listening = False
        self.exiting = False
        self.status_text = "Tr·∫°ng th√°i: TH·ª¶ C√îNG"
        self.status_color = "red"
        self.config = configparser.ConfigParser()
        
        self.broker = Constants.DEFAULT_BROKER
        self.port = Constants.DEFAULT_PORT
        self.username = Constants.DEFAULT_USER
        self.password = Constants.DEFAULT_PASS
        self.publish_topic = ""
        self.subscribe_topics = []
        self.water_topics = []
        self.gnss_topics = []
        self.warning_threshold = Constants.DEFAULT_WARN_THRESHOLD
        self.critical_threshold = Constants.DEFAULT_CRIT_THRESHOLD
        
        self.warning_sound, self.critical_sound, self.siren_sound = None, None, None
        self.decreasing_sound, self.safe_sound_1, self.safe_sound_2 = None, None, None
        self.mixer_initialized = False

        # ƒê·ªÄ XU·∫§T 4: QU·∫¢N L√ù B·ªò NH·ªö
        self.sensor_data = deque(maxlen=Constants.MAX_SENSOR_RECORDS)
        self.plot_data_points = deque(maxlen=Constants.MAX_PLOT_POINTS)
        
        self.gui_update_queue = queue.Queue()
        self.client = mqtt.Client(protocol=mqtt.MQTTv311)
        self.client.on_connect = self.on_connect
        self.client.on_disconnect = self.on_disconnect
        self.client.on_message = self.on_message

        self.shifting_process = None  
        self.gnss_velocity_queue = queue.Queue()
        self.gnss_time_settings = {
            'calculate_per_second': True,
            'calculate_per_minute': False, 
            'calculate_per_hour': False,
            'calculate_per_day': False,
            'calculate_per_month': False
        }
        
        self.alert_manager = AlertManager(self)

        self.setup_audio_mixer()
        self.setup_gpio()
        self.load_config()

        atexit.register(self.cleanup_on_exit)

    def start_shifting_process(self):
        if self.shifting_process and self.shifting_process.poll() is None:
            logger.info("Process shifting.py ƒë√£ ƒëang ch·∫°y.")
            return
        if not self.gnss_topics:
            logger.warning("Kh√¥ng c√≥ GNSS topics ƒë·ªÉ kh·ªüi ƒë·ªông shifting.py")
            return
            
        try:
            gnss_settings = {
                'broker': self.broker,
                'port': self.port,
                'username': self.username, 
                'password': self.password,
                'gnss_topics': self.gnss_topics,
                'time_intervals': getattr(self, 'gnss_time_settings', {
                    'calculate_per_second': True,
                    'calculate_per_minute': False,
                    'calculate_per_hour': False,
                    'calculate_per_day': False,
                    'calculate_per_month': False
                })
            }
            with open('gnss_settings.json', 'w') as f:
                json.dump(gnss_settings, f)

            self.shifting_process = subprocess.Popen([
                sys.executable, 'shifting.py'
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            
            logger.info("ƒê√£ kh·ªüi ƒë·ªông process shifting.py")
            
        except Exception as e:
            logger.error(f"L·ªói kh·ªüi ƒë·ªông shifting.py: {e}")

    def _read_shifting_output(self, pipe):
        for line in iter(pipe.readline, ''):
            if self.exiting:
                break
            try:
                # M·ªói d√≤ng l√† m·ªôt chu·ªói JSON ch·ª©a k·∫øt qu·∫£
                data = json.loads(line)
                # S·ª≠ d·ª•ng l·∫°i h√†m x·ª≠ l√Ω b√°o c√°o ƒë√£ c√≥
                self.handle_gnss_report(data)
            except json.JSONDecodeError:
                logger.warning(f"Nh·∫≠n ƒë∆∞·ª£c d√≤ng kh√¥ng ph·∫£i JSON t·ª´ shifting.py: {line.strip()}")
            except Exception as e:
                logger.error(f"L·ªói khi ƒë·ªçc k·∫øt qu·∫£ t·ª´ shifting.py: {e}")
        pipe.close()
        logger.info("Lu·ªìng ƒë·ªçc k·∫øt qu·∫£ t·ª´ shifting.py ƒë√£ d·ª´ng.")

    def handle_gnss_report(self, data: dict):
        try:
            classification_name = "Kh√¥ng x√°c ƒë·ªãnh"
            received_velocities = data.get("velocities", {})
            sorted_classification = sorted(
                self.gnss_speed_classification,
                key=lambda x: float(x.get('mm_giay', 0)),
                reverse=True
            )
            
            received_mm_per_sec = received_velocities.get('mm_giay')
            
            if received_mm_per_sec is not None:
                for level in sorted_classification:
                    threshold_mm_per_sec = level.get('mm_giay')
                    if threshold_mm_per_sec is not None and received_mm_per_sec >= float(threshold_mm_per_sec):
                        classification_name = level['name']
                        break # T√¨m th·∫•y m·ª©c ƒë·ªô ph√π h·ª£p ƒë·∫ßu ti√™n (nhanh nh·∫•t)

            name = data.get("sensorname", "GNSS")
            # Hi·ªÉn th·ªã gi√° tr·ªã ch√≠nh (mm/gi√¢y) v√† ƒë∆°n v·ªã
            value_str = f"{data.get('value', 0):.4f} {data.get('unit', '')}" 
            status = classification_name # **ƒê√¢y l√† k·∫øt qu·∫£ ph√¢n lo·∫°i**
            
            ts = float(data.get("timestamp", time.time()))
            dt_object = datetime.fromtimestamp(ts)
            
            # T·∫°o b·∫£n ghi ƒë·ªÉ hi·ªÉn th·ªã tr√™n GUI
            record = (name, value_str, status, dt_object.strftime("%H:%M:%S %d-%m"))
            
            self.sensor_data.append(record)
            # Kh√¥ng th√™m d·ªØ li·ªáu GNSS v√†o bi·ªÉu ƒë·ªì c·ªßa c·∫£m bi·∫øn n∆∞·ªõc
            # self.plot_data_points.append(...) 
            
            self.gui_update_queue.put(record)
            
            # Nh√°y ƒë√®n LED ƒë·ªÉ b√°o hi·ªáu c√≥ d·ªØ li·ªáu m·ªõi
            threading.Thread(target=self.flash_led, args=(Constants.LED1_PIN,), daemon=True).start()

        except Exception as e:
            logger.error(f"L·ªói x·ª≠ l√Ω b√°o c√°o GNSS: {e}")
            
    def stop_shifting_process(self):
        """D·ª´ng process shifting.py"""
        if self.shifting_process and self.shifting_process.poll() is None:
            try:
                logger.info("ƒêang d·ª´ng ti·∫øn tr√¨nh shifting.py...")
                self.shifting_process.terminate() # G·ª≠i t√≠n hi·ªáu SIGTERM
                self.shifting_process.wait(timeout=5) # Ch·ªù 5 gi√¢y
                logger.info("ƒê√£ d·ª´ng th√†nh c√¥ng ti·∫øn tr√¨nh shifting.py.")
            except subprocess.TimeoutExpired:
                logger.warning("Ti·∫øn tr√¨nh shifting.py kh√¥ng ph·∫£n h·ªìi, bu·ªôc d·ª´ng (kill).")
                self.shifting_process.kill()
            except Exception as e:
                logger.error(f"L·ªói khi d·ª´ng shifting.py: {e}")
        self.shifting_process = None

    def on_message(self, client, userdata, msg):
        if not self.listening or self.exiting: return
        if msg.topic in self.gnss_topics:
            return
        try:
            data = json.loads(msg.payload.decode('utf-8'))
            if "value" in data:
                value = float(data.get("value"))
                new_level = self.alert_manager.process_new_value(value)

                name = data.get("sensorname", msg.topic)
                ts = float(data.get("timestamp", time.time()))
                dt_object = datetime.fromtimestamp(ts)
                status = "NGUY HIEM" if new_level == 2 else ("CANH BAO" if new_level == 1 else "AN TOAN")
                
                # Hi·ªÉn th·ªã gi√° tr·ªã g·ªëc (m√©t) cho c·∫£m bi·∫øn n∆∞·ªõc
                record = (name, f"{value:.4f}", status, dt_object.strftime("%H:%M:%S %d-%m"))
                self.sensor_data.append(record)
                self.plot_data_points.append((dt_object, value))
                self.gui_update_queue.put(record)

                threading.Thread(target=self.flash_led, args=(Constants.LED1_PIN,), daemon=True).start()
                if new_level > 0:
                    threading.Thread(target=self.flash_led, args=(Constants.LED2_PIN,), daemon=True).start()

                if self.publish_topic:
                    payload_out_str = f"{name},{value},{status},{ts}"
                    self.client.publish(self.publish_topic, payload_out_str)
            else:
                logger.info(f"Nh·∫≠n ƒë∆∞·ª£c tin nh·∫Øn kh√¥ng ph·∫£i d·ªØ li·ªáu t·ª´ topic '{msg.topic}', b·ªè qua.")

        except (json.JSONDecodeError, ValueError, KeyError) as e:
            logger.error(f"L·ªói x·ª≠ l√Ω message: {e} | Payload: {msg.payload.decode('utf-8', errors='ignore')}")

    def setup_audio_mixer(self):
        try:
            pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=4096)
            self.mixer_initialized = True
            self._load_audio_files()
        except Exception as e:
            logger.error(f"Kh√¥ng th·ªÉ kh·ªüi t·∫°o pygame mixer: {e}")
            self.mixer_initialized = False

    def _load_audio_files(self):
        if not self.mixer_initialized: return
        
        def load_sound(filename):
            path = os.path.join(Constants.SOUNDS_DIR, filename)
            if os.path.exists(path):
                return pygame.mixer.Sound(path)
            logger.warning(f"Kh√¥ng t√¨m th·∫•y file √¢m thanh: {path}")
            return None

        try:
            self.siren_sound = load_sound("coi1.mp3")
            self.warning_sound = load_sound("warning.mp3")
            self.critical_sound = load_sound("danger.mp3")
            self.decreasing_sound = load_sound("decrease.mp3")
            self.safe_sound_1 = load_sound("safe.mp3")
            self.safe_sound_2 = load_sound("safe2.mp3")
        except Exception as e:
            logger.error(f"L·ªói khi t·∫£i file √¢m thanh: {e}")

    def update_and_reconnect(self, settings: dict):
        self.broker, self.port = settings['broker'], int(settings['port'])
        self.username, self.password = settings['username'], settings['password']
        self.publish_topic = settings['publish']
        self.update_topics_from_gui(settings['water_topics'], settings['gnss_topics'])
        self.warning_threshold = float(settings['warning_threshold'])
        self.critical_threshold = float(settings['critical_threshold'])
        self.save_config()
        if self.listening:
            self.toggle_off()
            time.sleep(1)
            self.toggle_on()

    def update_topics_from_gui(self, water_topics_text, gnss_topics_text):
        self.water_topics = [t.strip() for t in water_topics_text.splitlines() if t.strip()]
        self.gnss_topics = [t.strip() for t in gnss_topics_text.splitlines() if t.strip()]
        self.subscribe_topics = self.water_topics + self.gnss_topics

    def load_config(self):
        if not os.path.exists(Constants.CONFIG_FILE):
            logger.warning(f"File c·∫•u h√¨nh '{Constants.CONFIG_FILE}' kh√¥ng t·ªìn t·∫°i. S·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh.")
            self._reset_gnss_to_default()
            return
            
        try:
            self.config.read(Constants.CONFIG_FILE, encoding='utf-8')
            if "MQTT" in self.config:
                mqtt_cfg = self.config["MQTT"]
                self.broker = mqtt_cfg.get("broker", self.broker)
                self.port = mqtt_cfg.getint("port", self.port)
                self.username = mqtt_cfg.get("username", self.username)
                self.password = mqtt_cfg.get("password", self.password)
                self.water_topics = [t.strip() for t in mqtt_cfg.get("water_sub_topic", "").splitlines() if t.strip()]
                self.gnss_topics = [t.strip() for t in mqtt_cfg.get("gnss_sub_topic", "").splitlines() if t.strip()]
                self.subscribe_topics = self.water_topics + self.gnss_topics
                self.publish_topic = mqtt_cfg.get("publish", self.publish_topic)
                
            if "Settings" in self.config:
                settings_cfg = self.config["Settings"]
                self.warning_threshold = settings_cfg.getfloat("warning_threshold", self.warning_threshold)
                self.critical_threshold = settings_cfg.getfloat("critical_threshold", self.critical_threshold)

            if "GNSS_Classification" in self.config:
                self._load_gnss_from_config(self.config["GNSS_Classification"])
            else:
                 self._reset_gnss_to_default()
                 
            logger.info("ƒê√£ t·∫£i c·∫•u h√¨nh th√†nh c√¥ng.")
        except Exception as e:
            logger.error(f"L·ªói khi t·∫£i c·∫•u h√¨nh t·ª´ {Constants.CONFIG_FILE}: {e}")

    def save_config(self):
        try:
            self.config['MQTT'] = {
                'broker': self.broker, 'port': self.port, 'username': self.username,
                'password': self.password,
                'water_sub_topic': "\n".join(self.water_topics),
                'gnss_sub_topic': "\n".join(self.gnss_topics),
                'publish': self.publish_topic
            }
            self.config['Settings'] = {
                'warning_threshold': self.warning_threshold,
                'critical_threshold': self.critical_threshold
            }
            self.config['GNSS_Classification'] = {}
            for i, item in enumerate(self.gnss_speed_classification):
                for key, value in item.items():
                    self.config['GNSS_Classification'][f'item_{i}_{key}'] = str(value)

            with open(Constants.CONFIG_FILE, 'w', encoding='utf-8') as f:
                self.config.write(f)
            logger.info("ƒê√£ l∆∞u c·∫•u h√¨nh.")
        except IOError as e:
            logger.error(f"L·ªói khi l∆∞u file c·∫•u h√¨nh: {e}")
            
    def _reset_gnss_to_default(self):
        self.gnss_speed_classification = [
            {"name": "Nguy c·∫•p", "m_nam": "", "m_thang": "", "m_ngay": "", "m_gio": 18000, "m_phut": 300, "m_giay": 5, "mm_giay": 5000},
            {"name": "R·∫•t nhanh", "m_nam": "", "m_thang": "", "m_ngay": 4320, "m_gio": 180, "m_phut": 3, "m_giay": 0.05, "mm_giay": 50},
            {"name": "Nhanh", "m_nam": 1296.0, "m_thang": 43.2, "m_ngay": 1.8, "m_gio": 0.03, "m_phut": 0.0005, "m_giay": 0.5, "mm_giay": 0.5},
            {"name": "Trung b√¨nh", "m_nam": 157.68, "m_thang": 12.96, "m_ngay": 0.432, "m_gio": 0.018, "m_phut": 0.0003, "m_giay": 5e-06, "mm_giay": 0.005},
            {"name": "Ch·∫≠m", "m_nam": 0.158, "m_thang": 0.013, "m_ngay": 0.000432, "m_gio": 1.8e-06, "m_phut": 3e-08, "m_giay": 5e-10, "mm_giay": 5e-07},
            {"name": "R·∫•t ch·∫≠m", "m_nam": 0.017, "m_thang": 0.0014, "m_ngay": 4.75e-05, "m_gio": 1.98e-06, "m_phut": 3.3e-08, "m_giay": 5.5e-10, "mm_giay": 5.5e-07}
        ]

    def _load_gnss_from_config(self, gnss_cfg):
        items_dict = {}
        for key, value in gnss_cfg.items():
            if key.startswith('item_'):
                parts = key.split('_', 2)
                if len(parts) == 3:
                    item_index, attr_name = int(parts[1]), parts[2]
                    if item_index not in items_dict:
                        items_dict[item_index] = {}
                    if attr_name == 'name':
                        items_dict[item_index][attr_name] = value
                    else:
                        try:
                            items_dict[item_index][attr_name] = float(value) if value else ""
                        except ValueError:
                            items_dict[item_index][attr_name] = value
        if items_dict:
            self.gnss_speed_classification = [items_dict[i] for i in sorted(items_dict.keys())]

    def cleanup_on_exit(self):
        if self.exiting: return
        logger.info("B·∫Øt ƒë·∫ßu qu√° tr√¨nh d·ªçn d·∫πp ƒë·ªÉ tho√°t...")
        self.exiting = True
        
        self.alert_manager.stop_all_alerts()
        self.stop_shifting_process()
        
        try:
            if self.client.is_connected():
                self.client.loop_stop(force=True)
                self.client.disconnect()
        except Exception: pass
            
        self.save_session_data(silent=True)
        
        GPIO.cleanup()
        logger.info("Backend ƒë√£ d·ª´ng.")

    def setup_gpio(self):
        try:
            GPIO.setmode(GPIO.BCM)
            GPIO.setwarnings(False)
            GPIO.setup(Constants.LED1_PIN, GPIO.OUT, initial=GPIO.LOW)
            GPIO.setup(Constants.LED2_PIN, GPIO.OUT, initial=GPIO.LOW)
            logger.info("GPIO setup successful.")
        except Exception as e:
            logger.error(f"L·ªói khi c√†i ƒë·∫∑t GPIO: {e}. Vui l√≤ng ch·∫°y v·ªõi quy·ªÅn sudo.")

    def start_background_tasks(self):
        self.load_session_data()
        threading.Thread(target=self.auto_clear_scheduler, daemon=True).start()
        logger.info("ƒê√£ kh·ªüi ch·∫°y c√°c t√°c v·ª• n·ªÅn.")

    def flash_led(self, pin, duration=0.3):
        try:
            GPIO.output(pin, GPIO.HIGH)
            time.sleep(duration)
            GPIO.output(pin, GPIO.LOW)
        except Exception as e:
            logger.error(f"L·ªói nh√°y LED tr√™n pin {pin}: {e}")

    def on_connect(self, client, userdata, flags, rc):
        if self.exiting: return
        if rc == 0:
            logger.info("MQTT Connected successfully.")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: T·ª∞ ƒê·ªòNG", "green"
            if self.subscribe_topics:
                for t in self.subscribe_topics:
                    client.subscribe(t)
                    if t in self.gnss_topics:
                        logger.info(f"Subscribed to RAW GNSS Topic (for forwarding): {t}")
                    else: 
                        logger.info(f"Subscribed: {t}")
            if not self.subscribe_topics:
                logger.warning("Kh√¥ng c√≥ topic n√†o ƒë·ªÉ subscribe, s·∫Ω kh√¥ng nh·∫≠n d·ªØ li·ªáu.")
                self.status_text = "Tr·∫°ng th√°i: T·ª∞ ƒê·ªòNG (Kh√¥ng c√≥ topic)"
        else:
            logger.error(f"Failed to connect to MQTT, return code {rc}")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: L·ªñI K·∫æT N·ªêI", "red"
            self.listening = False

    def on_disconnect(self, client, userdata, rc):
        if not self.exiting and self.listening:
            logger.warning("M·∫•t k·∫øt n·ªëi MQTT...")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: M·∫§T K·∫æT N·ªêI", "orange"

    def get_gui_updates(self):
        updates = []
        while not self.gui_update_queue.empty():
            try:
                updates.append(self.gui_update_queue.get_nowait())
            except queue.Empty:
                break
        return updates

    # ƒê·ªÄ XU·∫§T 3: C·∫¢I THI·ªÜN X·ª¨ L√ù L·ªñI CHO MQTT
    def safe_mqtt_connect(self):
        max_retries = 3
        for attempt in range(max_retries):
            try:
                self.client.connect_async(self.broker, self.port, 60)
                self.client.loop_start()
                return True
            except Exception as e:
                logger.error(f"K·∫øt n·ªëi MQTT l·∫ßn th·ª≠ {attempt + 1}/{max_retries} th·∫•t b·∫°i: {e}")
                if attempt < max_retries - 1:
                    wait_time = 2 ** attempt
                    logger.info(f"Th·ª≠ l·∫°i sau {wait_time} gi√¢y...")
                    time.sleep(wait_time)
        return False

    def toggle_on(self):
        if self.listening: return
        self.listening = True
        self.status_text, self.status_color = "Tr·∫°ng th√°i: ƒêANG K·∫æT N·ªêI...", "orange"
        
        if not self.broker:
            self.listening = False
            self.status_text, self.status_color = "Tr·∫°ng th√°i: TH·ª¶ C√îNG (L·ªói Broker)", "red"
            logger.error("Kh√¥ng th·ªÉ b·∫≠t, ch∆∞a c·∫•u h√¨nh MQTT Broker.")
            return

        self.client.username_pw_set(self.username, self.password)
        logger.info(f"ƒêang k·∫øt n·ªëi t·ªõi MQTT broker: {self.broker}:{self.port}...")
        
        if not self.safe_mqtt_connect():
            self.listening = False
            self.status_text, self.status_color = "Tr·∫°ng th√°i: L·ªñI K·∫æT N·ªêI", "red"
            logger.error("Kh√¥ng th·ªÉ k·∫øt n·ªëi MQTT sau nhi·ªÅu l·∫ßn th·ª≠.")
            return
        if self.gnss_topics:
            self.start_shifting_process()

    def toggle_off(self):
        if not self.listening: return
        self.listening = False
        self.stop_shifting_process()
        try:
            self.client.loop_stop()
            self.client.disconnect()
            logger.info("ƒê√£ ng·∫Øt k·∫øt n·ªëi MQTT.")
        except Exception: pass
        self.status_text, self.status_color = "Tr·∫°ng th√°i: TH·ª¶ C√îNG", "red"

    def check_leds(self):
        if self.listening:
            logger.warning("Kh√¥ng th·ªÉ ki·ªÉm tra LED ·ªü ch·∫ø ƒë·ªô T·ª∞ ƒê·ªòNG.")
            return False
        threading.Thread(target=self._run_led_check, daemon=True).start()
        return True

    def _run_led_check(self):
        logger.info("Ki·ªÉm tra LED...")
        self.flash_led(Constants.LED1_PIN, duration=0.5)
        time.sleep(0.1)
        self.flash_led(Constants.LED2_PIN, duration=0.5)

    def auto_clear_scheduler(self):
        while not self.exiting:
            now = datetime.now()
            if now.hour == 0 and now.minute == 0:
                logger.info("ƒê√£ ƒë·∫øn 00:00, t·ª± ƒë·ªông x√≥a d·ªØ li·ªáu...")
                self.clear_all_data()
                time.sleep(61)
            else:
                time.sleep(30)

    def clear_all_data(self):
        self.sensor_data.clear()
        self.plot_data_points.clear()
        self.gui_update_queue.put(Constants.DATA_CLEAR_SIGNAL)
        logger.info("ƒê√£ x√≥a d·ªØ li·ªáu n·ªÅn.")

    def save_session_data(self, silent=False):
        if not silent: logger.info("ƒêang l∆∞u tr·∫°ng th√°i hi·ªán t·∫°i v√†o file...")
        try:
            plot_data_serializable = [(dt.isoformat(), val) for dt, val in self.plot_data_points]
            session = {"sensor_data": list(self.sensor_data), "plot_data_points": plot_data_serializable}
            with open(Constants.SESSION_FILE, "w") as f: json.dump(session, f)
            if not silent: logger.info(f"ƒê√£ l∆∞u tr·∫°ng th√°i v√†o {Constants.SESSION_FILE}")
        except Exception as e:
            logger.error(f"L·ªói khi l∆∞u tr·∫°ng th√°i: {e}")

    def load_session_data(self):
        if not os.path.exists(Constants.SESSION_FILE): return
        logger.info(f"T√¨m th·∫•y file tr·∫°ng th√°i {Constants.SESSION_FILE}, ƒëang t·∫£i l·∫°i d·ªØ li·ªáu...")
        try:
            with open(Constants.SESSION_FILE, "r") as f: session = json.load(f)
            self.sensor_data.extend(session.get("sensor_data", []))
            plot_data_serializable = session.get("plot_data_points", [])
            self.plot_data_points.clear()
            for dt_str, val in plot_data_serializable:
                self.plot_data_points.append((datetime.fromisoformat(dt_str), val))
            
            for record in self.sensor_data: self.gui_update_queue.put(record)
            logger.info("ƒê√£ t·∫£i l·∫°i d·ªØ li·ªáu th√†nh c√¥ng.")
        except Exception as e:
            logger.error(f"L·ªói khi t·∫£i tr·∫°ng th√°i: {e}")
        finally:
            if os.path.exists(Constants.SESSION_FILE):
                os.remove(Constants.SESSION_FILE)

# ==============================================================================
# L·ªöP GIAO DI·ªÜN NG∆Ø·ªúI D√ôNG (GUI)
# ==============================================================================
class AppGUI:
    def __init__(self, root: tk.Toplevel, backend: Backend, on_close_callback):
        self.root = root
        self.backend = backend
        self.on_close_callback = on_close_callback
        self.root.title("Giao di·ªán C·∫£m bi·∫øn & ƒêi·ªÅu khi·ªÉn LED")
        self.root.geometry(f"{self.root.winfo_screenwidth()}x{self.root.winfo_screenheight()-70}+0+0")
        
        self.chart_window = None
        self.settings_window = None
        self.classification_win = None # C·ª≠a s·ªï cho b·∫£ng ph√¢n lo·∫°i
        
        self.warning_threshold_var = tk.StringVar()
        self.critical_threshold_var = tk.StringVar()

        # Kh·ªüi t·∫°o c√°c bi·∫øn Boolean cho Checkbox c·ªßa GNSS
        self.gnss_second_var = tk.BooleanVar()
        self.gnss_minute_var = tk.BooleanVar()
        self.gnss_hour_var = tk.BooleanVar()
        self.gnss_day_var = tk.BooleanVar()
        self.gnss_month_var = tk.BooleanVar()

        self.CONVERSION_FACTORS = {"m": 1.0, "cm": 100.0, "mm": 1000.0, "ft": 3.28084}
        
        self.create_widgets()
        self.load_initial_data()
        self.root.after(250, self.periodic_update)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close_window)

    def create_widgets(self):
        main = ttk.Frame(self.root, padding=10)
        main.pack(fill="both", expand=True)
        main.grid_columnconfigure(1, weight=1)
        main.grid_columnconfigure(0, weight=0)
        main.grid_rowconfigure(0, weight=1)
        self.create_left_panel(main)
        self.create_right_panel(main)

    def create_left_panel(self, parent):
        left = ttk.LabelFrame(parent, text="C√†i ƒë·∫∑t MQTT", padding=10)
        left.grid(row=0, column=0, sticky="nsw", padx=(0, 15))

        def add_labeled_entry(frame, label, row, show=None):
            ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w", pady=3)
            entry = ttk.Entry(frame, show=show)
            entry.grid(row=row, column=1, sticky="ew", pady=3, columnspan=2)
            return entry

        self.broker_entry = add_labeled_entry(left, "MQTT Broker:", 0)
        self.port_entry = add_labeled_entry(left, "Port:", 1)
        self.user_entry = add_labeled_entry(left, "Username:", 2)
        self.pass_entry = add_labeled_entry(left, "Password:", 3, show="*")
        ttk.Button(left, text="üëÅ", command=self.toggle_pass, width=2, bootstyle="light").grid(row=3, column=2, sticky="e")
        self.pub_entry = add_labeled_entry(left, "Publish Topic:", 4)

        ttk.Label(left, text="Water Sub Topic:").grid(row=5, column=0, columnspan=3, sticky="w", pady=(10, 2))
        self.water_topic_entry = tk.Text(left, height=4, width=35, relief="solid", borderwidth=1)
        self.water_topic_entry.grid(row=6, column=0, columnspan=3, pady=(0, 5), sticky="nsew")

        ttk.Label(left, text="GNSS Sub Topic:").grid(row=7, column=0, columnspan=3, sticky="w", pady=(10, 2))
        self.gnss_topic_entry = tk.Text(left, height=4, width=35, relief="solid", borderwidth=1)
        self.gnss_topic_entry.grid(row=8, column=0, columnspan=3, pady=(0, 5), sticky="nsew")

        ttk.Button(left, text="C√†i ƒë·∫∑t N√¢ng cao", command=self.open_settings_window, bootstyle="secondary").grid(row=9, column=0, columnspan=3, sticky="ew", pady=(10, 5))
        ttk.Button(left, text="L∆∞u & √Åp d·ª•ng", command=lambda: self.apply_and_save_config(), bootstyle="primary").grid(row=10, column=0, columnspan=3, sticky="ew", pady=(5,0))
        left.grid_rowconfigure(6, weight=1)
        left.grid_rowconfigure(8, weight=1)
    
    def periodic_update(self):
        if not self.root.winfo_exists(): return
        self.update_status_label()
        new_updates = self.backend.get_gui_updates()
        if new_updates:
            if Constants.DATA_CLEAR_SIGNAL in new_updates:
                self.sheet.set_sheet_data(data=[])
                if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.clear_chart_data()
                logger.info("GUI ƒë√£ nh·∫≠n t√≠n hi·ªáu v√† x√≥a b·∫£ng.")
            else:
                valid_records = [rec for rec in new_updates if isinstance(rec, tuple)]
                if valid_records:
                    self.sheet.insert_rows(rows=len(self.sheet.get_sheet_data()), data=valid_records, add_new_rows=True)
                    self.sheet.dehighlight_all()
                    last_row_index = self.sheet.get_total_rows() - 1
                    if last_row_index >= 0:
                        self.sheet.see(row=last_row_index)
                        last_record = valid_records[-1]
                        status = last_record[2]
                        if status == "NGUY HIEM":
                            highlight_color = "#F8D7DA"
                        elif status == "CANH BAO":
                            highlight_color = "#FFF3CD"
                        else:
                            highlight_color = "#D4EDDA"
                        self.sheet.highlight_rows(rows=[last_row_index], bg=highlight_color, fg="black")
            if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.update_plot()
        self.root.after(250, self.periodic_update)

    def on_close_window(self):
        logger.info("ƒê√£ ƒë√≥ng c·ª≠a s·ªï giao di·ªán. G√µ 'show' trong terminal ƒë·ªÉ m·ªü l·∫°i.")
        self.on_close_callback()
        self.destroy_all_windows()

    def exit_program_graceful(self):
        if messagebox.askokcancel("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën tho√°t ho√†n to√†n ch∆∞∆°ng tr√¨nh?", parent=self.root):
            logger.info("T·ª± ƒë·ªông l∆∞u c·∫•u h√¨nh hi·ªán t·∫°i tr∆∞·ªõc khi tho√°t...")
            self.apply_and_save_config(show_message=False)
            self.on_close_callback(shutdown=True)

    def destroy_all_windows(self):
        if self.settings_window and self.settings_window.winfo_exists(): self.settings_window.destroy()
        if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.destroy()
        if self.classification_win and self.classification_win.winfo_exists(): self.classification_win.destroy()
        if self.root and self.root.winfo_exists(): self.root.destroy()
        
    def create_right_panel(self, parent):
        right = ttk.Frame(parent)
        right.grid(row=0, column=1, sticky="nsew")
        right.grid_rowconfigure(1, weight=1)
        right.grid_columnconfigure(0, weight=1)
        self.status_label = ttk.Label(right, text="", font=("Arial", 11, "bold"))
        self.status_label.grid(row=0, column=0, sticky="ew", pady=(0, 5))
        sheet_frame = ttk.Frame(right)
        sheet_frame.grid(row=1, column=0, sticky="nsew")
        self.sheet = Sheet(sheet_frame, headers=["T√™n", "Gi√° tr·ªã (m)", "Tr·∫°ng th√°i", "Th·ªùi gian"], show_row_index=True)
        self.sheet.pack(fill=tk.BOTH, expand=True)
        self.sheet.disable_bindings("all")
        self.sheet.set_options(font=("Arial", 10, "normal"), header_font=("Arial", 10, "bold"), align="center")
        self.create_control_panel(right)

    def create_control_panel(self, parent_frame):
        bottom_part = ttk.Frame(parent_frame)
        bottom_part.grid(row=2, column=0, sticky="ew", pady=(10, 0))
        ctrl = ttk.Frame(bottom_part)
        ctrl.pack(side=tk.TOP, fill=tk.X, expand=True)
        for i in range(5): ctrl.grid_columnconfigure(i, weight=1)
        ttk.Button(ctrl, text="T·ª± ƒë·ªông (ON)", command=self.backend.toggle_on, bootstyle="success").grid(row=0, column=0, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Th·ªß c√¥ng (OFF)", command=self.backend.toggle_off, bootstyle="danger").grid(row=0, column=1, padx=2, sticky="ew")
        self.save_csv_button = ttk.Button(ctrl, text="L∆∞u CSV", command=self.save_to_csv, bootstyle="info")
        self.save_csv_button.grid(row=0, column=2, padx=2, sticky="ew")
        ttk.Button(ctrl, text="X√≥a D·ªØ Li·ªáu", command=self.clear_table_gui, bootstyle="warning").grid(row=0, column=3, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Xem Bi·ªÉu ƒê·ªì", command=self.show_chart_window, bootstyle="primary").grid(row=0, column=4, padx=2, sticky="ew")
        led_panel = ttk.LabelFrame(bottom_part, text="Ki·ªÉm tra Thi·∫øt b·ªã", padding=5)
        led_panel.pack(side=tk.TOP, fill=tk.X, expand=True, pady=(10, 0))
        led_panel.grid_columnconfigure(0, weight=3)
        led_panel.grid_columnconfigure(1, weight=1)
        ttk.Button(led_panel, text="Ki·ªÉm tra LED", command=self.on_check_led_click).grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        ttk.Button(led_panel, text="Tho√°t", command=self.exit_program_graceful, bootstyle="secondary-outline").grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        
    def load_initial_data(self):
        self.broker_entry.insert(0, self.backend.broker)
        self.port_entry.insert(0, str(self.backend.port))
        self.user_entry.insert(0, self.backend.username)
        self.pass_entry.insert(0, self.backend.password)
        self.pub_entry.insert(0, self.backend.publish_topic)
        self.water_topic_entry.insert("1.0", "\n".join(self.backend.water_topics))
        self.gnss_topic_entry.insert("1.0", "\n".join(self.backend.gnss_topics))
        self.warning_threshold_var.set(str(self.backend.warning_threshold))
        self.critical_threshold_var.set(str(self.backend.critical_threshold))

    def _validate_config(self, settings):
        errors = []
        if not settings.get('broker'):
            errors.append("MQTT Broker kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng")
        try:
            port = int(settings.get('port', 0))
            if not (1 <= port <= 65535):
                errors.append("Port ph·∫£i l√† m·ªôt s·ªë t·ª´ 1-65535")
        except (ValueError, TypeError):
            errors.append("Port ph·∫£i l√† m·ªôt s·ªë nguy√™n")
        try:
            warning = float(settings.get('warning_threshold', 0))
            critical = float(settings.get('critical_threshold', 0))
            if critical <= warning:
                errors.append("Ng∆∞·ª°ng nguy hi·ªÉm ph·∫£i l·ªõn h∆°n ng∆∞·ª°ng c·∫£nh b√°o")
        except (ValueError, TypeError):
            errors.append("C√°c gi√° tr·ªã ng∆∞·ª°ng ph·∫£i l√† s·ªë")
        return errors

    def apply_and_save_config(self, show_message=True, parent_window=None):
        if parent_window is None: parent_window = self.root
        
        settings = {
            'broker': self.broker_entry.get(),
            'port': self.port_entry.get(),
            'username': self.user_entry.get(),
            'password': self.pass_entry.get(),
            'water_topics': self.water_topic_entry.get("1.0", "end-1c").strip(),
            'gnss_topics': self.gnss_topic_entry.get("1.0", "end-1c").strip(),
            'publish': self.pub_entry.get(),
            'warning_threshold': self.warning_threshold_var.get(),
            'critical_threshold': self.critical_threshold_var.get(),
            'gnss_time_settings': {
                'calculate_per_second': self.gnss_second_var.get(),
                'calculate_per_minute': self.gnss_minute_var.get(),
                'calculate_per_hour': self.gnss_hour_var.get(),
                'calculate_per_day': self.gnss_day_var.get(),
                'calculate_per_month': self.gnss_month_var.get()
            }
        }

        errors = self._validate_config(settings)
        if errors:
            messagebox.showerror("L·ªói C·∫•u h√¨nh", "\n".join(errors), parent=parent_window)
            return False

        try:
            # Truy·ªÅn c√†i ƒë·∫∑t GNSS m·ªõi v√†o backend
            self.backend.gnss_time_settings.update(settings['gnss_time_settings'])
            self.backend.update_and_reconnect(settings)
            if show_message:
                messagebox.showinfo("Th√†nh c√¥ng", "ƒê√£ l∆∞u v√† √°p d·ª•ng c·∫•u h√¨nh.", parent=parent_window)
            return True
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ √°p d·ª•ng c·∫•u h√¨nh: {e}", parent=parent_window)
            return False

    def update_status_label(self):
        if self.status_label.cget("text") != self.backend.status_text or self.status_label.cget("foreground") != self.backend.status_color:
            self.status_label.config(text=self.backend.status_text, foreground=self.backend.status_color)

    def toggle_pass(self): self.pass_entry.config(show="" if self.pass_entry.cget("show") else "*")
    def on_check_led_click(self):
        if not self.backend.check_leds(): messagebox.showwarning("C·∫£nh b√°o", "Ch·ªâ c√≥ th·ªÉ ki·ªÉm tra LED ·ªü ch·∫ø ƒë·ªô TH·ª¶ C√îNG (OFF).", parent=self.root)
    def clear_table_gui(self):
        if messagebox.askokcancel("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô d·ªØ li·ªáu hi·ªán t·∫°i?", parent=self.root): self.backend.clear_all_data()

    def save_to_csv(self):
        if not self.backend.sensor_data: messagebox.showinfo("Th√¥ng b√°o", "Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ l∆∞u.", parent=self.root); return
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")], title="L∆∞u file CSV", parent=self.root)
        if path:
            self.save_csv_button.config(state="disabled")
            data_copy = list(self.backend.sensor_data)
            threading.Thread(target=self._write_csv_in_background, args=(path, data_copy), daemon=True).start()

    def _write_csv_in_background(self, path, data_to_save):
        try:
            import csv
            with open(path, "w", newline="", encoding='utf-8-sig') as f:
                writer = csv.writer(f)
                writer.writerow(["T√™n", "Gi√° tr·ªã (m)", "Tr·∫°ng th√°i", "Th·ªùi gian"])
                writer.writerows(data_to_save)
            if self.root.winfo_exists():
                self.root.after(0, lambda: messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ l∆∞u d·ªØ li·ªáu v√†o {os.path.basename(path)}", parent=self.root))
        except Exception as e:
            if self.root.winfo_exists():
                self.root.after(0, lambda: messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ l∆∞u file:\n\n{e}", parent=self.root))
        finally:
            if self.root.winfo_exists():
                self.root.after(0, lambda: self.save_csv_button.config(state="normal"))

    def open_settings_window(self):
        if self.settings_window and self.settings_window.winfo_exists():
            self.settings_window.lift()
            return

        self.settings_window = Toplevel(self.root)
        self.settings_window.title("C√†i ƒë·∫∑t N√¢ng cao")
        self.settings_window.geometry("800x600")
        self.settings_window.transient(self.root)

        notebook = ttk.Notebook(self.settings_window)
        notebook.pack(pady=10, padx=10, fill="both", expand=True)

        gnss_frame = ttk.Frame(notebook, padding="10")
        notebook.add(gnss_frame, text='GNSS')
        
        # --- N√öT M·ªöI ƒê·ªÇ M·ªû B·∫¢NG PH√ÇN LO·∫†I ---
        classification_button_frame = ttk.Frame(gnss_frame)
        classification_button_frame.pack(fill="x", pady=(5, 10))
        ttk.Button(classification_button_frame, text="Ph√¢n lo·∫°i T·ªëc ƒë·ªô D·ªãch chuy·ªÉn...", command=self.open_classification_window, bootstyle="info").pack(side="left")

        # --- KHUNG M·ªöI CHO C√ÅC CHECKBOX ---
        gnss_settings_frame = ttk.LabelFrame(gnss_frame, text="C√†i ƒë·∫∑t T√≠nh to√°n V·∫≠n t·ªëc", padding="10")
        gnss_settings_frame.pack(fill="x", expand=True, pady=10)
        
        ttk.Label(gnss_settings_frame, text="T√≠nh v·∫≠n t·ªëc theo:").pack(anchor="w", pady=5)
        
        # Thi·∫øt l·∫≠p gi√° tr·ªã v√† t·∫°o c√°c Checkbox
        time_settings = self.backend.gnss_time_settings
        self.gnss_second_var.set(time_settings.get('calculate_per_second', True))
        ttk.Checkbutton(gnss_settings_frame, text="Gi√¢y", variable=self.gnss_second_var).pack(anchor="w", padx=10)
        
        self.gnss_minute_var.set(time_settings.get('calculate_per_minute', False))
        ttk.Checkbutton(gnss_settings_frame, text="Ph√∫t", variable=self.gnss_minute_var).pack(anchor="w", padx=10)

        self.gnss_hour_var.set(time_settings.get('calculate_per_hour', False))
        ttk.Checkbutton(gnss_settings_frame, text="Gi·ªù", variable=self.gnss_hour_var).pack(anchor="w", padx=10)

        self.gnss_day_var.set(time_settings.get('calculate_per_day', False))
        ttk.Checkbutton(gnss_settings_frame, text="Ng√†y", variable=self.gnss_day_var).pack(anchor="w", padx=10)
        
        self.gnss_month_var.set(time_settings.get('calculate_per_month', False))
        ttk.Checkbutton(gnss_settings_frame, text="Th√°ng", variable=self.gnss_month_var).pack(anchor="w", padx=10)

        # Tab M·ª±c n∆∞·ªõc
        water_level_frame = ttk.Frame(notebook, padding="10")
        notebook.add(water_level_frame, text='M·ª±c n∆∞·ªõc')

        def add_labeled_entry_settings(frame, label, row, textvariable):
            ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w", pady=5, padx=5)
            entry = ttk.Entry(frame, textvariable=textvariable)
            entry.grid(row=row, column=1, sticky="ew", pady=5, padx=5)
            frame.grid_columnconfigure(1, weight=1)

        add_labeled_entry_settings(water_level_frame, "Ng∆∞·ª°ng C·∫£nh B√°o (m):", 0, self.warning_threshold_var)
        add_labeled_entry_settings(water_level_frame, "Ng∆∞·ª°ng Nguy Hi·ªÉm (m):", 1, self.critical_threshold_var)

        ttk.Button(self.settings_window, text="L∆∞u & ƒê√≥ng", command=self.save_and_close_settings, bootstyle="success").pack(pady=10)

    def open_classification_window(self):
        """M·ªü m·ªôt c·ª≠a s·ªï Toplevel m·ªõi ƒë·ªÉ hi·ªÉn th·ªã v√† ch·ªânh s·ª≠a b·∫£ng ph√¢n lo·∫°i."""
        if self.classification_win and self.classification_win.winfo_exists():
            self.classification_win.lift()
            return
            
        self.classification_win = Toplevel(self.settings_window)
        self.classification_win.title("B·∫£ng Ph√¢n Lo·∫°i T·ªëc ƒê·ªô D·ªãch Chuy·ªÉn")
        self.classification_win.geometry("780x420")
        self.classification_win.transient(self.settings_window)
        self.classification_win.grab_set()

        main_frame = ttk.Frame(self.classification_win, padding=10)
        main_frame.pack(fill="both", expand=True)

        classification_frame = ttk.LabelFrame(main_frame, text="B·∫£ng ph√¢n lo·∫°i", padding="10")
        classification_frame.pack(fill="both", expand=True, pady=(0, 10))
        
        columns = ("Ph√¢n lo·∫°i", "m/nƒÉm", "m/th√°ng", "m/ng√†y", "m/gi·ªù", "m/ph√∫t", "m/gi√¢y", "mm/gi√¢y")
        self.gnss_tree = ttk.Treeview(classification_frame, columns=columns, show="headings", height=10)
        for col in columns:
            self.gnss_tree.heading(col, text=col)
            self.gnss_tree.column(col, width=90, anchor="center")
            
        tree_scrollbar = ttk.Scrollbar(classification_frame, orient="vertical", command=self.gnss_tree.yview)
        self.gnss_tree.configure(yscrollcommand=tree_scrollbar.set)
        self.gnss_tree.pack(side="left", fill="both", expand=True)
        tree_scrollbar.pack(side="right", fill="y")
        
        self.load_gnss_classification_data()
        
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill="x", pady=(10, 0))
        
        # C√°c n√∫t ƒëi·ªÅu khi·ªÉn tr·ªè ƒë·∫øn c√°c h√†m hi·ªán c√≥
        ttk.Button(control_frame, text="Ch·ªânh s·ª≠a", command=self.edit_gnss_classification).pack(side="left", padx=(0, 5))
        ttk.Button(control_frame, text="Th√™m m·ªõi", command=self.add_gnss_classification).pack(side="left", padx=5)
        ttk.Button(control_frame, text="X√≥a", command=self.delete_gnss_classification).pack(side="left", padx=5)
        ttk.Button(control_frame, text="Kh√¥i ph·ª•c m·∫∑c ƒë·ªãnh", command=self.reset_gnss_classification, bootstyle="danger").pack(side="left", padx=5)

    def save_and_close_settings(self):
        success = self.apply_and_save_config(show_message=False, parent_window=self.settings_window)
        if success:
            messagebox.showinfo("Th√†nh c√¥ng", "ƒê√£ l∆∞u t·∫•t c·∫£ c√†i ƒë·∫∑t.", parent=self.settings_window)
            self.settings_window.destroy()
            
    def load_gnss_classification_data(self):
        for item in self.gnss_tree.get_children():
            self.gnss_tree.delete(item)
        for i, classification in enumerate(self.backend.gnss_speed_classification):
            value = (
                classification.get("name", "N/A"),
                classification.get("m_nam", "-"),
                classification.get("m_thang", "-"),
                classification.get("m_ngay", "-"),
                classification.get("m_gio", "-"),
                classification.get("m_phut", "-"),
                classification.get("m_giay", "-"),
                classification.get("mm_giay", "-")
            )
            self.gnss_tree.insert("", "end", values=value, tags=(str(i),))

    def edit_gnss_classification(self):
        parent = self.classification_win if self.classification_win and self.classification_win.winfo_exists() else self.settings_window
        selected = self.gnss_tree.selection()
        if not selected:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn m·ªôt m·ª•c ƒë·ªÉ ch·ªânh s·ª≠a.", parent=parent)
            return
        item = selected[0]
        index = int(self.gnss_tree.item(item)["tags"][0])
        self.open_classification_editor(index)

    def add_gnss_classification(self):
        new_item = {
            "name": "M·ªõi", "m_nam": "", "m_thang": "", "m_ngay": "",
            "m_gio": 0, "m_phut": 0, "m_giay": 0, "mm_giay": 0
        }
        self.backend.gnss_speed_classification.append(new_item)
        self.load_gnss_classification_data()
        self.backend.save_config()

    def delete_gnss_classification(self):
        parent = self.classification_win if self.classification_win and self.classification_win.winfo_exists() else self.settings_window
        selected = self.gnss_tree.selection()
        if not selected:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn m·ªôt m·ª•c ƒë·ªÉ x√≥a.", parent=parent)
            return
        if messagebox.askyesno("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a m·ª•c n√†y?", parent=parent):
            item = selected[0]
            index = int(self.gnss_tree.item(item)["tags"][0])
            del self.backend.gnss_speed_classification[index]
            self.load_gnss_classification_data()
            self.backend.save_config()

    def reset_gnss_classification(self):
        parent = self.classification_win if self.classification_win and self.classification_win.winfo_exists() else self.settings_window
        if messagebox.askyesno("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën kh√¥i ph·ª•c b·∫£ng v·ªÅ gi√° tr·ªã m·∫∑c ƒë·ªãnh?", parent=parent):
            self.backend._reset_gnss_to_default()
            self.load_gnss_classification_data()
            self.backend.save_config()

    def open_classification_editor(self, index):
        parent = self.classification_win if self.classification_win and self.classification_win.winfo_exists() else self.settings_window
        editor_window = Toplevel(parent)
        editor_window.title("Ch·ªânh s·ª≠a ph√¢n lo·∫°i t·ªëc ƒë·ªô")
        editor_window.geometry("400x350")
        editor_window.transient(parent)
        editor_window.grab_set()
        
        classification = self.backend.gnss_speed_classification[index]
        vars_dict = {}
        fields = [
            ("T√™n ph√¢n lo·∫°i:", "name"), ("m/nƒÉm:", "m_nam"), ("m/th√°ng:", "m_thang"), 
            ("m/ng√†y:", "m_ngay"), ("m/gi·ªù:", "m_gio"), ("m/ph√∫t:", "m_phut"),
            ("m/gi√¢y:", "m_giay"), ("mm/gi√¢y:", "mm_giay")
        ]
        
        for label, key in fields:
            vars_dict[key] = tk.StringVar(value=str(classification.get(key, '')))
        
        main_frame = ttk.Frame(editor_window, padding="10")
        main_frame.pack(fill="both", expand=True)
        for i, (label, key) in enumerate(fields):
            ttk.Label(main_frame, text=label).grid(row=i, column=0, sticky="w", pady=5, padx=5)
            entry = ttk.Entry(main_frame, textvariable=vars_dict[key])
            entry.grid(row=i, column=1, sticky="ew", pady=5, padx=5)
            main_frame.grid_columnconfigure(1, weight=1)
        
        button_frame = ttk.Frame(editor_window)
        button_frame.pack(fill="x", pady=10)

        def save_changes():
            try:
                for key, var in vars_dict.items():
                    value = var.get().strip()
                    if key == "name":
                        classification[key] = value
                    else:
                        classification[key] = float(value) if value else ""
                self.load_gnss_classification_data()
                self.backend.save_config()
                editor_window.destroy()
            except ValueError:
                messagebox.showerror("L·ªói", "Gi√° tr·ªã s·ªë kh√¥ng h·ª£p l·ªá.", parent=editor_window)
        
        ttk.Button(button_frame, text="L∆∞u", command=save_changes).pack(side="left", padx=10)
        ttk.Button(button_frame, text="H·ªßy", command=editor_window.destroy).pack(side="right", padx=10)

    def show_chart_window(self):
        if self.chart_window and self.chart_window.winfo_exists():
            self.chart_window.lift()
            return

        self.chart_window = Toplevel(self.root)
        self.chart_window.title("Bi·ªÉu ƒë·ªì D·ªØ li·ªáu C·∫£m bi·∫øn")
        self.chart_window.geometry("900x650")
        self.chart_window.protocol("WM_DELETE_WINDOW", self.on_chart_close)

        # Chart-specific attributes
        self.current_start_index = 0
        self._is_updating_slider = False
        self._slider_after_id = None
        self.points_per_view = Constants.CHART_POINTS_PER_VIEW
        
        top_frame = ttk.Frame(self.chart_window, padding=(10, 5))
        top_frame.pack(side=tk.TOP, fill=tk.X)
        ttk.Label(top_frame, text="Ch·ªçn ƒë∆°n v·ªã:").pack(side=tk.LEFT, padx=(0, 5))
        self.unit_selector = ttk.Combobox(top_frame, state="readonly", values=list(self.CONVERSION_FACTORS.keys()))
        self.unit_selector.set("m")
        self.unit_selector.pack(side=tk.LEFT, padx=5)
        self.unit_selector.bind("<<ComboboxSelected>>", lambda e: self.update_plot())
        
        self.auto_follow_var = tk.BooleanVar(value=True)
        auto_follow_check = ttk.Checkbutton(top_frame, text="T·ª± ƒë·ªông theo d√µi", variable=self.auto_follow_var, command=self.on_auto_follow_toggle)
        auto_follow_check.pack(side=tk.LEFT, padx=20)
        
        chart_frame = ttk.Frame(self.chart_window, padding=(10, 5))
        chart_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.fig = Figure(figsize=(9, 4.5), dpi=100)
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=chart_frame)
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        
        slider_frame = ttk.Frame(self.chart_window, padding=10)
        slider_frame.pack(side=tk.BOTTOM, fill=tk.X)
        self.position_var = tk.DoubleVar()
        self.position_scale = ttk.Scale(slider_frame, from_=0, to=100, orient=tk.HORIZONTAL, variable=self.position_var, command=self.on_slider_change)
        self.position_scale.pack(side=tk.TOP, fill=tk.X, expand=True)
        self.info_label = ttk.Label(slider_frame, text="T·ªïng ƒëi·ªÉm: 0 | Hi·ªÉn th·ªã: 0-0", font=("Arial", 9))
        self.info_label.pack(side=tk.TOP, pady=(5, 0))
        
        self.update_plot()

    def clear_chart_data(self):
        self.current_start_index = 0
        self.auto_follow_var.set(True)
        self.update_plot()

    def update_plot(self):
        if not (self.chart_window and self.chart_window.winfo_exists()): return
        all_data = list(self.backend.plot_data_points)
        total_points = len(all_data)
        
        start, end = self._update_slider_and_indices(total_points)
        display_data_slice = all_data[start:end]
        
        self.ax.clear()
        if not display_data_slice:
            self._setup_plot_style()
            self.ax.text(0.5, 0.5, 'Ch∆∞a c√≥ d·ªØ li·ªáu', ha='center', va='center', transform=self.ax.transAxes, fontsize=16, color='gray')
            self.info_label.config(text="T·ªïng ƒëi·ªÉm: 0 | Hi·ªÉn th·ªã: 0-0")
        else:
            indices, values, times, unit, warn_thresh, crit_thresh = self._prepare_plot_data(display_data_slice, start)
            self._setup_plot_style(unit)
            self._draw_plot_elements(indices, values, warn_thresh, crit_thresh)
            self._configure_plot_axes(start, end, total_points, indices, times)
        
        self.canvas.draw()

    def _update_slider_and_indices(self, total_points):
        if total_points <= self.points_per_view:
            self.position_scale.config(state="disabled")
            self.current_start_index = 0
            pos_percent = 0
        else:
            self.position_scale.config(state="normal")
            max_start_idx = total_points - self.points_per_view
            if self.auto_follow_var.get():
                self.current_start_index = max_start_idx
            
            self.current_start_index = min(self.current_start_index, max_start_idx)
            pos_percent = (self.current_start_index / max_start_idx) * 100 if max_start_idx > 0 else 100
        
        self._is_updating_slider = True
        self.position_var.set(pos_percent)
        self._is_updating_slider = False
        
        start = self.current_start_index
        end = min(total_points, start + self.points_per_view)
        return start, end

    def _prepare_plot_data(self, data_slice, start_index):
        unit = self.unit_selector.get()
        conversion_factor = self.CONVERSION_FACTORS.get(unit, 1.0)
        indices = range(start_index, start_index + len(data_slice))
        values = [item[1] * conversion_factor for item in data_slice]
        times = [item[0] for item in data_slice]
        warning_thresh = self.backend.warning_threshold * conversion_factor
        critical_thresh = self.backend.critical_threshold * conversion_factor
        return indices, values, times, unit, warning_thresh, critical_thresh

    def _setup_plot_style(self, unit='Gi√° tr·ªã'):
        self.ax.set_title('D·ªØ li·ªáu C·∫£m bi·∫øn Theo Th·ªùi Gian', fontsize=14, fontweight='bold')
        self.ax.set_xlabel('Th·ªùi gian', fontsize=12)
        self.ax.set_ylabel(f'Gi√° tr·ªã ({unit})', fontsize=12)
        self.ax.grid(True, which='major', linestyle='--', alpha=0.6)

    def _draw_plot_elements(self, indices, values, warning_thresh, critical_thresh):
        self.ax.plot(indices, values, color='gray', linestyle='-', linewidth=1, alpha=0.5, zorder=3)
        
        safe_indices, warn_indices, crit_indices = [], [], []
        safe_values, warn_values, crit_values = [], [], []
        for i, val in zip(indices, values):
            if val >= critical_thresh: crit_indices.append(i); crit_values.append(val)
            elif val >= warning_thresh: warn_indices.append(i); warn_values.append(val)
            else: safe_indices.append(i); safe_values.append(val)
        
        self.ax.scatter(safe_indices, safe_values, color='green', s=30, label='An to√†n', zorder=5)
        self.ax.scatter(warn_indices, warn_values, color='orange', s=30, label='C·∫£nh b√°o', zorder=5)
        self.ax.scatter(crit_indices, crit_values, color='red', s=30, label='Nguy hi·ªÉm', zorder=5)
        
        unit = self.unit_selector.get()
        self.ax.axhline(y=warning_thresh, color='gold', linestyle='--', linewidth=2, label=f'Ng∆∞·ª°ng C·∫£nh b√°o ({warning_thresh:.2f} {unit})')
        self.ax.axhline(y=critical_thresh, color='darkorange', linestyle='--', linewidth=2, label=f'Ng∆∞·ª°ng Nguy hi·ªÉm ({critical_thresh:.2f} {unit})')
        
    def _configure_plot_axes(self, start, end, total_points, indices, times):
        self.ax.set_xlim(left=start - 0.5, right=start + self.points_per_view - 1.5)
        num_ticks = min(len(indices), 8)
        if num_ticks > 1:
            tick_indices_in_slice = np.linspace(0, len(indices) - 1, num_ticks, dtype=int)
            self.ax.set_xticks([indices[i] for i in tick_indices_in_slice])
            self.ax.set_xticklabels([times[i].strftime('%H:%M:%S') for i in tick_indices_in_slice], rotation=25, ha='right')
        elif len(indices) == 1:
            self.ax.set_xticks(indices); self.ax.set_xticklabels([t.strftime('%H:%M:%S') for t in times])
        
        handles, labels = self.ax.get_legend_handles_labels()
        by_label = dict(zip(labels, handles))
        self.ax.legend(by_label.values(), by_label.keys(), loc='upper left')
        self.info_label.config(text=f"T·ªïng ƒëi·ªÉm: {total_points} | Hi·ªÉn th·ªã: {start+1}-{end}")
        self.fig.tight_layout()

    def on_auto_follow_toggle(self):
        if self.auto_follow_var.get():
            self.update_plot()

    def on_slider_change(self, value_str):
        if self._is_updating_slider: return
        if self._slider_after_id:
            self.root.after_cancel(self._slider_after_id)
        self._slider_after_id = self.root.after(100, lambda: self._perform_slider_update(float(value_str)))

    def _perform_slider_update(self, value):
        self._slider_after_id = None
        self.auto_follow_var.set(False)
        total_points = len(self.backend.plot_data_points)
        if total_points <= self.points_per_view: return
        
        max_start_index = total_points - self.points_per_view
        self.current_start_index = int((value / 100) * max_start_index)
        self.update_plot()

    def on_chart_close(self):
        if self._slider_after_id: self.root.after_cancel(self._slider_after_id)
        plt.close(self.fig)
        self.chart_window.destroy()
        self.chart_window = None

# ==============================================================================
# KH·ªêI ƒêI·ªÄU KHI·ªÇN CH√çNH (MAIN CONTROLLER)
# ==============================================================================
class MainController:
    def __init__(self, backend, command_queue):
        self.backend = backend
        self.command_queue = command_queue
        self.app_instance = None
        self.root = ttk.Window()
        self.root.withdraw()

    def run(self):
        self.check_for_commands()
        self.root.mainloop()

    def check_for_commands(self):
        try:
            command = self.command_queue.get_nowait()
            if command == 'show': self.create_gui_window()
            elif command == 'exit': self.handle_shutdown()
            elif command == 'restart': self.handle_restart()
        except queue.Empty: pass
        finally:
            if not self.backend.exiting and self.root.winfo_exists():
                self.root.after(100, self.check_for_commands)

    def create_gui_window(self):
        if self.app_instance and self.app_instance.root.winfo_exists():
            logger.info("Giao di·ªán ƒë√£ ƒëang ch·∫°y.")
            self.app_instance.root.lift()
            return
        logger.info("ƒêang kh·ªüi ƒë·ªông giao di·ªán ng∆∞·ªùi d√πng...")
        toplevel_window = tk.Toplevel(self.root)
        self.app_instance = AppGUI(toplevel_window, self.backend, self.on_gui_close)

    def on_gui_close(self, shutdown=False):
        self.app_instance = None
        if shutdown:
            self.command_queue.put('exit')

    def handle_shutdown(self):
        logger.info("Nh·∫≠n l·ªánh tho√°t...")
        if self.app_instance: self.app_instance.destroy_all_windows()
        self.backend.exiting = True
        if self.root.winfo_exists(): self.root.destroy()

    def handle_restart(self):
        logger.info("Nh·∫≠n l·ªánh kh·ªüi ƒë·ªông l·∫°i...")
        global needs_restart; needs_restart = True
        self.handle_shutdown()

# ==============================================================================
# KH·ªêI TH·ª∞C THI CH√çNH (MAIN)
# ==============================================================================
needs_restart = False
command_queue = queue.Queue()

def console_input_listener(cmd_queue: queue.Queue):
    while True:
        try:
            command = input().strip().lower()
            if command: cmd_queue.put(command)
            if command in ['exit', 'restart']: break
        except (EOFError, KeyboardInterrupt):
            cmd_queue.put('exit'); break

def signal_handler(signum, frame):
    logger.info("\nNh·∫≠n t√≠n hi·ªáu ng·∫Øt (Ctrl+C), ƒëang tho√°t...")
    while not command_queue.empty():
        try: command_queue.get_nowait()
        except queue.Empty: pass
    command_queue.put('exit')

if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal_handler)
    
    backend_instance = Backend()
    backend_instance.start_background_tasks()
    
    console_thread = threading.Thread(target=console_input_listener, args=(command_queue,), daemon=True)
    console_thread.start()
    
    logger.info("="*50)
    logger.info("Ch∆∞∆°ng tr√¨nh ƒë√£ s·∫µn s√†ng.")
    logger.info("G√µ 'show' ƒë·ªÉ m·ªü giao di·ªán, 'exit' ƒë·ªÉ tho√°t, 'restart' ƒë·ªÉ kh·ªüi ƒë·ªông l·∫°i.")
    logger.info("="*50)
    
    main_controller = MainController(backend_instance, command_queue)
    command_queue.put('show')
    main_controller.run()
    
    if needs_restart:
        logger.info("\n" + "="*50)
        logger.info("KH·ªûI ƒê·ªòNG L·∫†I CH∆Ø∆†NG TR√åNH...")
        logger.info("="*50 + "\n")
        try:
            os.execv(sys.executable, ['python'] + sys.argv)
        except Exception as e:
            logger.critical(f"L·ªñI KH√îNG TH·ªÇ KH·ªûI ƒê·ªòNG L·∫†I: {e}")
    else:
        logger.info("Ch∆∞∆°ng tr√¨nh ƒë√£ k·∫øt th√∫c.")
