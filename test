import tkinter as tk
from tkinter import messagebox, filedialog, Toplevel
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tksheet import Sheet
import paho.mqtt.client as mqtt
import json
from datetime import datetime
import threading
import time
import warnings
import configparser
import signal
import os
import sys
import queue
from collections import deque
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt
import numpy as np
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1"
import pygame
import RPi.GPIO as GPIO

# --- CÁC HẰNG SỐ TOÀN CỤC ---
warnings.filterwarnings("ignore", category=DeprecationWarning)
CONFIG_FILE = 'config.ini'
SESSION_FILE = "session.json"
DATA_CLEAR_SIGNAL = "CLEAR_ALL_DATA"
LED1_PIN = 3
LED2_PIN = 27
MAX_PLOT_POINTS = 10000
SOUNDS_DIR = "/home/vippro123/Desktop/code/sounds"

# --- DỮ LIỆU BẢNG CRUDEN (1996) MẶC ĐỊNH ---
# Giá trị được lưu trữ dưới dạng đơn vị cơ sở: m/giây
DEFAULT_VELOCITY_THRESHOLDS = {
    'nguy_cap': 5.0,
    'rat_nhanh': 0.05,
    'nhanh': 0.0005,
    'trung_binh': 0.000005,
    'cham': 5e-09,
    'rat_cham': 5.5e-10,
}

# Các mức phân loại và tên hiển thị
VELOCITY_CLASSIFICATION = [
    ("nguy_cap", "Nguy cấp"),
    ("rat_nhanh", "Rất nhanh"),
    ("nhanh", "Nhanh"),
    ("trung_binh", "Trung bình"),
    ("cham", "Chậm"),
    ("rat_cham", "Rất chậm")
]

# ==============================================================================
# LỚP LOGIC NỀN (BACKEND) - Logic cảnh báo đa cấp
# ==============================================================================
class Backend:
    def __init__(self):
        self.listening = False
        self.exiting = False
        self.status_text = "Trạng thái: THỦ CÔNG"
        self.status_color = "red"
        self.config = configparser.ConfigParser()
        self.broker, self.port, self.username, self.password = "aitogy.xyz", 1883, "abc", "xyz"
        self.publish_topic = ""
        self.subscribe_topics = []

        # Ngưỡng cho Mực nước
        self.water_level_warning_threshold = 1.0
        self.water_level_critical_threshold = 1.2

        # Ngưỡng cho GNSS (tốc độ) - sẽ được tải từ config
        self.velocity_thresholds = {}
        self.velocity_display_options = {}
        self.last_gnss_reading = {'timestamp': None, 'value': None}


        self.led1_pin, self.led2_pin = LED1_PIN, LED2_PIN
        self.warning_sound = None
        self.critical_sound = None
        self.siren_sound = None
        self.decreasing_sound = None
        self.safe_sound_1 = None
        self.safe_sound_2 = None
        self.alert_thread = None
        self.mixer_initialized = False
        self.current_alert_level = 0
        self.safe_readings_count = 0
        self.warning_readings_count = 0
        self.decreasing_warning_count = 0
        self.was_in_high_level_state = False
        self.initial_safe_played = False
        self.safe_return_phase = 0
        self.sensor_data = []
        self.plot_data_points = deque(maxlen=MAX_PLOT_POINTS)
        self.gui_update_queue = queue.Queue()
        self.client = mqtt.Client(protocol=mqtt.MQTTv311)
        self.client.on_connect = self.on_connect
        self.client.on_disconnect = self.on_disconnect
        self.client.on_message = self.on_message
        self.stop_event = threading.Event()
        self.setup_audio_mixer()
        self.setup_gpio()
        self.load_config()

    def setup_audio_mixer(self):
        try:
            pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=4096)
            self.mixer_initialized = True
        except Exception as e:
            print(f"LỖI: Không thể khởi tạo pygame mixer: {e}")
            self.mixer_initialized = False

    def _load_audio_files(self):
        if not self.mixer_initialized: return
        # ... (Phần code này không thay đổi)
        if not self.mixer_initialized: return
        SIREN_FILE = os.path.join(SOUNDS_DIR, "coi1.mp3")
        WARNING_FILE = os.path.join(SOUNDS_DIR, "warning.mp3")
        DANGER_FILE = os.path.join(SOUNDS_DIR, "danger.mp3")
        DECREASE_FILE = os.path.join(SOUNDS_DIR, "decrease.mp3")
        SAFE_FILE_1 = os.path.join(SOUNDS_DIR, "safe.mp3")
        SAFE_FILE_2 = os.path.join(SOUNDS_DIR, "safe2.mp3")
        try:
            if os.path.exists(SIREN_FILE): self.siren_sound = pygame.mixer.Sound(SIREN_FILE)
            else: print(f"CẢNH BÁO: Không tìm thấy file {SIREN_FILE}")
            if os.path.exists(WARNING_FILE): self.warning_sound = pygame.mixer.Sound(WARNING_FILE)
            else: print(f"CẢNH BÁO: Không tìm thấy file {WARNING_FILE}")
            if os.path.exists(DANGER_FILE): self.critical_sound = pygame.mixer.Sound(DANGER_FILE)
            else: print(f"CẢNH BÁO: Không tìm thấy file {DANGER_FILE}")
            if os.path.exists(DECREASE_FILE): self.decreasing_sound = pygame.mixer.Sound(DECREASE_FILE)
            else: print(f"CẢNH BÁO: Không tìm thấy file {DECREASE_FILE}")
            if os.path.exists(SAFE_FILE_1): self.safe_sound_1 = pygame.mixer.Sound(SAFE_FILE_1)
            else: print(f"CẢNH BÁO: Không tìm thấy file {SAFE_FILE_1}")
            if os.path.exists(SAFE_FILE_2): self.safe_sound_2 = pygame.mixer.Sound(SAFE_FILE_2)
            else: print(f"CẢNH BÁO: Không tìm thấy file {SAFE_FILE_2}")
        except Exception as e:
            print(f"LỖI khi tải file âm thanh: {e}")


    def on_message(self, client, userdata, msg):
        if not self.listening or self.exiting: return
        try:
            data = json.loads(msg.payload.decode())
            name = data.get("sensorname", msg.topic.split('/')[-1])
            value = float(data.get("value"))
            ts = float(data.get("timestamp", time.time()))

            new_level = 0
            status_text = "AN TOAN"

            # Phân luồng logic: GNSS dùng tốc độ, các loại khác dùng ngưỡng tĩnh
            if "gnss" in name.lower():
                # --- LOGIC CẢNH BÁO DỰA TRÊN TỐC ĐỘ CHO GNSS ---
                if self.last_gnss_reading['timestamp'] is None:
                    # Đây là điểm dữ liệu đầu tiên, chỉ lưu lại và thoát
                    self.last_gnss_reading = {'timestamp': ts, 'value': value}
                    return

                delta_time = ts - self.last_gnss_reading['timestamp']
                if delta_time <= 0: # Tránh chia cho 0 hoặc du hành thời gian
                    return

                delta_value = value - self.last_gnss_reading['value']
                velocity_mps = abs(delta_value / delta_time) # Tốc độ m/s

                # So sánh với ngưỡng tốc độ từ cao đến thấp
                for key, classification_name in VELOCITY_CLASSIFICATION:
                    if velocity_mps >= self.velocity_thresholds.get(key, 999):
                        status_text = classification_name.upper()
                        if key in ['nguy_cap', 'rat_nhanh', 'nhanh']:
                            new_level = 2 if key == 'nguy_cap' else 1
                        break
                
                self.last_gnss_reading = {'timestamp': ts, 'value': value}

            else:
                # --- LOGIC CẢNH BÁO TĨNH CHO CÁC CẢM BIẾN KHÁC (Vd: Mực nước) ---
                if value >= self.water_level_critical_threshold:
                    new_level = 2
                    status_text = "NGUY HIEM"
                elif value >= self.water_level_warning_threshold:
                    new_level = 1
                    status_text = "CANH BAO"
                else:
                    new_level = 0
                    status_text = "AN TOAN"

            # --- PHẦN XỬ LÝ ÂM THANH VÀ TRẠNG THÁI CHUNG ---
            # (Phần này giữ nguyên logic phức tạp về âm thanh của bạn)
            previous_level = self.current_alert_level
            # ... (Toàn bộ logic if/elif/else cho new_level, safe_readings_count, was_in_high_level_state... của bạn được đặt ở đây)
            # Ví dụ một logic đơn giản hóa để thay thế:
            if new_level != previous_level:
                 print(f"Chuyển trạng thái từ {previous_level} -> {new_level}")
                 if new_level == 2:
                     self._play_sequence_in_thread([self.siren_sound, self.critical_sound])
                 elif new_level == 1:
                     self._play_sequence_in_thread([self.siren_sound, self.warning_sound])

            self.current_alert_level = new_level
            dt_object = datetime.fromtimestamp(ts)
            record = (name, str(value), status_text, dt_object.strftime("%H:%M:%S %d-%m"))
            
            self.sensor_data.append(record)
            self.plot_data_points.append((dt_object, value))
            self.gui_update_queue.put(record)
            
            # Flash LED
            threading.Thread(target=self.flash_led, args=(self.led1_pin,), daemon=True).start()
            if new_level > 0:
                threading.Thread(target=self.flash_led, args=(self.led2_pin,), daemon=True).start()

            # Publish
            if self.publish_topic:
                payload_out_str = f"{name},{value},{status_text},{ts}"
                self.client.publish(self.publish_topic, payload_out_str)

        except (json.JSONDecodeError, ValueError, KeyError) as e:
            print(f"Lỗi xử lý message: {e}")


    def stop_all_alerts(self):
        # ... (Không thay đổi)
        if self.mixer_initialized:
            pygame.mixer.stop()

    def _play_sequence_in_thread(self, sound_list):
        # ... (Không thay đổi)
        self.stop_all_alerts()
        if self.alert_thread and self.alert_thread.is_alive():
            pass

        def target():
            if not self.mixer_initialized: return
            for sound in sound_list:
                if sound:
                    if threading.current_thread() != self.alert_thread:
                        return
                    print(f" -> Đang phát một âm thanh trong chuỗi...")
                    sound.play()
                    while pygame.mixer.get_busy():
                        if threading.current_thread() != self.alert_thread:
                            pygame.mixer.stop()
                            return
                        time.sleep(0.1)
                else:
                    print("CẢNH BÁO: Bỏ qua file âm thanh không tồn tại trong chuỗi.")
                time.sleep(0.2)
        self.alert_thread = threading.Thread(target=target, daemon=True)
        self.alert_thread.start()

    def update_and_reconnect(self, settings: dict):
        self.broker, self.port = settings['broker'], int(settings['port'])
        self.username, self.password = settings['username'], settings['password']
        self.publish_topic = settings['publish']
        self.subscribe_topics = [t for t in settings['topics'].splitlines() if t]
        
        # Cập nhật ngưỡng Mực nước
        self.water_level_warning_threshold = float(settings['water_level_warning_threshold'])
        self.water_level_critical_threshold = float(settings['water_level_critical_threshold'])
        
        # Cập nhật ngưỡng Tốc độ GNSS
        self.velocity_thresholds = settings['velocity_thresholds']
        self.velocity_display_options = settings['velocity_display_options']

        self.save_config()
        if self.listening:
            self.toggle_off()
            time.sleep(1)
            self.toggle_on()

    def load_config(self):
        if not os.path.exists(CONFIG_FILE):
            # Nếu không có file config, sử dụng giá trị mặc định
            self.velocity_thresholds = DEFAULT_VELOCITY_THRESHOLDS.copy()
            self.velocity_display_options = {
                'm/năm': True, 'm/tháng': True, 'm/ngày': True, 'm/giờ': True,
                'm/phút': True, 'm/giây': True, 'mm/giây': True
            }
            self._load_audio_files()
            return
            
        try:
            self.config.read(CONFIG_FILE)
            # MQTT
            if "MQTT" in self.config:
                mqtt_cfg = self.config["MQTT"]
                self.broker = mqtt_cfg.get("broker", self.broker)
                self.port = mqtt_cfg.getint("port", self.port)
                self.username = mqtt_cfg.get("username", self.username)
                self.password = mqtt_cfg.get("password", self.password)
                self.subscribe_topics = [t for t in mqtt_cfg.get("topics", "").splitlines() if t]
                self.publish_topic = mqtt_cfg.get("publish", self.publish_topic)
            
            # Mực nước
            if "WaterLevelSettings" in self.config:
                wl_cfg = self.config["WaterLevelSettings"]
                self.water_level_warning_threshold = wl_cfg.getfloat("warning_threshold", self.water_level_warning_threshold)
                self.water_level_critical_threshold = wl_cfg.getfloat("critical_threshold", self.water_level_critical_threshold)

            # GNSS Velocity Thresholds
            if "GNSS_Velocity" in self.config:
                gnss_cfg = self.config["GNSS_Velocity"]
                for key, _ in VELOCITY_CLASSIFICATION:
                    default_val = DEFAULT_VELOCITY_THRESHOLDS.get(key)
                    self.velocity_thresholds[key] = gnss_cfg.getfloat(key, default_val)
            else: # Fallback to defaults if section is missing
                 self.velocity_thresholds = DEFAULT_VELOCITY_THRESHOLDS.copy()

            # GNSS Display Options
            if "GNSS_Display" in self.config:
                disp_cfg = self.config["GNSS_Display"]
                self.velocity_display_options['m/năm'] = disp_cfg.getboolean('show_year', True)
                self.velocity_display_options['m/tháng'] = disp_cfg.getboolean('show_month', True)
                self.velocity_display_options['m/ngày'] = disp_cfg.getboolean('show_day', True)
                self.velocity_display_options['m/giờ'] = disp_cfg.getboolean('show_hour', True)
                self.velocity_display_options['m/phút'] = disp_cfg.getboolean('show_minute', True)
                self.velocity_display_options['m/giây'] = disp_cfg.getboolean('show_second', True)
                self.velocity_display_options['mm/giây'] = disp_cfg.getboolean('show_mm_second', True)
            else: # Fallback
                self.velocity_display_options = {k: True for k in ['m/năm', 'm/tháng', 'm/ngày', 'm/giờ', 'm/phút', 'm/giây', 'mm/giây']}


            print("Đã tải cấu hình.")
            self._load_audio_files()
        except Exception as e:
            print(f"Lỗi khi tải cấu hình từ {CONFIG_FILE}: {e}")

    def save_config(self):
        self.config['MQTT'] = {
            'broker': self.broker, 'port': self.port, 'username': self.username,
            'password': self.password, 'topics': "\n".join(self.subscribe_topics),
            'publish': self.publish_topic
        }
        self.config['WaterLevelSettings'] = {
            'warning_threshold': self.water_level_warning_threshold,
            'critical_threshold': self.water_level_critical_threshold
        }
        # Lưu các ngưỡng tốc độ (đơn vị m/s)
        self.config['GNSS_Velocity'] = {key: str(val) for key, val in self.velocity_thresholds.items()}
        
        # Lưu các tùy chọn hiển thị
        self.config['GNSS_Display'] = {
            'show_year': str(self.velocity_display_options.get('m/năm', True)),
            'show_month': str(self.velocity_display_options.get('m/tháng', True)),
            'show_day': str(self.velocity_display_options.get('m/ngày', True)),
            'show_hour': str(self.velocity_display_options.get('m/giờ', True)),
            'show_minute': str(self.velocity_display_options.get('m/phút', True)),
            'show_second': str(self.velocity_display_options.get('m/giây', True)),
            'show_mm_second': str(self.velocity_display_options.get('mm/giây', True)),
        }

        try:
            with open(CONFIG_FILE, 'w') as f: self.config.write(f)
            print("Đã lưu cấu hình.")
        except IOError as e:
            print(f"Lỗi Lưu File: {e}")

    # ... (Các hàm còn lại của Backend như shutdown, setup_gpio, flash_led, on_connect,... giữ nguyên)
    def shutdown(self, silent=False):
        if self.exiting: return
        if not silent: print("\nBắt đầu quá trình dọn dẹp để thoát...")
        self.exiting = True
        self.stop_event.set()
        self.stop_all_alerts()
        self.alert_thread = None
        try:
            self.client.loop_stop(force=True)
            self.client.disconnect()
        except Exception: pass
        GPIO.cleanup()
        if not silent: print(" -> Backend đã dừng.")

    def setup_gpio(self):
        try:
            GPIO.setmode(GPIO.BCM)
            GPIO.setwarnings(False)
            GPIO.setup(self.led1_pin, GPIO.OUT, initial=GPIO.LOW)
            GPIO.setup(self.led2_pin, GPIO.OUT, initial=GPIO.LOW)
            print("GPIO setup successful.")
        except Exception as e:
            print(f"Lỗi khi cài đặt GPIO: {e}")

    def start_background_tasks(self):
        self.load_session_data()
        threading.Thread(target=self.auto_clear_scheduler, daemon=True).start()
        print("Đã khởi chạy các tác vụ nền.")

    def flash_led(self, pin, duration=0.3):
        try:
            GPIO.output(pin, GPIO.HIGH)
            time.sleep(duration)
            GPIO.output(pin, GPIO.LOW)
        except Exception as e:
            print(f"Lỗi nháy LED trên pin {pin}: {e}")

    def on_connect(self, client, userdata, flags, rc):
        if self.exiting: return
        if rc == 0:
            print("MQTT Connected successfully.")
            self.status_text, self.status_color = "Trạng thái: TỰ ĐỘNG", "green"
            for t in self.subscribe_topics:
                client.subscribe(t)
                print(f"Subscribed: {t}")
            if not self.subscribe_topics:
                self.status_text = "Trạng thái: TỰ ĐỘNG (Không có topic)"
        else:
            print(f"Failed to connect, return code {rc}")
            self.status_text, self.status_color = "Trạng thái: LỖI KẾT NỐI", "red"
            self.listening = False

    def on_disconnect(self, client, userdata, rc):
        if not self.exiting and self.listening:
            print("Mất kết nối MQTT...")
            self.status_text, self.status_color = "Trạng thái: MẤT KẾT NỐI", "orange"

    def get_gui_updates(self):
        updates = []
        while not self.gui_update_queue.empty():
            try:
                updates.append(self.gui_update_queue.get_nowait())
            except queue.Empty:
                break
        return updates

    def toggle_on(self):
        if self.listening: return
        self.listening = True
        self.status_text, self.status_color = "Trạng thái: ĐANG KẾT NỐI...", "orange"
        if not self.broker:
            self.listening = False
            self.status_text, self.status_color = "Trạng thái: THỦ CÔNG (Lỗi Broker)", "red"
            return

        self.client.username_pw_set(self.username, self.password)
        try:
            print(f"Đang kết nối tới MQTT broker: {self.broker}:{self.port}...")
            self.client.connect_async(self.broker, self.port, 60)
            self.client.loop_start()
        except Exception as e:
            self.listening = False
            self.status_text, self.status_color = "Trạng thái: LỖI KẾT NỐI", "red"
            print(f"Lỗi kết nối MQTT: {e}")

    def toggle_off(self):
        if not self.listening: return
        self.listening = False
        try:
            self.client.loop_stop()
            self.client.disconnect()
            print("Đã ngắt kết nối MQTT.")
        except Exception: pass
        self.status_text, self.status_color = "Trạng thái: THỦ CÔNG", "red"

    def check_leds(self):
        if self.listening:
            print("Không thể kiểm tra LED ở chế độ TỰ ĐỘNG.")
            return False
        threading.Thread(target=self._run_led_check, daemon=True).start()
        return True

    def _run_led_check(self):
        print("Kiểm tra LED...")
        self.flash_led(self.led1_pin, duration=0.5)
        time.sleep(0.1)
        self.flash_led(self.led2_pin, duration=0.5)

    def auto_clear_scheduler(self):
        while not self.stop_event.is_set():
            now = datetime.now()
            if now.hour == 0 and now.minute == 0:
                print("Đã đến 00:00, tự động xóa dữ liệu...")
                self.clear_all_data()
                time.sleep(61)
            else:
                time.sleep(30)

    def clear_all_data(self):
        self.sensor_data.clear()
        self.plot_data_points.clear()
        self.gui_update_queue.put(DATA_CLEAR_SIGNAL)
        self.last_gnss_reading = {'timestamp': None, 'value': None} # Reset cả điểm GNSS cuối
        print("Đã xóa dữ liệu nền.")

    def save_session_data(self, silent=False):
        # ... (Không thay đổi)
        if not silent: print(" -> Đang lưu trạng thái hiện tại vào file...")
        try:
            plot_data_serializable = [(dt.isoformat(), val) for dt, val in self.plot_data_points]
            session = {"sensor_data": self.sensor_data, "plot_data_points": plot_data_serializable}
            with open(SESSION_FILE, "w") as f: json.dump(session, f)
            if not silent: print(f" -> Đã lưu trạng thái vào {SESSION_FILE}")
        except Exception as e:
            print(f" -> Lỗi khi lưu trạng thái: {e}")

    def load_session_data(self):
        # ... (Không thay đổi)
        if not os.path.exists(SESSION_FILE): return
        print(f" -> Tìm thấy file trạng thái {SESSION_FILE}, đang tải lại dữ liệu...")
        try:
            with open(SESSION_FILE, "r") as f: session = json.load(f)
            self.sensor_data = session.get("sensor_data", [])
            plot_data_serializable = session.get("plot_data_points", [])
            self.plot_data_points.clear()
            for dt_str, val in plot_data_serializable:
                self.plot_data_points.append((datetime.fromisoformat(dt_str), val))
            for record in self.sensor_data: self.gui_update_queue.put(record)
            print(" -> Đã tải lại dữ liệu thành công.")
        except Exception as e:
            print(f" -> Lỗi khi tải trạng thái: {e}")
        finally:
            if os.path.exists(SESSION_FILE): os.remove(SESSION_FILE)


# ==============================================================================
# LỚP GIAO DIỆN NGƯỜI DÙNG (GUI)
# ==============================================================================
class AppGUI:
    def __init__(self, root: tk.Toplevel, backend: Backend, on_close_callback):
        self.root = root
        self.backend = backend
        self.on_close_callback = on_close_callback
        self.root.title("Giao diện Cảm biến & Điều khiển LED")
        self.root.geometry(f"{self.root.winfo_screenwidth()}x{self.root.winfo_screenheight()-70}+0+0")
        self.chart_window = None
        self.settings_window = None
        
        # Biến cho tab Mực nước
        self.water_level_warning_var = tk.StringVar()
        self.water_level_critical_var = tk.StringVar()

        # Các hằng số chuyển đổi tốc độ (BASE UNIT: m/s)
        self._VELOCITY_CONVERSION_FACTORS = {
            "m/giây": 1,
            "mm/giây": 1000,
            "m/phút": 60,
            "m/giờ": 3600,
            "m/ngày": 86400,
            "m/tháng": 2628000,  # Trung bình 30.42 ngày
            "m/năm": 31536000, # Trung bình 365 ngày
        }
        self._is_updating_gnss_sheet = False

        self.CONVERSION_FACTORS = {"m": 1.0, "cm": 100.0, "mm": 1000.0, "ft": 3.28084}
        self.points_per_view = 40
        self.current_start_index = 0
        self.last_highlighted_row = None
        self._is_updating_slider = False
        self._slider_after_id = None
        self.create_widgets()
        self.load_initial_data()
        self.root.after(250, self.periodic_update)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close_window)

    def create_left_panel(self, parent):
        # ... (Không thay đổi)
        left = ttk.LabelFrame(parent, text="Cài đặt MQTT", padding=10)
        left.grid(row=0, column=0, sticky="nsw", padx=(0, 15))
        left.grid_rowconfigure(6, weight=1) # Cho phép text box mở rộng

        def add_labeled_entry(frame, label, row, show=None):
            ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w", pady=3)
            entry = ttk.Entry(frame, show=show)
            entry.grid(row=row, column=1, sticky="ew", pady=3, columnspan=2)
            return entry

        self.broker_entry = add_labeled_entry(left, "MQTT Broker:", 0)
        self.port_entry = add_labeled_entry(left, "Port:", 1)
        self.user_entry = add_labeled_entry(left, "Username:", 2)
        self.pass_entry = add_labeled_entry(left, "Password:", 3, show="*")
        show_btn = ttk.Button(left, text="👁", command=self.toggle_pass, width=2, bootstyle="light")
        show_btn.grid(row=3, column=2, sticky="e")
        self.pub_entry = add_labeled_entry(left, "Publish Topic:", 4)

        ttk.Label(left, text="Subscribe Topics:").grid(row=5, column=0, columnspan=3, sticky="w", pady=(10, 2))
        self.topic_input = tk.Text(left, height=8, width=35, relief="solid", borderwidth=1)
        self.topic_input.grid(row=6, column=0, columnspan=3, pady=(0, 5), sticky="nsew")

        ttk.Button(left, text="Cài đặt Nâng cao", command=self.open_settings_window, bootstyle="secondary").grid(row=7, column=0, columnspan=3, sticky="ew", pady=(10, 5))

        ttk.Button(left, text="Lưu & Áp dụng", command=self.apply_and_save_config, bootstyle="primary").grid(row=8, column=0, columnspan=3, sticky="ew", pady=(5,0))


    def open_settings_window(self):
        if self.settings_window and self.settings_window.winfo_exists():
            self.settings_window.lift()
            return

        self.settings_window = Toplevel(self.root)
        self.settings_window.title("Cài đặt Nâng cao")
        self.settings_window.geometry("800x600")
        self.settings_window.transient(self.root)

        notebook = ttk.Notebook(self.settings_window)
        notebook.pack(pady=10, padx=10, fill="both", expand=True)

        # Tab 1: GNSS - Đã được thiết kế lại hoàn toàn
        gnss_frame = ttk.Frame(notebook, padding="10")
        notebook.add(gnss_frame, text='Phân loại Tốc độ (GNSS)')
        self._setup_gnss_tab(gnss_frame)

        # Tab 2: Mực nước
        water_level_frame = ttk.Frame(notebook, padding="10")
        notebook.add(water_level_frame, text='Mực nước')
        self._setup_water_level_tab(water_level_frame)
        
        # Load dữ liệu vào các tab
        self.load_settings_to_gui()
        
        # Nút để đóng cửa sổ cài đặt
        ttk.Button(self.settings_window, text="Đóng", command=self.settings_window.destroy).pack(pady=10)

    def _setup_water_level_tab(self, parent_frame):
        def add_labeled_entry_settings(frame, label, row, textvariable):
            ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w", pady=5, padx=5)
            entry = ttk.Entry(frame, textvariable=textvariable)
            entry.grid(row=row, column=1, sticky="ew", pady=5, padx=5)
            frame.grid_columnconfigure(1, weight=1)

        add_labeled_entry_settings(parent_frame, "Ngưỡng Cảnh Báo (m):", 0, self.water_level_warning_var)
        add_labeled_entry_settings(parent_frame, "Ngưỡng Nguy Hiểm (m):", 1, self.water_level_critical_var)


    def _setup_gnss_tab(self, parent_frame):
        # Khu vực tùy chọn hiển thị cột
        display_options_frame = ttk.LabelFrame(parent_frame, text="Tùy chọn Hiển thị Cột", padding=10)
        display_options_frame.pack(fill="x", pady=(0, 10))

        self.gnss_display_vars = {}
        column_map = {
            'm/năm': 'm/năm', 'm/tháng': 'm/tháng', 'm/ngày': 'm/ngày', 'm/giờ': 'm/giờ',
            'm/phút': 'm/phút', 'm/giây': 'm/giây', 'mm/giây': 'mm/giây'
        }
        for i, (text, key) in enumerate(column_map.items()):
            var = tk.BooleanVar()
            cb = ttk.Checkbutton(display_options_frame, text=text, variable=var, command=self._update_gnss_table_visibility)
            cb.grid(row=0, column=i, padx=5, sticky="w")
            self.gnss_display_vars[key] = var

        # Khu vực bảng
        table_frame = ttk.LabelFrame(parent_frame, text="Bảng Phân loại Tốc độ Dịch chuyển [Cruden, 1996]", padding=10)
        table_frame.pack(fill="both", expand=True)

        self.gnss_sheet = Sheet(table_frame, show_row_index=False, headers=["Phân loại"])
        self.gnss_sheet.enable_bindings("single_select", "edit_cell")
        self.gnss_sheet.pack(fill="both", expand=True)
        self.gnss_sheet.extra_bindings([("cell_edit", self._on_gnss_sheet_edit)])
    
    def _update_gnss_table_visibility(self):
        if not hasattr(self, 'gnss_sheet'): return

        self._is_updating_gnss_sheet = True # Ngăn trigger sự kiện edit
        
        # Lấy dữ liệu hiện tại từ bảng
        current_data = self.gnss_sheet.get_sheet_data()
        current_headers = self.gnss_sheet.headers()

        # Tạo map từ header đến index để lấy đúng dữ liệu
        header_map = {h: i for i, h in enumerate(current_headers)}
        
        # Xác định header mới
        new_headers = ["Phân loại"]
        for header, var in self.gnss_display_vars.items():
            if var.get():
                new_headers.append(header)
        
        # Tạo dữ liệu mới dựa trên header mới
        new_data = []
        for row_idx, (key, name) in enumerate(VELOCITY_CLASSIFICATION):
            new_row = [name]
            # Lấy giá trị cơ sở (m/s) từ backend
            base_value_mps = self.backend.velocity_thresholds.get(key, 0)
            
            for header in new_headers:
                if header == "Phân loại":
                    continue
                # Tính toán lại giá trị cho từng cột hiển thị
                factor = self._VELOCITY_CONVERSION_FACTORS.get(header, 1)
                new_val = base_value_mps * factor
                
                # Định dạng số khoa học cho giá trị rất nhỏ
                if 0 < new_val < 1e-4:
                     new_row.append(f"{new_val:.2E}")
                else:
                     new_row.append(f"{new_val:.6f}".rstrip('0').rstrip('.'))

            new_data.append(new_row)

        self.gnss_sheet.set_sheet_data(data=new_data, headers=new_headers)
        self.gnss_sheet.set_all_column_widths()
        self.gnss_sheet.column_width(0, 100)
        self.gnss_sheet.readonly_columns([0]) # Cột "Phân loại" không thể sửa

        self._is_updating_gnss_sheet = False

    def _on_gnss_sheet_edit(self, event):
        if self._is_updating_gnss_sheet:
            return
            
        self._is_updating_gnss_sheet = True

        row, col, _, new_value_str, *_ = event
        
        try:
            new_value = float(new_value_str)
        except (ValueError, TypeError):
            self._is_updating_gnss_sheet = False
            return # Bỏ qua nếu giá trị nhập vào không phải là số

        edited_header = self.gnss_sheet.headers()[col]
        
        # 1. Chuyển giá trị đã sửa về đơn vị cơ sở (m/s)
        conversion_factor = self._VELOCITY_CONVERSION_FACTORS.get(edited_header, 1)
        base_value_mps = new_value / conversion_factor
        
        # Cập nhật giá trị cơ sở này trong backend
        classification_key = VELOCITY_CLASSIFICATION[row][0]
        self.backend.velocity_thresholds[classification_key] = base_value_mps

        # 2. Cập nhật lại tất cả các ô trong cùng một hàng
        for c_idx, header in enumerate(self.gnss_sheet.headers()):
            if c_idx == col or c_idx == 0: # Bỏ qua cột vừa sửa và cột tên
                continue
            
            factor = self._VELOCITY_CONVERSION_FACTORS.get(header, 1)
            recalculated_value = base_value_mps * factor
            
            # Định dạng lại giá trị để hiển thị
            if 0 < recalculated_value < 1e-4:
                display_val = f"{recalculated_value:.2E}"
            else:
                display_val = f"{recalculated_value:.6f}".rstrip('0').rstrip('.')

            self.gnss_sheet.set_cell_data(row, c_idx, display_val)

        self._is_updating_gnss_sheet = False
        
    def load_initial_data(self):
        # Load dữ liệu MQTT
        self.broker_entry.insert(0, self.backend.broker)
        self.port_entry.insert(0, str(self.backend.port))
        self.user_entry.insert(0, self.backend.username)
        self.pass_entry.insert(0, self.backend.password)
        self.pub_entry.insert(0, self.backend.publish_topic)
        self.topic_input.insert("1.0", "\n".join(self.backend.subscribe_topics))
    
    def load_settings_to_gui(self):
        # Load dữ liệu ngưỡng mực nước
        self.water_level_warning_var.set(str(self.backend.water_level_warning_threshold))
        self.water_level_critical_var.set(str(self.backend.water_level_critical_threshold))
        
        # Load trạng thái các checkbox của GNSS
        for key, var in self.gnss_display_vars.items():
            is_checked = self.backend.velocity_display_options.get(key, True)
            var.set(is_checked)
        
        # Cập nhật bảng GNSS dựa trên dữ liệu đã load
        self._update_gnss_table_visibility()


    def _save_settings_from_gui(self) -> dict:
        """Lấy tất cả cài đặt từ GUI để chuẩn bị lưu."""
        settings = {}
        # Ngưỡng mực nước
        settings['water_level_warning_threshold'] = self.water_level_warning_var.get()
        settings['water_level_critical_threshold'] = self.water_level_critical_var.get()
        
        # Ngưỡng tốc độ GNSS (đã được cập nhật vào backend mỗi khi sửa)
        settings['velocity_thresholds'] = self.backend.velocity_thresholds.copy()

        # Tùy chọn hiển thị GNSS
        settings['velocity_display_options'] = {key: var.get() for key, var in self.gnss_display_vars.items()}
        
        return settings

    def apply_and_save_config(self, show_message=True):
        try:
            # Lấy cài đặt chung
            settings = {
                'broker': self.broker_entry.get(),
                'port': self.port_entry.get(),
                'username': self.user_entry.get(),
                'password': self.pass_entry.get(),
                'topics': self.topic_input.get("1.0", "end").strip(),
                'publish': self.pub_entry.get()
            }
            
            # Nếu cửa sổ cài đặt đang mở, lấy dữ liệu từ đó, nếu không dùng dữ liệu hiện có trong backend
            if self.settings_window and self.settings_window.winfo_exists():
                advanced_settings = self._save_settings_from_gui()
                settings.update(advanced_settings)
            else:
                 settings['water_level_warning_threshold'] = self.backend.water_level_warning_threshold
                 settings['water_level_critical_threshold'] = self.backend.water_level_critical_threshold
                 settings['velocity_thresholds'] = self.backend.velocity_thresholds
                 settings['velocity_display_options'] = self.backend.velocity_display_options
                 
            # Xác thực dữ liệu
            float(settings['water_level_warning_threshold'])
            float(settings['water_level_critical_threshold'])
            
            # Cập nhật backend
            self.backend.update_and_reconnect(settings)
            
            if show_message:
                messagebox.showinfo("Thành công", "Đã lưu và áp dụng cấu hình.", parent=self.root)
        except ValueError:
            messagebox.showerror("Lỗi", "Giá trị ngưỡng không hợp lệ. Vui lòng nhập số.", parent=self.root)
        except Exception as e:
            messagebox.showerror("Lỗi", f"Không thể áp dụng cấu hình: {e}", parent=self.root)

    # ... (Các hàm còn lại của AppGUI như periodic_update, on_close_window,... giữ nguyên)
    def periodic_update(self):
        if not self.root.winfo_exists(): return
        self.update_status_label()
        new_updates = self.backend.get_gui_updates()
        if new_updates:
            if DATA_CLEAR_SIGNAL in new_updates:
                self.sheet.set_sheet_data([])
                if self.chart_window and self.chart_window.winfo_exists(): self.clear_chart_data()
                print("GUI đã nhận tín hiệu và xóa bảng.")
            else:
                valid_records = [rec for rec in new_updates if isinstance(rec, tuple)]
                if valid_records:
                    self.sheet.insert_rows(valid_records)
                    self.sheet.dehighlight_all()
                    last_row_index = self.sheet.get_total_rows() - 1
                    if last_row_index >= 0:
                        self.sheet.see(row=last_row_index)
                        self.sheet.deselect()
                        last_record = valid_records[-1]
                        status = last_record[2]
                        if "NGUY" in status:
                            highlight_color = "#F8D7DA"
                        elif "CANH BAO" in status or "NHANH" in status :
                            highlight_color = "#FFF3CD"
                        else:
                            highlight_color = "#D4EDDA"
                        self.sheet.highlight_rows(rows=[last_row_index], bg=highlight_color, fg="black")
            if self.chart_window and self.chart_window.winfo_exists(): self.update_plot()
        self.root.after(250, self.periodic_update)

    def destroy_all_windows(self):
        if self.settings_window and self.settings_window.winfo_exists(): self.settings_window.destroy()
        if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.destroy()
        if self.root and self.root.winfo_exists(): self.root.destroy()

    def on_close_window(self):
        print("Đã đóng cửa sổ giao diện. Gõ 'show' trong terminal để mở lại.")
        self.on_close_callback()
        self.destroy_all_windows()

    def exit_program_graceful(self):
        if messagebox.askokcancel("Xác nhận", "Bạn có chắc muốn thoát hoàn toàn chương trình?", parent=self.root):
            print("Tự động lưu cấu hình hiện tại trước khi thoát...")
            self.apply_and_save_config(show_message=False) # Lưu lại các thay đổi cuối cùng
            self.on_close_callback(shutdown=True)

    def create_widgets(self):
        main = ttk.Frame(self.root, padding=10)
        main.pack(fill="both", expand=True)
        main.grid_columnconfigure(1, weight=1)
        main.grid_columnconfigure(0, weight=0)
        main.grid_rowconfigure(0, weight=1)
        self.create_left_panel(main)
        self.create_right_panel(main)

    def create_right_panel(self, parent):
        right = ttk.Frame(parent)
        right.grid(row=0, column=1, sticky="nsew")
        right.grid_rowconfigure(1, weight=1)
        right.grid_columnconfigure(0, weight=1)
        self.status_label = ttk.Label(right, text="", font=("Arial", 11, "bold"))
        self.status_label.grid(row=0, column=0, sticky="ew", pady=(0, 5))
        sheet_frame = ttk.Frame(right)
        sheet_frame.grid(row=1, column=0, sticky="nsew")
        self.sheet = Sheet(sheet_frame, headers=["Tên", "Giá trị", "Trạng thái", "Thời gian"], show_row_index=True)
        self.sheet.pack(fill=tk.BOTH, expand=True)
        self.sheet.disable_bindings()
        self.sheet.set_options(font=("Arial", 10, "normal"), header_font=("Arial", 10, "bold"), align="center")
        self.sheet.column_widths({0:150, 1:120, 2:150, 3:200})
        self.create_control_panel(right)

    def create_control_panel(self, parent_frame):
        bottom_part = ttk.Frame(parent_frame)
        bottom_part.grid(row=2, column=0, sticky="ew", pady=(10, 0))
        ctrl = ttk.Frame(bottom_part)
        ctrl.pack(side=tk.TOP, fill=tk.X, expand=True)
        for i in range(5): ctrl.grid_columnconfigure(i, weight=1)
        ttk.Button(ctrl, text="Tự động (ON)", command=self.backend.toggle_on, bootstyle="success").grid(row=0, column=0, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Thủ công (OFF)", command=self.backend.toggle_off, bootstyle="danger").grid(row=0, column=1, padx=2, sticky="ew")
        self.save_csv_button = ttk.Button(ctrl, text="Lưu CSV", command=self.save_to_csv, bootstyle="info")
        self.save_csv_button.grid(row=0, column=2, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Xóa Dữ Liệu", command=self.clear_table_gui, bootstyle="warning").grid(row=0, column=3, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Xem Biểu Đồ", command=self.show_chart_window, bootstyle="primary").grid(row=0, column=4, padx=2, sticky="ew")
        led_panel = ttk.LabelFrame(bottom_part, text="Kiểm tra Thiết bị", padding=5)
        led_panel.pack(side=tk.TOP, fill=tk.X, expand=True, pady=(10, 0))
        led_panel.grid_columnconfigure(0, weight=3)
        led_panel.grid_columnconfigure(1, weight=1)
        ttk.Button(led_panel, text="Kiểm tra LED", command=self.on_check_led_click).grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        ttk.Button(led_panel, text="Thoát", command=self.exit_program_graceful, bootstyle="secondary-outline").grid(row=0, column=1, padx=5, pady=5, sticky="ew")

    def update_status_label(self):
        if self.status_label.cget("text") != self.backend.status_text or self.status_label.cget("foreground") != self.backend.status_color:
            self.status_label.config(text=self.backend.status_text, foreground=self.backend.status_color)

    def toggle_pass(self): self.pass_entry.config(show="" if self.pass_entry.cget("show") else "*")

    def on_check_led_click(self):
        if not self.backend.check_leds(): messagebox.showwarning("Cảnh báo", "Chỉ có thể kiểm tra LED ở chế độ THỦ CÔNG (OFF).", parent=self.root)

    def clear_table_gui(self):
        if messagebox.askokcancel("Xác nhận", "Bạn có chắc muốn xóa toàn bộ dữ liệu hiện tại?", parent=self.root): self.backend.clear_all_data()

    def save_to_csv(self):
        if not self.backend.sensor_data: messagebox.showinfo("Thông báo", "Không có dữ liệu để lưu.", parent=self.root); return
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")], title="Lưu file CSV", parent=self.root)
        if path:
            self.save_csv_button.config(state="disabled")
            threading.Thread(target=self._write_csv_in_background, args=(path, list(self.backend.sensor_data)), daemon=True).start()

    def _write_csv_in_background(self, path, data_to_save):
        try:
            import csv
            with open(path, "w", newline="", encoding='utf-8-sig') as f:
                writer = csv.writer(f)
                writer.writerow(self.sheet.headers())
                writer.writerows(data_to_save)
            if self.root.winfo_exists():
                self.root.after(0, lambda p=path: messagebox.showinfo("Thành công", f"Đã lưu dữ liệu vào {os.path.basename(p)}", parent=self.root))
        except Exception as e:
            if self.root.winfo_exists():
                self.root.after(0, lambda err=e: messagebox.showerror("Lỗi", f"Không thể lưu file:\n\n{err}", parent=self.root))
        finally:
            if self.root.winfo_exists():
                self.root.after(0, lambda: self.save_csv_button.config(state="normal"))

    def show_chart_window(self):
        if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.lift(); return
        self.chart_window = tk.Toplevel(self.root)
        self.chart_window.title("Biểu đồ Dữ liệu Cảm biến")
        self.chart_window.geometry("900x650")
        self.chart_window.protocol("WM_DELETE_WINDOW", self.on_chart_close)
        top_frame = ttk.Frame(self.chart_window, padding=(10, 5))
        top_frame.pack(side=tk.TOP, fill=tk.X)
        ttk.Label(top_frame, text="Chọn đơn vị:").pack(side=tk.LEFT, padx=(0, 5))
        self.unit_selector = ttk.Combobox(top_frame, state="readonly", values=list(self.CONVERSION_FACTORS.keys()))
        self.unit_selector.set("m"); self.unit_selector.pack(side=tk.LEFT, padx=5)
        self.unit_selector.bind("<<ComboboxSelected>>", lambda e: self.update_plot())
        self.auto_follow_var = tk.BooleanVar(value=True)
        auto_follow_check = ttk.Checkbutton(top_frame, text="Tự động theo dõi", variable=self.auto_follow_var, command=self.on_auto_follow_toggle)
        auto_follow_check.pack(side=tk.LEFT, padx=20)
        self.current_start_index = 0
        chart_frame = ttk.Frame(self.chart_window, padding=(10, 5))
        chart_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.fig = Figure(figsize=(9, 4.5), dpi=100)
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=chart_frame)
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        slider_frame = ttk.Frame(self.chart_window, padding=10)
        slider_frame.pack(side=tk.BOTTOM, fill=tk.X)
        self.position_var = tk.DoubleVar()
        self.position_scale = ttk.Scale(slider_frame, from_=0, to=100, orient=tk.HORIZONTAL, variable=self.position_var, command=self.on_slider_change)
        self.position_scale.pack(side=tk.TOP, fill=tk.X, expand=True)
        self.info_label = ttk.Label(slider_frame, text="Tổng điểm: 0 | Hiển thị: 0-0", font=("Arial", 9))
        self.info_label.pack(side=tk.TOP, pady=(5, 0))
        self.update_plot()

    def clear_chart_data(self):
        self.current_start_index = 0
        if hasattr(self, 'auto_follow_var'):
            self.auto_follow_var.set(True)
        self.update_plot()

    def update_plot(self):
        if not (self.chart_window and self.chart_window.winfo_exists()): return
        all_data = list(self.backend.plot_data_points)
        total_points = len(all_data)
        if total_points > self.points_per_view:
            max_start = total_points - self.points_per_view
            self.current_start_index = min(self.current_start_index, max_start)
        start, end = self._update_slider_and_indices(total_points)
        display_data_slice = all_data[start:end]
        self.ax.clear()
        
        if not display_data_slice:
            self.ax.text(0.5, 0.5, 'Chưa có dữ liệu', ha='center', va='center', transform=self.ax.transAxes, fontsize=16, color='gray')
            self.info_label.config(text="Tổng điểm: 0 | Hiển thị: 0-0")
        else:
            indices, values, times, unit, warning_thresh, critical_thresh = self._prepare_plot_data(display_data_slice, start)
            self._setup_plot_style(unit)
            self._draw_plot_elements(indices, values, warning_thresh, critical_thresh, unit)
            self._configure_plot_axes(start, end, total_points, indices, times)
        self.canvas.draw()

    def _update_slider_and_indices(self, total_points):
        if total_points <= self.points_per_view:
            self.position_scale.config(state="disabled")
            self.current_start_index = 0
            self._is_updating_slider = True
            self.position_scale.set(0)
            self._is_updating_slider = False
        else:
            self.position_scale.config(state="normal")
            if self.auto_follow_var.get():
                self.current_start_index = max(0, total_points - self.points_per_view)
        if total_points > self.points_per_view:
            max_start_idx = max(0, total_points - self.points_per_view)
            pos_percent = (self.current_start_index / max_start_idx) * 100 if max_start_idx > 0 else 100
        else:
            pos_percent = 100
        self._is_updating_slider = True
        self.position_scale.set(pos_percent)
        self._is_updating_slider = False
        start = self.current_start_index
        end = min(total_points, start + self.points_per_view)
        return start, end

    def _prepare_plot_data(self, data_slice, start_index):
        unit = self.unit_selector.get()
        conversion_factor = self.CONVERSION_FACTORS.get(unit, 1.0)
        indices = range(start_index, start_index + len(data_slice))
        values = [item[1] * conversion_factor for item in data_slice]
        times = [item[0] for item in data_slice]
        # Chú ý: biểu đồ vẫn dùng ngưỡng Mực nước cũ, có thể cần điều chỉnh nếu muốn biểu đồ động
        warning_thresh = self.backend.water_level_warning_threshold * conversion_factor
        critical_thresh = self.backend.water_level_critical_threshold * conversion_factor
        return indices, values, times, unit, warning_thresh, critical_thresh

    def _setup_plot_style(self, unit='Giá trị'):
        self.ax.set_title('Dữ liệu Cảm biến Theo Thời Gian', fontsize=14, fontweight='bold')
        self.ax.set_xlabel('Thời gian', fontsize=12)
        self.ax.set_ylabel(f'Giá trị ({unit})', fontsize=12)
        self.ax.grid(True, which='major', linestyle='--', alpha=0.6)

    def _draw_plot_elements(self, indices, values, warning_thresh, critical_thresh, unit):
        # ... (phần này có thể cần sửa để phù hợp logic mới nếu muốn)
        self.ax.plot(indices, values, color='blue', linestyle='-', linewidth=1.5, marker='o', markersize=4, zorder=3)
        self.ax.axhline(y=warning_thresh, color='gold', linestyle='--', linewidth=2, alpha=0.9, label=f'Ngưỡng Cảnh báo ({warning_thresh:.2f} {unit})')
        self.ax.axhline(y=critical_thresh, color='darkorange', linestyle='--', linewidth=2, alpha=0.9, label=f'Ngưỡng Nguy hiểm ({critical_thresh:.2f} {unit})')

    def _configure_plot_axes(self, start, end, total_points, indices, times):
        self.ax.set_xlim(left=start - 0.5, right=start + self.points_per_view - 0.5)
        num_ticks = min(len(indices), 8)
        if num_ticks > 1:
            tick_indices_in_slice = np.linspace(0, len(indices) - 1, num_ticks, dtype=int)
            self.ax.set_xticks([indices[i] for i in tick_indices_in_slice])
            self.ax.set_xticklabels([times[i].strftime('%H:%M:%S') for i in tick_indices_in_slice], rotation=45, ha='right')
        elif len(indices) == 1:
            self.ax.set_xticks(indices); self.ax.set_xticklabels([t.strftime('%H:%M:%S') for t in times])
        handles, labels = self.ax.get_legend_handles_labels()
        by_label = dict(zip(labels, handles))
        self.ax.legend(by_label.values(), by_label.keys(), loc='upper left')
        self.info_label.config(text=f"Tổng điểm: {total_points} | Hiển thị: {start+1}-{end}")
        try:
            self.fig.tight_layout()
        except (RecursionError, RuntimeError):
            print("Cảnh báo: Lỗi tạm thời khi tính toán layout biểu đồ.")

    def on_auto_follow_toggle(self):
        if self.auto_follow_var.get():
            total_points = len(self.backend.plot_data_points)
            if total_points > self.points_per_view:
                self.current_start_index = max(0, total_points - self.points_per_view)
            else:
                self.current_start_index = 0
            self.update_plot()

    def on_slider_change(self, value_str):
        if self._is_updating_slider: return
        if self._slider_after_id:
            self.root.after_cancel(self._slider_after_id)
        self._slider_after_id = self.root.after(100, lambda v=value_str: self._perform_slider_update(v))

    def _perform_slider_update(self, value_str):
        self._slider_after_id = None
        if self.auto_follow_var.get():
            self.auto_follow_var.set(False)
        total_points = len(self.backend.plot_data_points)
        if total_points <= self.points_per_view:
            return
        max_start_index = total_points - self.points_per_view
        self.current_start_index = int((float(value_str) / 100) * max_start_index)
        self.update_plot()

    def on_chart_close(self):
        if self._slider_after_id:
            self.root.after_cancel(self._slider_after_id)
            self._slider_after_id = None
        plt.close(self.fig)
        self.chart_window.destroy()
        self.chart_window = None


# ==============================================================================
# KHỐI ĐIỀU KHIỂN CHÍNH (MAIN CONTROLLER)
# ==============================================================================
class MainController:
    # ... (Không thay đổi)
    def __init__(self, backend, command_queue):
        self.backend = backend
        self.command_queue = command_queue
        self.app_instance = None
        self.root = ttk.Window()
        self.root.withdraw()

    def run(self):
        self.check_for_commands()
        self.root.mainloop()

    def check_for_commands(self):
        try:
            command = self.command_queue.get_nowait()
            if command == 'show': self.create_gui_window()
            elif command == 'exit': self.handle_shutdown()
            elif command == 'restart': self.handle_restart()
        except queue.Empty: pass
        finally:
            if not self.backend.exiting and self.root.winfo_exists():
                self.root.after(100, self.check_for_commands)

    def create_gui_window(self):
        if self.app_instance and self.app_instance.root.winfo_exists():
            print("Giao diện đã đang chạy."); self.app_instance.root.lift();
            return
        print("Đang khởi động giao diện người dùng...")
        toplevel_window = tk.Toplevel(self.root)
        self.app_instance = AppGUI(toplevel_window, self.backend, self.on_gui_close)

    def on_gui_close(self, shutdown=False):
        self.app_instance = None
        if shutdown: self.command_queue.put('exit')

    def handle_shutdown(self, silent=False):
        if not silent: print(" -> Nhận lệnh thoát...")
        if self.app_instance: self.app_instance.destroy_all_windows(); self.app_instance = None
        self.backend.shutdown(silent=silent)
        if self.root.winfo_exists(): self.root.destroy()

    def handle_restart(self):
        print(" -> Nhận lệnh khởi động lại...")
        global needs_restart; needs_restart = True
        self.backend.save_session_data(silent=True)
        self.handle_shutdown(silent=True)

# ==============================================================================
# KHỐI THỰC THI CHÍNH (MAIN)
# ==============================================================================
needs_restart = False
command_queue = queue.Queue()
def console_input_listener(cmd_queue: queue.Queue):
    # ... (Không thay đổi)
    while True:
        try:
            command = input().strip().lower()
            if command: cmd_queue.put(command)
            if command in ['exit', 'restart']: break
        except (EOFError, KeyboardInterrupt):
            cmd_queue.put('exit'); break

def signal_handler(signum, frame):
    # ... (Không thay đổi)
    print("\nNhận tín hiệu ngắt (Ctrl+C), đang thoát...")
    if not command_queue.empty():
        try: command_queue.get_nowait()
        except queue.Empty: pass
    command_queue.put('exit')

if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal_handler)
    backend_instance = Backend()
    backend_instance.start_background_tasks()
    console_thread = threading.Thread(target=console_input_listener, args=(command_queue,), daemon=True)
    console_thread.start()
    print("Chương trình đã sẵn sàng.")
    print("Gõ 'show' để mở giao diện, 'exit' để thoát, 'restart' để khởi động lại.")
    main_controller = MainController(backend_instance, command_queue)
    command_queue.put('show')
    main_controller.run()
    if needs_restart:
        print("\n" + "="*50); print("KHỞI ĐỘNG LẠI CHƯƠNG TRÌNH..."); print("="*50 + "\n")
        try: os.execv(sys.executable, ['python'] + sys.argv)
        except Exception as e: print(f"LỖI KHÔNG THỂ KHỞI ĐỘNG LẠI: {e}")
    else: print("Chương trình đã kết thúc.")
