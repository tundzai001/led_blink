import ttkbootstrap as ttk
import tkinter as tk
from tkinter import TclError
from ttkbootstrap.constants import *
from ttkbootstrap import Style
from ttkbootstrap.dialogs import Messagebox
from tkinter import messagebox
from tkinter import filedialog
from tksheet import Sheet
import paho.mqtt.client as mqtt
from datetime import datetime
import csv
import RPi.GPIO as GPIO
import threading
import time
import warnings
import configparser
import signal
import os
import collections # C·∫¢I TI·∫æN: S·ª≠ d·ª•ng deque cho h√†ng ƒë·ª£i hi·ªáu qu·∫£
from concurrent.futures import ThreadPoolExecutor # C·∫¢I TI·∫æN: S·ª≠ d·ª•ng Thread Pool

# C·∫¢I TI·∫æN: C·ªë g·∫Øng s·ª≠ d·ª•ng orjson ƒë·ªÉ tƒÉng t·ªëc ƒë·ªô x·ª≠ l√Ω JSON
try:
    import orjson as json
    print("S·ª≠ d·ª•ng th∆∞ vi·ªán 'orjson' ƒë·ªÉ tƒÉng t·ªëc x·ª≠ l√Ω JSON.")
except ImportError:
    import json
    print("Th∆∞ vi·ªán 'orjson' kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y, s·ª≠ d·ª•ng 'json' m·∫∑c ƒë·ªãnh.")


warnings.filterwarnings("ignore", category=DeprecationWarning)
 #GPIOsetup
LED1_PIN = 3
LED2_PIN = 27
try:
    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)
    GPIO.setup(LED1_PIN, GPIO.OUT)
    GPIO.setup(LED2_PIN, GPIO.OUT)
    print("GPIO setup successful.")
except Exception as e:
    print(f"Error setting up GPIO. Are you running on a Raspberry Pi with permissions? Error: {e}")

SHUTDOWN_REQUESTED = False
threshold = 1.3
sensor_data = []
listening = False
blink_mode = False 
stop_event = threading.Event()
current_topics = []

# C·∫¢I TI·∫æN: Kh·ªüi t·∫°o Thread Pool ƒë·ªÉ qu·∫£n l√Ω c√°c t√°c v·ª• nh·ªè nh∆∞ nh√°y LED
# ƒêi·ªÅu n√†y hi·ªáu qu·∫£ h∆°n vi·ªác t·∫°o lu·ªìng m·ªõi m·ªói l·∫ßn.
thread_pool = ThreadPoolExecutor(max_workers=5, thread_name_prefix='Worker')

# C·∫¢I TI·∫æN: H√†ng ƒë·ª£i d·ªØ li·ªáu v√† c·ªù ƒë·ªÉ c·∫≠p nh·∫≠t giao di·ªán theo l√¥
data_queue = collections.deque()
gui_update_scheduled = False
GUI_UPDATE_INTERVAL_MS = 200 # C·∫≠p nh·∫≠t giao di·ªán m·ªói 200ms

# ==== Flash LED ====
def flash_led(pin, duration=0.3):
    GPIO.setwarnings(False)
    try:
        GPIO.output(pin, GPIO.HIGH)
        time.sleep(duration)
        GPIO.output(pin, GPIO.LOW)
    except Exception as e:
        print(f"Error flashing LED on pin {pin}: {e}")

# ==== GUI ====
root = ttk.Window(themename="flatly")
root.title("Giao di·ªán C·∫£m bi·∫øn & ƒêi·ªÅu khi·ªÉn LED")
root.geometry(f"{root.winfo_screenwidth()}x{root.winfo_screenheight()}")
main = ttk.Frame(root)
main.pack(fill="both", expand=True, padx=10, pady=10)
main.grid_columnconfigure(1, weight=1)
main.grid_rowconfigure (0, weight=1)

style = ttk.Style()
style.configure("Treeview.Heading", font=("Arial", 10, "bold"))
style.configure("Treeview", rowheight=24, font=("Arial", 10))

# ==== LEFT PANEL ====
left = ttk.LabelFrame(main, text="C√†i ƒë·∫∑t MQTT & Ng∆∞·ª°ng")
left.grid(row=0, column=0, sticky="nsw", padx=(0, 15), pady=10)
left.grid_rowconfigure(8, weight=1)
def add_labeled_entry(frame, label, row, default="", width=14, show=None):
    ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w")
    entry = ttk.Entry(frame, width=width, show=show)
    entry.insert(0, default)
    entry.grid(row=row, column=1, sticky="ew", pady=2)
    frame.grid_columnconfigure(1, weight=1)
    return entry

broker_entry = add_labeled_entry(left, "MQTT Broker:", 0, "aitogy.xyz")
port_entry = add_labeled_entry(left, "Port:", 1, "1883")
user_entry = add_labeled_entry(left, "Username:", 2, "abc")
pass_entry = add_labeled_entry(left, "Password:", 3, "xyz", show="*")
pub_entry   = add_labeled_entry(left, "Publish Topic:", 4, "",)
threshold_entry = add_labeled_entry(left, "Ng∆∞·ª°ng c·∫£nh b√°o:", 5, str(threshold))

def save_config(silent=False):
    config = configparser.ConfigParser()
    config['MQTT'] = {
        'broker': broker_entry.get(),
        'port': port_entry.get(),
        'username': user_entry.get(),
        'password': pass_entry.get(),
        'topics': topic_input.get("1.0", "end").strip(),
        'publish': pub_entry.get()
    }
    config['Settings'] = {
        'threshold': threshold_entry.get()
    }
    with open('config.ini', 'w') as f:
        config.write(f)
    if not silent:
        messagebox.showinfo("L∆∞u c·∫•u h√¨nh", "ƒê√£ l∆∞u c·∫•u h√¨nh th√†nh c√¥ng")

def apply_and_save_config():
    save_config()
    if listening:
        print("ƒêang ·ªü ch·∫ø ƒë·ªô t·ª± ƒë·ªông, √°p d·ª•ng c·∫•u h√¨nh MQTT m·ªõi...")
        update_mqtt()

def load_config():
    config = configparser.ConfigParser()
    if not os.path.exists('config.ini'):
        print("Kh√¥ng t√¨m th·∫•y file config.ini. S·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh.")
        return
    config.read('config.ini')
    if "MQTT" in config:
        mqtt_config = config["MQTT"]
        broker_entry.delete(0, tk.END)
        broker_entry.insert(0, mqtt_config.get("broker", ""))

        port_entry.delete(0, tk.END)
        port_entry.insert(0, mqtt_config.get("port", "1883"))

        user_entry.delete(0, tk.END)
        user_entry.insert(0, mqtt_config.get("username", ""))

        pass_entry.delete(0, tk.END)
        pass_entry.insert(0, mqtt_config.get("password", ""))

        topic_input.delete("1.0", tk.END)
        topic_input.insert("1.0", mqtt_config.get("topics", ""))
        
        pub_entry.delete(0, tk.END)
        pub_entry.insert(0, mqtt_config.get("publish", "led_data"))

    if "Settings" in config and "threshold" in config["Settings"]:
        threshold_entry.delete(0, tk.END)
        threshold_entry.insert(0, config["Settings"]["threshold"])
    print("ƒê√£ t·∫£i c·∫•u h√¨nh.")

def load_threshold():
    config = configparser.ConfigParser()
    config.read('config.ini')
    if "Settings" in config and 'threshold' in config['Settings']: 
        threshold_entry.delete(0, tk.END)
        threshold_entry.insert(0, config['Settings']['threshold'])

def toggle_pass():
    if pass_entry.cget("show") == "":
        pass_entry.config(show="*")
        show_btn.config(text="üëÅ")
    else:
        pass_entry.config(show="")
        show_btn.config(text="üôà")

show_btn = ttk.Button(left, text="üëÅ", command=toggle_pass, width=2)
show_btn.grid(row=3, column=2, sticky="w")
ttk.Label(left, text="Subscribe Topics (1 d√≤ng m·ªói topic):").grid(row=7, column=0, columnspan=2, sticky="w")
topic_input = tk.Text(left, width=22, height=6)
topic_input.grid(row=8, column=0, columnspan=3, pady=(0,5), sticky="nsew")
ttk.Button(left, text="L∆∞u & √Åp d·ª•ng", command=apply_and_save_config, bootstyle="primary").grid(row=9, column=0, columnspan=3, sticky="ew", pady=5)

exiting = False
def on_connect(client, userdata, flags, rc):
    root.after(0, _on_connect_gui, rc, flags)

def _on_connect_gui(rc, flags): 
    global current_topics
    if rc == 0:
        print("MQTT Connected successfully.")
        topics_to_subscribe = [t for t in topic_input.get("1.0", "end").strip().splitlines() if t]

        topics_to_unsubscribe = set(current_topics) - set(topics_to_subscribe)
        for t in topics_to_unsubscribe:
            if t:
                client.unsubscribe(t)
                print(f"Unsubscribed from topic: {t}")

        topics_to_subscribe_new = set(topics_to_subscribe) - set(current_topics)
        for t in topics_to_subscribe_new:
            if t:
                client.subscribe(t)
                print(f"Subscribed to topic: {t}")

        current_topics = topics_to_subscribe 

        if not current_topics:
            print("Warning: No topics specified to subscribe to.")
            if listening:
                status_label.config(text="Tr·∫°ng th√°i: T·ª∞ ƒê·ªòNG (Kh√¥ng c√≥ topic)", foreground="green")
        else:
            if listening:
                status_label.config(text="Tr·∫°ng th√°i: T·ª∞ ƒê·ªòNG", foreground="green")
    else:
        print(f"Failed to connect, return code {rc}\n")
        status_label.config(text="Tr·∫°ng th√°i: L·ªñI K·∫æT N·ªêI", foreground="red")
        if listening:
            messagebox.showerror("MQTT Error", f"Kh√¥ng th·ªÉ k·∫øt n·ªëi MQTT, m√£ l·ªói: {rc}")
        toggle_off()

def _attempt_reconnect(client):
    while not stop_event.is_set() and listening:
        try:
            print("ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i MQTT...")
            broker = broker_entry.get().strip()
            port = int(port_entry.get().strip())
            client.connect(broker, port, 60)
            client.loop_start()
            return 
        except Exception as e:
            print(f"K·∫øt n·ªëi l·∫°i th·∫•t b·∫°i: {e}. Th·ª≠ l·∫°i sau 5 gi√¢y.")
            time.sleep(5)

def update_mqtt():
    global exiting
    if exiting:
        return
    try:
        client.loop_stop()
        if client.is_connected():
            client.disconnect()
    except Exception as e:
        print(f"L·ªói khi ng·∫Øt k·∫øt n·ªëi MQTT ƒë·ªÉ c·∫≠p nh·∫≠t: {e}")
        status_label.config(text="Tr·∫°ng th√°i: M·∫§T K·∫æT N·ªêI", foreground="red")
        thread_pool.submit(_attempt_reconnect, client)
    if listening:
        toggle_on(reconnecting=True)
    
def toggle_on(reconnecting=False):
    global listening, client
    if blink_mode:
        messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng t·∫Øt ch·∫ø ƒë·ªô BLINK tr∆∞·ªõc khi b·∫≠t T·ª∞ ƒê·ªòNG")
        return
    if listening and not reconnecting:
        print("Ch·∫ø ƒë·ªô t·ª± ƒë·ªông ƒë√£ ƒë∆∞·ª£c b·∫≠t.")
        return

    listening = True
    if blink_mode: toggle_blink()
    status_label.config(text="Tr·∫°ng th√°i: ƒêANG K·∫æT N·ªêI...", foreground="orange")
    
    broker = broker_entry.get().strip()
    port_text = port_entry.get().strip()
    pwd = pass_entry.get().strip()
    user = user_entry.get().strip()

    if not broker:
        messagebox.showerror("L·ªói MQTT", "Vui l√≤ng nh·∫≠p ƒë·ªãa ch·ªâ MQTT Broker")
        toggle_off()
        return
    try:
        port = int(port_text)
    except (ValueError, TypeError):
        messagebox.showerror("L·ªói c·∫•u h√¨nh", "Port ph·∫£i l√† s·ªë nguy√™n.")
        toggle_off()
        return

    client = mqtt.Client(protocol=mqtt.MQTTv311)
    client.on_connect = on_connect
    client.on_message = on_message
    client.on_disconnect = on_disconnect
    
    client.username_pw_set(user, pwd)
    
    try:
        print(f"ƒêang t·∫°o k·∫øt n·ªëi m·ªõi t·ªõi MQTT broker: {broker}:{port}...")
        client.connect(broker, port=port, keepalive=60)
        client.loop_start()
    except Exception as e:
        messagebox.showerror("L·ªói k·∫øt n·ªëi MQTT", f"Kh√¥ng th·ªÉ k·∫øt n·ªëi: {e}"); 
        status_label.config(text="Tr·∫°ng th√°i: M·∫§T K·∫æT N·ªêI", foreground="red")
        thread_pool.submit(_attempt_reconnect, client)

# ==== RIGHT PANEL ====
right = ttk.Frame(main, borderwidth=1, relief="solid")
right.grid(row=0, column=1, sticky="nsew")
right.grid_columnconfigure(0, weight=1)
right.grid_rowconfigure(1, weight=1)

status_label = ttk.Label(right, text="Tr·∫°ng th√°i: TH·ª¶ C√îNG", foreground="red", font=("Arial", 11, "bold"))
status_label.grid(row=0, column=0, pady=5)

sheet_frame = ttk.Frame(right)
sheet_frame.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)
sheet_frame.grid_columnconfigure(0, weight=1)
sheet_frame.grid_rowconfigure(0, weight=1)
sheet = Sheet(sheet_frame,
              headers=["T√™n", "Gi√° tr·ªã", "Tr·∫°ng th√°i", "Th·ªùi gian"],
              show_row_index=False,
              column_widths=[150, 100, 100, 150],
)
sheet.enable_bindings()
sheet.set_options(
    font=("Arial", 10, "normal"),
    align="w",
    header_font=("Arial", 10, "bold"),
    table_bg="#ffffff",
    grid_color="#cccccc"
)
sheet.disable_bindings(["edit_cell", "arrowkeys", "drag_and_drop", "column_drag_and_drop", "rc_delete_row", "rc_insert_row", "rc_delete_column", "rc_insert_column"])
sheet.set_options(grid_color="#cccccc", table_bg="#ffffff", index_bg="#eeeeee")
sheet.grid(row=0, column=0, sticky="nsew")

def resize_columns(event=None):
    width = right.winfo_width() - 20 
    # C·∫¢I TI·∫æN: Tr√°nh l·ªói khi chi·ªÅu r·ªông kh√¥ng h·ª£p l·ªá
    if width <= 1: return
    ratios = [0.30, 0.20, 0.20, 0.30]
    new_widths = [int(width * r) for r in ratios]
    try:
        sheet.set.column_widths(new_widths)
    except TclError: # Tr√°nh l·ªói khi widget ƒë√£ b·ªã h·ªßy
        pass
right.bind("<Configure>", resize_columns)


# C·∫¢I TI·∫æN: H√†m x·ª≠ l√Ω h√†ng ƒë·ª£i v√† c·∫≠p nh·∫≠t GUI m·ªôt l·∫ßn
def process_data_queue():
    global gui_update_scheduled
    if exiting or not data_queue:
        gui_update_scheduled = False
        return

    # L·∫•y t·∫•t c·∫£ d·ªØ li·ªáu t·ª´ h√†ng ƒë·ª£i
    new_records = []
    while data_queue:
        new_records.append(data_queue.popleft())

    if new_records:
        sensor_data.extend(new_records)
        
        # C·∫≠p nh·∫≠t b·∫£ng d·ªØ li·ªáu m·ªôt l·∫ßn duy nh·∫•t
        data_as_lists = [list(row) for row in sensor_data]
        sheet.set_sheet_data(data_as_lists, redraw=False) # redraw=False ƒë·ªÉ t·ªëi ∆∞u
        
        # Highlight v√† cu·ªôn ƒë·∫øn h√†ng m·ªõi nh·∫•t
        new_row_index = len(sensor_data) - 1
        if new_row_index >= 0:
            sheet.dehighlight_all()
            sheet.highlight_rows([new_row_index], bg='#D2EAF8')
            sheet.see(row=new_row_index, column=0)
        
        sheet.redraw() # V·∫Ω l·∫°i b·∫£ng m·ªôt l·∫ßn duy nh·∫•t

    gui_update_scheduled = False

# C·∫¢I TI·∫æN: H√†m l√™n l·ªãch c·∫≠p nh·∫≠t GUI
def schedule_gui_update():
    global gui_update_scheduled
    if not gui_update_scheduled:
        gui_update_scheduled = True
        root.after(GUI_UPDATE_INTERVAL_MS, process_data_queue)

def clear_table():
    sensor_data.clear()
    data_queue.clear()
    root.after(0, lambda: sheet.set_sheet_data([]))
    print("ƒê√£ x√≥a b·∫£ng d·ªØ li·ªáu l√∫c 00:00")

def auto_clear_loop():
    while not stop_event.wait(timeout=10):
        now = datetime.now()
        if now.hour == 0 and now.minute == 0:
            clear_table()
            stop_event.wait(60)

def on_message(client, userdata, msg):
    if not listening:
        return
    try:
        payload = msg.payload.decode()
        data = json.loads(payload)
        name = data.get("sensorname", msg.topic)
        value = float(data.get("value", 0))
        ts = float(data.get("timestamp", time.time()))
        
        try:
            current_threshold = float(threshold_entry.get())
        except (ValueError, TclError):
            current_threshold = float('inf')
            print("L·ªói: Gi√° tr·ªã ng∆∞·ª°ng kh√¥ng h·ª£p l·ªá, s·ª≠ d·ª•ng gi√° tr·ªã v√¥ c√πng.")
        
        status = "VUOT MUC" if value > current_threshold else "AN TOAN"
        time_str = datetime.fromtimestamp(ts).strftime("%H:%M:%S %d-%m")
        record = (name, value, status, time_str)

        # C·∫¢I TI·∫æN: Th√™m d·ªØ li·ªáu v√†o h√†ng ƒë·ª£i thay v√¨ c·∫≠p nh·∫≠t GUI tr·ª±c ti·∫øp
        data_queue.append(record)
        schedule_gui_update()

        # C·∫¢I TI·∫æN: S·ª≠ d·ª•ng thread pool ƒë·ªÉ nh√°y LED, hi·ªáu qu·∫£ h∆°n
        thread_pool.submit(flash_led, LED1_PIN)
        if value > current_threshold:
            thread_pool.submit(flash_led, LED2_PIN)

        pub_topic = pub_entry.get().strip()
        if pub_topic:
            client.publish(pub_topic, f"({value}, {status}, {int(ts)})")

    except (json.JSONDecodeError, UnicodeDecodeError):
        print(f"Error decoding JSON from topic '{msg.topic}'")
    except ValueError:
        print(f"Error converting value to float from topic '{msg.topic}'")
    except Exception as e:
        print(f"L·ªói trong on_message: {e}")

def on_disconnect(client, userdata, rc):
    global exiting
    if not exiting and listening and rc != 0:
        root.after(0, update_disconnect_status)

def update_disconnect_status():   
        if listening:
            print("M·∫•t k·∫øt n·ªëi MQTT, ƒëang th·ª≠ k·∫øt n·ªëi l·∫°i...")
            status_label.config(text="Tr·∫°ng th√°i: M·∫§T K·∫æT N·ªêI", foreground="orange")
            # C·∫¢I TI·∫æN: S·ª≠ d·ª•ng thread pool ƒë·ªÉ k·∫øt n·ªëi l·∫°i
            thread_pool.submit(_attempt_reconnect, client)

client = mqtt.Client(protocol=mqtt.MQTTv311)
client.on_connect = on_connect
client.on_message = on_message
client.on_disconnect = on_disconnect

def toggle_off():
    global listening, current_topics
    if not listening:
        return
    listening = False
    current_topics.clear()
    try:
        if client.is_connected():
            client.loop_stop()
            client.disconnect()
            print("ƒê√£ ng·∫Øt k·∫øt n·ªëi MQTT.")
    except Exception as e:
        print(f"L·ªói khi t·∫Øt MQTT (c√≥ th·ªÉ b·ªè qua): {e}")
    status_label.config(text="Tr·∫°ng th√°i: TH·ª¶ C√îNG", foreground="red")

def toggle_led(pin):
    if not listening:
        try:
            GPIO.output(pin, not GPIO.input(pin))
        except Exception as e:
            print(f"Could not toggle LED on pin {pin}: {e}")
    else:
        messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng t·∫Øt ch·∫ø ƒë·ªô t·ª± ƒë·ªông tr∆∞·ªõc khi ƒëi·ªÅu khi·ªÉn LED th·ªß c√¥ng")

def blink_loop():
    state = True
    while not stop_event.wait(timeout=0.5):
        if blink_mode and not listening:
            try:
                GPIO.output(LED1_PIN, state)
                GPIO.output(LED2_PIN, state)
                state = not state
            except Exception as e:
                print(f"L·ªói trong blink_loop: {e}")

def toggle_blink():
    global blink_mode
    if listening:
        messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng t·∫Øt ch·∫ø ƒë·ªô t·ª± ƒë·ªông tr∆∞·ªõc khi b·∫≠t BLINK")
        return

    blink_mode = not blink_mode
    if blink_mode:
        status_label.config(text="Tr·∫°ng th√°i: BLINK", foreground="blue")
    else:
        try:
            GPIO.output(LED1_PIN, GPIO.LOW)
            GPIO.output(LED2_PIN, GPIO.LOW)
        except Exception as e:
            print(f"Could not turn off LEDs: {e}")
        status_label.config(text="Tr·∫°ng th√°i: TH·ª¶ C√îNG", foreground="red")

def console_input_listener():
    print("G√µ 'exit' v√† nh·∫•n Enter trong console n√†y ƒë·ªÉ tho√°t kh·∫©n c·∫•p.")
    while not stop_event.is_set():
        try:
            command = input()
            if command.strip().lower() == 'exit':
                print("L·ªánh 'exit' ƒë√£ ƒë∆∞·ª£c nh·∫≠n. Th·ª±c hi·ªán tho√°t kh·∫©n c·∫•p...")
                exit_program_force()
                break
        except (EOFError, KeyboardInterrupt):
            if not exiting:
                exit_program_force()
            break
        except Exception:
            break

def _write_csv_in_background(path, data_list_from_gui):
    data_to_save = list(data_list_from_gui)
    try:
        print(f"B·∫Øt ƒë·∫ßu ghi {len(data_to_save)} d√≤ng v√†o file CSV trong lu·ªìng n·ªÅn...")
        
        start_time = time.time()
        with open(path, "w", newline="", encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(["T√™n", "Gi√° tr·ªã", "Tr·∫°ng th√°i", "Th·ªùi gian"])
            writer.writerows(data_to_save)
        end_time = time.time()
       
        print(f"Ghi file CSV th√†nh c√¥ng trong {end_time - start_time:.2f} gi√¢y.")
        root.after(0, lambda: messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ l∆∞u {len(data_to_save)} d√≤ng d·ªØ li·ªáu v√†o {path}"))
    except Exception as e:
        print(f"L·ªói khi ghi file CSV: {e}")
        root.after(0, lambda: messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ l∆∞u file: {e}"))
    finally:
        root.after(0, lambda: save_csv_button.config(state="normal"))

def save_to_csv():
    if not sensor_data:
        messagebox.showinfo("Th√¥ng b√°o", "Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ l∆∞u.")
        return
    path = filedialog.asksaveasfilename(
        defaultextension=".csv",
        filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
    )
    if path:
        save_csv_button.config(state="disabled")
        print(f"Chu·∫©n b·ªã l∆∞u {len(sensor_data)} d√≤ng. G·ª≠i t√°c v·ª• ƒë·∫øn lu·ªìng n·ªÅn...")
        thread_pool.submit(_write_csv_in_background, path, sensor_data)

exiting = False 
def _cleanup_and_destroy():
    global exiting
    if exiting:
        return
    exiting = True
    print("ƒê√£ nh·∫≠n t√≠n hi·ªáu tho√°t. B·∫Øt ƒë·∫ßu qu√° tr√¨nh d·ªçn d·∫πp...")
    stop_event.set()

    def cleanup_thread_task():
        print("Lu·ªìng d·ªçn d·∫πp: ƒêang d·ª´ng Thread Pool...")
        # C·∫¢I TI·∫æN: D·ªçn d·∫πp Thread Pool m·ªôt c√°ch an to√†n
        thread_pool.shutdown(wait=True)
        print("Lu·ªìng d·ªçn d·∫πp: Thread Pool ƒë√£ d·ª´ng.")

        print("Lu·ªìng d·ªçn d·∫πp: ƒêang ng·∫Øt k·∫øt n·ªëi MQTT...")
        try:
            if client.is_connected():
                client.loop_stop()
                client.disconnect()
            print("Lu·ªìng d·ªçn d·∫πp: ƒê√£ ng·∫Øt k·∫øt n·ªëi MQTT.")
        except Exception as e:
            print(f"Lu·ªìng d·ªçn d·∫πp: L·ªói khi ng·∫Øt k·∫øt n·ªëi MQTT (c√≥ th·ªÉ b·ªè qua): {e}")

        print("Lu·ªìng d·ªçn d·∫πp: ƒêang d·ªçn d·∫πp GPIO...")
        try:
            GPIO.cleanup()
            print("Lu·ªìng d·ªçn d·∫πp: ƒê√£ d·ªçn d·∫πp GPIO.")
        except Exception as e:
            print(f"Lu·ªìng d·ªçn d·∫πp: L·ªói khi d·ªçn d·∫πp GPIO (c√≥ th·ªÉ b·ªè qua): {e}")
        
        print("Lu·ªìng d·ªçn d·∫πp: ƒê√£ ho√†n t·∫•t.")
        # C·∫¢I TI·∫æN: G·ªçi root.quit() t·ª´ lu·ªìng ch√≠nh ƒë·ªÉ ƒë·∫£m b·∫£o an to√†n
        root.after(0, root.quit)

    cleanup_thread = threading.Thread(target=cleanup_thread_task, daemon=True)
    cleanup_thread.start()
    
def exit_program_graceful():
    global exiting
    if exiting: return
    if messagebox.askokcancel("X√°c nh·∫≠n", "B·∫°n c√≥ mu·ªën tho√°t ch∆∞∆°ng tr√¨nh?"):
        # L∆∞u d·ªØ li·ªáu n·∫øu c·∫ßn
        if sensor_data and messagebox.askyesno("L∆∞u d·ªØ li·ªáu", "B·∫°n c√≥ mu·ªën l∆∞u b·∫£ng d·ªØ li·ªáu ra file CSV kh√¥ng?"):
            save_to_csv()
        
        _cleanup_and_destroy()

def exit_program_force():
    global exiting
    if exiting:
        return
    exiting = True
    stop_event.set()
    print("Th·ª±c hi·ªán tho√°t kh·∫©n c·∫•p...")
    try:
        save_config(silent=True)
        print("ƒê√£ l∆∞u c·∫•u h√¨nh cu·ªëi c√πng.")
    except Exception as e:
        print(f"Kh√¥ng th·ªÉ l∆∞u c·∫•u h√¨nh khi tho√°t kh·∫©n c·∫•p: {e}")
    
    # C·ªë g·∫Øng d·ªçn d·∫πp nhanh
    thread_pool.shutdown(wait=False)
    try:
        GPIO.cleanup()
    except: pass
    os._exit(1) # Tho√°t ngay l·∫≠p t·ª©c

def signal_handler(signum, frame):
    print("\nƒê√£ nh·∫≠n t√≠n hi·ªáu Ctrl+C.")
    exit_program_force()

ctrl = ttk.Frame(right)
ctrl.grid(row=2, column=0, pady=5, sticky="ew")
ctrl.grid_columnconfigure((0, 1, 2, 3), weight=1)
right.grid_rowconfigure(2, weight=0)
ttk.Button(ctrl, text="T·ª± ƒë·ªông (ON)", command=toggle_on, bootstyle="success").grid(row=0, column=0, padx=3)
ttk.Button(ctrl, text="Th·ªß c√¥ng (OFF)", command=toggle_off, bootstyle="danger").grid(row=0, column=1, padx=3)
save_csv_button = ttk.Button(ctrl, text="L∆∞u CSV", command=save_to_csv, bootstyle="info")
save_csv_button.grid(row=0, column=2, padx=3)
ttk.Button(ctrl, text="Tho√°t", command=exit_program_graceful, bootstyle="secondary").grid(row=0, column=3, padx=3)

led_panel = ttk.LabelFrame(right, text="LED Th·ªß c√¥ng")
led_panel.grid(row=3, column=0, pady=5, sticky="ew")
led_panel.grid_columnconfigure((0, 1, 2), weight=1)
right.grid_rowconfigure(3, weight=0)
ttk.Button(led_panel, text="LED1", width=10, command=lambda: toggle_led(LED1_PIN)).grid(row=0, column=0, padx=5, pady=5)
ttk.Button(led_panel, text="LED2", width=10, command=lambda: toggle_led(LED2_PIN)).grid(row=0, column=1, padx=5, pady=5)
ttk.Button(led_panel, text="BLINK", width=10, command=toggle_blink).grid(row=0, column=2, padx=5, pady=5)

# ==== Run ====
if __name__ == "__main__":
    console_listener_thread = threading.Thread(target=console_input_listener, daemon=True)
    console_listener_thread.start()
    
    threading.Thread(target=blink_loop, daemon=True).start()
    
    signal.signal(signal.SIGINT, signal_handler)
    root.protocol("WM_DELETE_WINDOW", exit_program_graceful)
    
    load_config()
    # Kh·ªüi t·∫°o b·∫£ng ban ƒë·∫ßu
    sheet.set_sheet_data([["", "", "", ""]])
    
    print("Ch∆∞∆°ng tr√¨nh ƒë√£ s·∫µn s√†ng. ƒê√≥ng c·ª≠a s·ªï ho·∫∑c nh·∫•n Ctrl+C trong console ƒë·ªÉ tho√°t.")
    root.mainloop()

    # ƒêo·∫°n m√£ n√†y s·∫Ω ch·∫°y sau khi mainloop k·∫øt th√∫c
    print("ƒê√£ tho√°t kh·ªèi v√≤ng l·∫∑p ch√≠nh c·ªßa giao di·ªán.")
    if not exiting:
        # D·ªçn d·∫πp l·∫ßn cu·ªëi n·∫øu tho√°t kh√¥ng theo quy tr√¨nh chu·∫©n
        print("Th·ª±c hi·ªán d·ªçn d·∫πp cu·ªëi c√πng...")
        stop_event.set()
        thread_pool.shutdown(wait=False)
        try:
            GPIO.cleanup()
        except: pass
    print("ƒê√£ tho√°t ch∆∞∆°ng tr√¨nh.")
