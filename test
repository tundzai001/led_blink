import tkinter as tk
from tkinter import messagebox, filedialog
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tksheet import Sheet
import paho.mqtt.client as mqtt
import json
from datetime import datetime
import threading
import time
import warnings
import configparser
import signal
import os
import sys
import queue
from collections import deque
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt
import numpy as np

# --- TH√äM M·ªöI: Import v√† ki·ªÉm tra Pygame ---
try:
    import pygame
    PYGAME_AVAILABLE = True
except ImportError:
    PYGAME_AVAILABLE = False
    print("C·∫¢NH B√ÅO: Th∆∞ vi·ªán 'pygame' ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t. Ch·ª©c nƒÉng c·∫£nh b√°o √¢m thanh s·∫Ω b·ªã v√¥ hi·ªáu h√≥a.")
    print("Vui l√≤ng c√†i ƒë·∫∑t b·∫±ng l·ªánh: pip install pygame")


# --- C√ÅC H·∫∞NG S·ªê TO√ÄN C·ª§C ---
warnings.filterwarnings("ignore", category=DeprecationWarning)
CONFIG_FILE = 'config.ini'
SESSION_FILE = "session.json"
DATA_CLEAR_SIGNAL = "CLEAR_ALL_DATA"
LED1_PIN = 3
LED2_PIN = 27
MAX_PLOT_POINTS = 10000

# --- MOCK GPIO CHO M√îI TR∆Ø·ªúNG KH√îNG PH·∫¢I RASPBERRY PI ---
try:
    import RPi.GPIO as GPIO
    IS_PI = True
except (ImportError, RuntimeError):
    IS_PI = False
    print("C·∫¢NH B√ÅO: Kh√¥ng th·ªÉ import RPi.GPIO. Ch·∫°y ·ªü ch·∫ø ƒë·ªô m√¥ ph·ªèng GPIO.")

class MockGPIO:
    BCM, OUT, LOW, HIGH = "BCM_MODE", "OUT_MODE", 0, 1
    def setmode(self, mode): print(f"[GPIO Mock] Set mode to {mode}")
    def setwarnings(self, state): print(f"[GPIO Mock] Set warnings to {state}")
    def setup(self, pin, mode, initial=LOW): self.output(pin, initial); print(f"[GPIO Mock] Setup pin {pin} to mode {mode}")
    def output(self, pin, state): print(f"[GPIO Mock] Set pin {pin} to state {'HIGH' if state else 'LOW'}")
    def cleanup(self): print("[GPIO Mock] GPIO cleanup called.")

if not IS_PI:
    GPIO = MockGPIO()

# ==============================================================================
# L·ªöP LOGIC N·ªÄN (BACKEND)
# ==============================================================================
class Backend:
    def __init__(self):
        self.listening = False
        self.exiting = False
        self.status_text = "Tr·∫°ng th√°i: TH·ª¶ C√îNG"
        self.status_color = "red"
        self.config = configparser.ConfigParser()
        self.broker, self.port, self.username, self.password = "aitogy.xyz", 1883, "abc", "xyz"
        self.publish_topic = ""
        self.subscribe_topics = []
        self.threshold = 1.1
        self.led1_pin, self.led2_pin = LED1_PIN, LED2_PIN
        # --- THAY ƒê·ªîI: Qu·∫£n l√Ω 2 file √¢m thanh v√† tr·∫°ng th√°i c·∫£nh b√°o ---
        self.siren_sound_path = ""      # ƒê∆∞·ªùng d·∫´n file c√≤i
        self.warning_sound_path = ""    # ƒê∆∞·ªùng d·∫´n file l·ªùi n√≥i
        self.alert_active = False       # C·ªù b√°o hi·ªáu c·∫£nh b√°o ƒëang ho·∫°t ƒë·ªông
        self.alert_thread = None        # Lu·ªìng x·ª≠ l√Ω v√≤ng l·∫∑p √¢m thanh
        self.mixer_initialized = False
        self.sensor_data = []
        self.plot_data_points = deque(maxlen=MAX_PLOT_POINTS)
        self.gui_update_queue = queue.Queue()
        self.client = mqtt.Client(protocol=mqtt.MQTTv311)
        self.client.on_connect = self.on_connect
        self.client.on_disconnect = self.on_disconnect
        self.client.on_message = self.on_message
        self.stop_event = threading.Event()

        self.setup_audio_mixer()
        self.setup_gpio()
        self.load_config()

    def setup_audio_mixer(self):
        """Kh·ªüi t·∫°o Pygame mixer ƒë·ªÉ s·∫µn s√†ng ph√°t √¢m thanh."""
        if not PYGAME_AVAILABLE:
            return
        try:
            pygame.mixer.init()
            self.mixer_initialized = True
            print("Pygame mixer ƒë√£ kh·ªüi t·∫°o th√†nh c√¥ng.")
        except Exception as e:
            print(f"L·ªñI: Kh√¥ng th·ªÉ kh·ªüi t·∫°o pygame mixer: {e}")
            self.mixer_initialized = False

    def setup_gpio(self):
        try:
            GPIO.setmode(GPIO.BCM)
            GPIO.setwarnings(False)
            GPIO.setup(self.led1_pin, GPIO.OUT, initial=GPIO.LOW)
            GPIO.setup(self.led2_pin, GPIO.OUT, initial=GPIO.LOW)
            print("GPIO setup successful.")
        except Exception as e:
            print(f"Error setting up GPIO: {e}")

    def start_background_tasks(self):
        self.load_session_data()
        threading.Thread(target=self.auto_clear_scheduler, daemon=True).start()
        print("ƒê√£ kh·ªüi ch·∫°y c√°c t√°c v·ª• n·ªÅn.")

    def flash_led(self, pin, duration=0.3):
        try:
            GPIO.output(pin, GPIO.HIGH)
            time.sleep(duration)
            GPIO.output(pin, GPIO.LOW)
        except Exception as e:
            print(f"Error flashing LED on pin {pin}: {e}")

    def on_connect(self, client, userdata, flags, rc):
        if self.exiting: return
        if rc == 0:
            print("MQTT Connected successfully.")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: T·ª∞ ƒê·ªòNG", "green"
            for t in self.subscribe_topics:
                client.subscribe(t)
                print(f"Subscribed: {t}")
            if not self.subscribe_topics:
                self.status_text = "Tr·∫°ng th√°i: T·ª∞ ƒê·ªòNG (Kh√¥ng c√≥ topic)"
        else:
            print(f"Failed to connect, return code {rc}")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: L·ªñI K·∫æT N·ªêI", "red"
            self.listening = False

    def on_disconnect(self, client, userdata, rc):
        if not self.exiting and self.listening:
            print("M·∫•t k·∫øt n·ªëi MQTT...")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: M·∫§T K·∫æT N·ªêI", "orange"

    def on_message(self, client, userdata, msg):
        if not self.listening or self.exiting: return
        try:
            data = json.loads(msg.payload.decode())
            name = data.get("sensorname", msg.topic)
            value = float(data.get("value", 0))
            ts = float(data.get("timestamp", time.time()))
            dt_object = datetime.fromtimestamp(ts)
            
            is_over_threshold = value > self.threshold
            status = "VUOT MUC" if is_over_threshold else "AN TOAN"
            record = (name, f"{value:.2f}", status, dt_object.strftime("%H:%M:%S %d-%m"))
            
            self.sensor_data.append(record)
            self.plot_data_points.append((dt_object, value))
            self.gui_update_queue.put(record)

            threading.Thread(target=self.flash_led, args=(self.led1_pin,), daemon=True).start()

            # --- LOGIC C·∫¢NH B√ÅO √ÇM THANH M·ªöI ---
            if is_over_threshold:
                threading.Thread(target=self.flash_led, args=(self.led2_pin,), daemon=True).start()
                # N·∫øu c·∫£nh b√°o ch∆∞a active, h√£y k√≠ch ho·∫°t n√≥
                if not self.alert_active:
                    self.alert_active = True
                    self.alert_thread = threading.Thread(target=self._alert_sound_loop, daemon=True)
                    self.alert_thread.start()
            else:
                # N·∫øu gi√° tr·ªã ƒë√£ an to√†n, t·∫Øt c·∫£nh b√°o
                if self.alert_active:
                    self.alert_active = False # G·ª≠i t√≠n hi·ªáu d·ª´ng cho lu·ªìng
                    if self.mixer_initialized:
                        pygame.mixer.stop() # D·ª´ng ngay l·∫≠p t·ª©c m·ªçi √¢m thanh
                    print("ƒêi·ªÅu ki·ªán an to√†n, ƒë√£ d·ª´ng v√≤ng l·∫∑p √¢m thanh.")
            
            if self.publish_topic:
                self.client.publish(self.publish_topic, f"({value:.2f}, {status}, {int(ts)})")
        except (json.JSONDecodeError, ValueError, KeyError) as e:
            print(f"L·ªói x·ª≠ l√Ω message: {e}")

    def _alert_sound_loop(self):
        """
        H√†m n√†y ch·∫°y trong m·ªôt lu·ªìng ri√™ng, l·∫∑p l·∫°i chu·ªói √¢m thanh
        (c√≤i -> l·ªùi n√≥i) cho ƒë·∫øn khi c·ªù self.alert_active l√† False.
        """
        if not self.mixer_initialized:
            print("B·ªè qua v√≤ng l·∫∑p √¢m thanh: mixer ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o.")
            return

        print("B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p √¢m thanh c·∫£nh b√°o...")
        
        siren_path = self.siren_sound_path
        warning_path = self.warning_sound_path

        if not siren_path or not os.path.exists(siren_path):
            print(f"L·ªñI: Kh√¥ng t√¨m th·∫•y file c√≤i: {siren_path}")
            self.alert_active = False
            return
        if not warning_path or not os.path.exists(warning_path):
            print(f"L·ªñI: Kh√¥ng t√¨m th·∫•y file l·ªùi n√≥i: {warning_path}")
            self.alert_active = False
            return

        try:
            siren_sound = pygame.mixer.Sound(siren_path)
            warning_sound = pygame.mixer.Sound(warning_path)

            while self.alert_active:
                # 1. Ph√°t ti·∫øng c√≤i
                print(" -> Ph√°t c√≤i...")
                siren_sound.play()
                while pygame.mixer.get_busy() and self.alert_active:
                    time.sleep(0.1)
                
                if not self.alert_active: break

                # 2. Ph√°t l·ªùi n√≥i c·∫£nh b√°o
                print(" -> Ph√°t l·ªùi n√≥i c·∫£nh b√°o...")
                warning_sound.play()
                while pygame.mixer.get_busy() and self.alert_active:
                    time.sleep(0.1)

                if not self.alert_active: break
                
                time.sleep(0.5)

        except Exception as e:
            print(f"L·ªñI trong v√≤ng l·∫∑p √¢m thanh: {e}")
        
        print("ƒê√£ tho√°t kh·ªèi v√≤ng l·∫∑p √¢m thanh.")
        self.alert_active = False

    def get_gui_updates(self):
        updates = []
        while not self.gui_update_queue.empty():
            try:
                updates.append(self.gui_update_queue.get_nowait())
            except queue.Empty:
                break
        return updates

    def toggle_on(self):
        if self.listening: return
        self.listening = True
        self.status_text, self.status_color = "Tr·∫°ng th√°i: ƒêANG K·∫æT N·ªêI...", "orange"
        if not self.broker:
            self.listening = False
            self.status_text, self.status_color = "Tr·∫°ng th√°i: TH·ª¶ C√îNG (L·ªói Broker)", "red"
            return
        
        self.client.username_pw_set(self.username, self.password)
        try:
            print(f"ƒêang k·∫øt n·ªëi t·ªõi MQTT broker: {self.broker}:{self.port}...")
            self.client.connect_async(self.broker, self.port, 60)
            self.client.loop_start()
        except Exception as e:
            self.listening = False
            self.status_text, self.status_color = "Tr·∫°ng th√°i: L·ªñI K·∫æT N·ªêI", "red"
            print(f"L·ªói k·∫øt n·ªëi MQTT: {e}")

    def toggle_off(self):
        if not self.listening: return
        self.listening = False
        try:
            self.client.loop_stop()
            self.client.disconnect()
            print("ƒê√£ ng·∫Øt k·∫øt n·ªëi MQTT.")
        except Exception: pass
        self.status_text, self.status_color = "Tr·∫°ng th√°i: TH·ª¶ C√îNG", "red"

    def update_and_reconnect(self, settings: dict):
        self.broker, self.port = settings['broker'], int(settings['port'])
        self.username, self.password = settings['username'], settings['password']
        self.publish_topic = settings['publish']
        self.subscribe_topics = [t for t in settings['topics'].splitlines() if t]
        self.threshold = float(settings['threshold'])
        
        self.siren_sound_path = settings['siren_sound']
        self.warning_sound_path = settings['warning_sound']

        self.save_config()
        if self.listening:
            print("ƒêang ·ªü ch·∫ø ƒë·ªô t·ª± ƒë·ªông, √°p d·ª•ng c·∫•u h√¨nh MQTT m·ªõi...")
            self.toggle_off()
            time.sleep(1)
            self.toggle_on()

    def check_leds(self):
        if self.listening:
            print("Kh√¥ng th·ªÉ ki·ªÉm tra LED ·ªü ch·∫ø ƒë·ªô T·ª∞ ƒê·ªòNG.")
            return False
        threading.Thread(target=self._run_led_check, daemon=True).start()
        return True

    def _run_led_check(self):
        print("Ki·ªÉm tra LED...")
        try:
            self.flash_led(self.led1_pin, duration=0.5)
            time.sleep(0.1)
            self.flash_led(self.led2_pin, duration=0.5)
        except Exception as e:
            print(f"L·ªói khi ki·ªÉm tra LED: {e}")

    def auto_clear_scheduler(self):
        while not self.stop_event.is_set():
            now = datetime.now()
            if now.hour == 0 and now.minute == 0:
                print("ƒê√£ ƒë·∫øn 00:00, t·ª± ƒë·ªông x√≥a d·ªØ li·ªáu...")
                self.clear_all_data()
                time.sleep(61)
            else:
                time.sleep(30)

    def clear_all_data(self):
        self.sensor_data.clear()
        self.plot_data_points.clear()
        self.gui_update_queue.put(DATA_CLEAR_SIGNAL)
        print("ƒê√£ x√≥a d·ªØ li·ªáu n·ªÅn.")

    def load_config(self):
        if not os.path.exists(CONFIG_FILE): return
        try:
            self.config.read(CONFIG_FILE)
            if "MQTT" in self.config:
                mqtt_cfg = self.config["MQTT"]
                self.broker = mqtt_cfg.get("broker", self.broker)
                self.port = mqtt_cfg.getint("port", self.port)
                self.username = mqtt_cfg.get("username", self.username)
                self.password = mqtt_cfg.get("password", self.password)
                self.subscribe_topics = [t for t in mqtt_cfg.get("topics", "").splitlines() if t]
                self.publish_topic = mqtt_cfg.get("publish", self.publish_topic)
            if "Settings" in self.config:
                settings_cfg = self.config["Settings"]
                self.threshold = settings_cfg.getfloat("threshold", self.threshold)
                self.siren_sound_path = settings_cfg.get("siren_sound_path", "")
                self.warning_sound_path = settings_cfg.get("warning_sound_path", "")
            print("ƒê√£ t·∫£i c·∫•u h√¨nh.")
        except Exception as e:
            print(f"L·ªói khi t·∫£i c·∫•u h√¨nh t·ª´ {CONFIG_FILE}: {e}")

    def save_config(self):
        self.config['MQTT'] = {
            'broker': self.broker, 'port': self.port, 'username': self.username,
            'password': self.password, 'topics': "\n".join(self.subscribe_topics),
            'publish': self.publish_topic
        }
        self.config['Settings'] = {
            'threshold': self.threshold,
            'siren_sound_path': self.siren_sound_path,
            'warning_sound_path': self.warning_sound_path
        }
        try:
            with open(CONFIG_FILE, 'w') as f: self.config.write(f)
            print("ƒê√£ l∆∞u c·∫•u h√¨nh.")
        except IOError as e:
            print(f"L·ªói L∆∞u File: {e}")

    def save_session_data(self, silent=False):
        if not silent: print(" -> ƒêang l∆∞u tr·∫°ng th√°i hi·ªán t·∫°i v√†o file...")
        try:
            plot_data_serializable = [(dt.isoformat(), val) for dt, val in self.plot_data_points]
            session = {"sensor_data": self.sensor_data, "plot_data_points": plot_data_serializable}
            with open(SESSION_FILE, "w") as f: json.dump(session, f)
            if not silent: print(f" -> ƒê√£ l∆∞u tr·∫°ng th√°i v√†o {SESSION_FILE}")
        except Exception as e:
            print(f" -> L·ªói khi l∆∞u tr·∫°ng th√°i: {e}")

    def load_session_data(self):
        if not os.path.exists(SESSION_FILE): return
        print(f" -> T√¨m th·∫•y file tr·∫°ng th√°i {SESSION_FILE}, ƒëang t·∫£i l·∫°i d·ªØ li·ªáu...")
        try:
            with open(SESSION_FILE, "r") as f: session = json.load(f)
            self.sensor_data = session.get("sensor_data", [])
            
            plot_data_serializable = session.get("plot_data_points", [])
            self.plot_data_points.clear()
            for dt_str, val in plot_data_serializable:
                self.plot_data_points.append((datetime.fromisoformat(dt_str), val))
            
            for record in self.sensor_data: self.gui_update_queue.put(record)
            print(" -> ƒê√£ t·∫£i l·∫°i d·ªØ li·ªáu th√†nh c√¥ng.")
        except Exception as e:
            print(f" -> L·ªói khi t·∫£i tr·∫°ng th√°i: {e}")
        finally:
            if os.path.exists(SESSION_FILE): os.remove(SESSION_FILE)

    def shutdown(self, silent=False):
        if self.exiting: return
        if not silent: print("\nB·∫Øt ƒë·∫ßu qu√° tr√¨nh d·ªçn d·∫πp ƒë·ªÉ tho√°t...")
        self.exiting = True
        self.stop_event.set()
        try:
            self.client.loop_stop(force=True)
            self.client.disconnect()
        except Exception: pass
        try: GPIO.cleanup()
        except Exception: pass
        if not silent: print(" -> Backend ƒë√£ d·ª´ng.")

# ==============================================================================
# L·ªöP GIAO DI·ªÜN NG∆Ø·ªúI D√ôNG (GUI)
# ==============================================================================
class AppGUI:
    def __init__(self, root: tk.Toplevel, backend: Backend, on_close_callback):
        self.root = root
        self.backend = backend
        self.on_close_callback = on_close_callback
        self.root.title("Giao di·ªán C·∫£m bi·∫øn & ƒêi·ªÅu khi·ªÉn LED")
        self.root.geometry(f"{self.root.winfo_screenwidth()}x{self.root.winfo_screenheight()-70}+0+0")
        
        self.chart_window = None
        self.CONVERSION_FACTORS = {"m": 1.0, "cm": 100.0, "mm": 1000.0, "ft": 3.28084}
        self.points_per_view = 40
        self.current_start_index = 0
        
        self.last_highlighted_row = None
        self._is_updating_slider = False
        self._slider_after_id = None 

        self.create_widgets()
        self.load_initial_data()
        self.root.after(250, self.periodic_update)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close_window)

    def destroy_all_windows(self):
        if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.destroy()
        if self.root and self.root.winfo_exists(): self.root.destroy()

    def on_close_window(self):
        print("ƒê√£ ƒë√≥ng c·ª≠a s·ªï giao di·ªán. G√µ 'show' trong terminal ƒë·ªÉ m·ªü l·∫°i.")
        self.on_close_callback()
        self.destroy_all_windows()

    def exit_program_graceful(self):
        if messagebox.askokcancel("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën tho√°t ho√†n to√†n ch∆∞∆°ng tr√¨nh?", parent=self.root):
            self.on_close_callback(shutdown=True)

    def create_widgets(self):
        main = ttk.Frame(self.root, padding=10)
        main.pack(fill="both", expand=True)
        main.grid_columnconfigure(1, weight=1) 
        main.grid_columnconfigure(0, weight=0)
        main.grid_rowconfigure(0, weight=1)
        self.create_left_panel(main)
        self.create_right_panel(main)

    def create_left_panel(self, parent):
        left = ttk.LabelFrame(parent, text="C√†i ƒë·∫∑t MQTT & Ng∆∞·ª°ng", padding=10)
        left.grid(row=0, column=0, sticky="nsw", padx=(0, 15))

        def add_labeled_entry(frame, label, row, show=None):
            ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w", pady=3)
            entry = ttk.Entry(frame, show=show)
            entry.grid(row=row, column=1, sticky="ew", pady=3, columnspan=2)
            return entry

        self.broker_entry = add_labeled_entry(left, "MQTT Broker:", 0)
        self.port_entry = add_labeled_entry(left, "Port:", 1)
        self.user_entry = add_labeled_entry(left, "Username:", 2)
        self.pass_entry = add_labeled_entry(left, "Password:", 3, show="*")
        
        show_btn = ttk.Button(left, text="üëÅ", command=self.toggle_pass, width=2, bootstyle="light")
        show_btn.grid(row=3, column=2, sticky="e", padx=(0,0))

        self.pub_entry = add_labeled_entry(left, "Publish Topic:", 4)
        self.threshold_entry = add_labeled_entry(left, "Ng∆∞·ª°ng (m):", 5)

        # --- THAY ƒê·ªîI: Th√™m 2 tr∆∞·ªùng ch·ªçn file √¢m thanh ---
        def add_sound_selector(frame, label_text, row):
            ttk.Label(frame, text=label_text).grid(row=row, column=0, sticky="w", pady=3)
            entry = ttk.Entry(frame)
            entry.grid(row=row, column=1, sticky="ew", pady=3)
            button = ttk.Button(frame, text="Ch·ªçn...", width=8)
            button.grid(row=row, column=2, sticky="e", padx=(5,0))
            button.configure(command=lambda e=entry: self.select_sound_file(e))
            return entry

        self.siren_sound_entry = add_sound_selector(left, "√Çm thanh C√≤i:", 6)
        self.warning_sound_entry = add_sound_selector(left, "L·ªùi n√≥i C·∫£nh b√°o:", 7)

        ttk.Label(left, text="Subscribe Topics:").grid(row=8, column=0, columnspan=3, sticky="w", pady=(10, 2))
        self.topic_input = tk.Text(left, height=4, width=35, relief="solid", borderwidth=1)
        self.topic_input.grid(row=9, column=0, columnspan=3, pady=(0, 5), sticky="nsew")
        
        left.grid_rowconfigure(9, weight=1)
        ttk.Button(left, text="L∆∞u & √Åp d·ª•ng", command=self.apply_and_save_config, bootstyle="primary").grid(row=10, column=0, columnspan=3, sticky="ew", pady=(10,0))

    def create_right_panel(self, parent):
        right = ttk.Frame(parent)
        right.grid(row=0, column=1, sticky="nsew")
        right.grid_rowconfigure(1, weight=1)
        right.grid_columnconfigure(0, weight=1)

        self.status_label = ttk.Label(right, text="", font=("Arial", 11, "bold"))
        self.status_label.grid(row=0, column=0, sticky="ew", pady=(0, 5))

        sheet_frame = ttk.Frame(right)
        sheet_frame.grid(row=1, column=0, sticky="nsew")
        
        self.sheet = Sheet(sheet_frame, headers=["T√™n", "Gi√° tr·ªã (m)", "Tr·∫°ng th√°i", "Th·ªùi gian"], show_row_index=True)
        self.sheet.pack(fill=tk.BOTH, expand=True)
        self.sheet.disable_bindings()
        self.sheet.set_options(font=("Arial", 10, "normal"), header_font=("Arial", 10, "bold"), align="center")
        self.create_control_panel(right)

    def create_control_panel(self, parent_frame):
        bottom_part = ttk.Frame(parent_frame)
        bottom_part.grid(row=2, column=0, sticky="ew", pady=(10, 0))
        ctrl = ttk.Frame(bottom_part)
        ctrl.pack(side=tk.TOP, fill=tk.X, expand=True)
        for i in range(5): ctrl.grid_columnconfigure(i, weight=1)
        ttk.Button(ctrl, text="T·ª± ƒë·ªông (ON)", command=self.backend.toggle_on, bootstyle="success").grid(row=0, column=0, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Th·ªß c√¥ng (OFF)", command=self.backend.toggle_off, bootstyle="danger").grid(row=0, column=1, padx=2, sticky="ew")
        self.save_csv_button = ttk.Button(ctrl, text="L∆∞u CSV", command=self.save_to_csv, bootstyle="info")
        self.save_csv_button.grid(row=0, column=2, padx=2, sticky="ew")
        ttk.Button(ctrl, text="X√≥a D·ªØ Li·ªáu", command=self.clear_table_gui, bootstyle="warning").grid(row=0, column=3, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Xem Bi·ªÉu ƒê·ªì", command=self.show_chart_window, bootstyle="primary").grid(row=0, column=4, padx=2, sticky="ew")
        led_panel = ttk.LabelFrame(bottom_part, text="Ki·ªÉm tra Thi·∫øt b·ªã", padding=5)
        led_panel.pack(side=tk.TOP, fill=tk.X, expand=True, pady=(10, 0))
        led_panel.grid_columnconfigure(0, weight=3)
        led_panel.grid_columnconfigure(1, weight=1)
        ttk.Button(led_panel, text="Ki·ªÉm tra LED", command=self.on_check_led_click).grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        ttk.Button(led_panel, text="Tho√°t", command=self.exit_program_graceful, bootstyle="secondary-outline").grid(row=0, column=1, padx=5, pady=5, sticky="ew")

    def load_initial_data(self):
        self.broker_entry.insert(0, self.backend.broker)
        self.port_entry.insert(0, str(self.backend.port))
        self.user_entry.insert(0, self.backend.username)
        self.pass_entry.insert(0, self.backend.password)
        self.pub_entry.insert(0, self.backend.publish_topic)
        self.threshold_entry.insert(0, str(self.backend.threshold))
        
        self.siren_sound_entry.insert(0, self.backend.siren_sound_path)
        self.warning_sound_entry.insert(0, self.backend.warning_sound_path)

        self.topic_input.insert("1.0", "\n".join(self.backend.subscribe_topics))
    
    def periodic_update(self):
        if not self.root.winfo_exists(): return
        self.update_status_label()
        new_updates = self.backend.get_gui_updates()
        if new_updates:
            if DATA_CLEAR_SIGNAL in new_updates:
                self.sheet.set_sheet_data([])
                if self.chart_window and self.chart_window.winfo_exists(): self.clear_chart_data()
                print("GUI ƒë√£ nh·∫≠n t√≠n hi·ªáu v√† x√≥a b·∫£ng.")
            else:
                valid_records = [rec for rec in new_updates if isinstance(rec, tuple)]
                if valid_records:
                    self.sheet.insert_rows(valid_records)
                    self.sheet.dehighlight_all()
                    last_row_index = self.sheet.get_total_rows() - 1
                    if last_row_index >= 0:
                        self.sheet.see(row=last_row_index)
                        self.sheet.deselect()
                        last_record = valid_records[-1]
                        status = last_record[2]  
                        if status == "VUOT MUC":
                            highlight_color = "#F8D7DA"  
                        else:
                            highlight_color = "#D4EDDA" 
                        self.sheet.highlight_rows(rows=[last_row_index], bg=highlight_color, fg="black")
            if self.chart_window and self.chart_window.winfo_exists(): self.update_plot()
        self.root.after(250, self.periodic_update)

    def update_status_label(self):
        if self.status_label.cget("text") != self.backend.status_text or self.status_label.cget("foreground") != self.backend.status_color:
            self.status_label.config(text=self.backend.status_text, foreground=self.backend.status_color)

    def toggle_pass(self): self.pass_entry.config(show="" if self.pass_entry.cget("show") else "*")

    def select_sound_file(self, target_entry: ttk.Entry):
        """M·ªü h·ªôp tho·∫°i ƒë·ªÉ ng∆∞·ªùi d√πng ch·ªçn file √¢m thanh v√† ƒëi·ªÅn v√†o entry ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh."""
        filepath = filedialog.askopenfilename(
            title="Ch·ªçn file √¢m thanh",
            filetypes=[("Sound files", "*.mp3 *.wav"), ("All files", "*.*")],
            parent=self.root
        )
        if filepath:
            target_entry.delete(0, tk.END)
            target_entry.insert(0, filepath)

    def apply_and_save_config(self):
        settings = {
            'broker': self.broker_entry.get(), 
            'port': self.port_entry.get(), 
            'username': self.user_entry.get(), 
            'password': self.pass_entry.get(), 
            'topics': self.topic_input.get("1.0", "end").strip(), 
            'publish': self.pub_entry.get(), 
            'threshold': self.threshold_entry.get(),
            'siren_sound': self.siren_sound_entry.get(),
            'warning_sound': self.warning_sound_entry.get()
        }
        try:
            int(settings['port']); float(settings['threshold'])
            self.backend.update_and_reconnect(settings)
            messagebox.showinfo("Th√†nh c√¥ng", "ƒê√£ l∆∞u v√† √°p d·ª•ng c·∫•u h√¨nh.", parent=self.root)
        except ValueError as e: messagebox.showerror("L·ªói", f"D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá: {e}", parent=self.root)
        except Exception as e: messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ √°p d·ª•ng c·∫•u h√¨nh: {e}", parent=self.root)

    def on_check_led_click(self):
        if not self.backend.check_leds(): messagebox.showwarning("C·∫£nh b√°o", "Ch·ªâ c√≥ th·ªÉ ki·ªÉm tra LED ·ªü ch·∫ø ƒë·ªô TH·ª¶ C√îNG (OFF).", parent=self.root)

    def clear_table_gui(self):
        if messagebox.askokcancel("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô d·ªØ li·ªáu hi·ªán t·∫°i?", parent=self.root): self.backend.clear_all_data()

    def save_to_csv(self):
        if not self.backend.sensor_data: messagebox.showinfo("Th√¥ng b√°o", "Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ l∆∞u.", parent=self.root); return
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")], title="L∆∞u file CSV", parent=self.root)
        if path:
            self.save_csv_button.config(state="disabled")
            threading.Thread(target=self._write_csv_in_background, args=(path, list(self.backend.sensor_data)), daemon=True).start()

    def _write_csv_in_background(self, path, data_to_save):
        try:
            import csv
            with open(path, "w", newline="", encoding='utf-8-sig') as f:
                writer = csv.writer(f)
                writer.writerow(self.sheet.headers())
                writer.writerows(data_to_save)
            if self.root.winfo_exists():
                self.root.after(0, lambda p=path: messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ l∆∞u d·ªØ li·ªáu v√†o {os.path.basename(p)}", parent=self.root))
        except Exception as e:
            if self.root.winfo_exists():
                self.root.after(0, lambda err=e: messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ l∆∞u file:\n\n{err}", parent=self.root))
        finally:
            if self.root.winfo_exists():
                self.root.after(0, lambda: self.save_csv_button.config(state="normal"))

    # --- C√°c h√†m bi·ªÉu ƒë·ªì (gi·ªØ nguy√™n, kh√¥ng thay ƒë·ªïi) ---
    def show_chart_window(self):
        if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.lift(); return
        self.chart_window = tk.Toplevel(self.root)
        self.chart_window.title("Bi·ªÉu ƒë·ªì D·ªØ li·ªáu C·∫£m bi·∫øn")
        self.chart_window.geometry("900x650")
        self.chart_window.protocol("WM_DELETE_WINDOW", self.on_chart_close)
        top_frame = ttk.Frame(self.chart_window, padding=(10, 5))
        top_frame.pack(side=tk.TOP, fill=tk.X)
        ttk.Label(top_frame, text="Ch·ªçn ƒë∆°n v·ªã:").pack(side=tk.LEFT, padx=(0, 5))
        self.unit_selector = ttk.Combobox(top_frame, state="readonly", values=list(self.CONVERSION_FACTORS.keys()))
        self.unit_selector.set("m"); self.unit_selector.pack(side=tk.LEFT, padx=5)
        self.unit_selector.bind("<<ComboboxSelected>>", lambda e: self.update_plot())
        self.auto_follow_var = tk.BooleanVar(value=True)
        auto_follow_check = ttk.Checkbutton(top_frame, text="T·ª± ƒë·ªông theo d√µi", variable=self.auto_follow_var, command=self.on_auto_follow_toggle)
        auto_follow_check.pack(side=tk.LEFT, padx=20)
        self.current_start_index = 0
        chart_frame = ttk.Frame(self.chart_window, padding=(10, 5))
        chart_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.fig = Figure(figsize=(9, 4.5), dpi=100)
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=chart_frame)
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        slider_frame = ttk.Frame(self.chart_window, padding=10)
        slider_frame.pack(side=tk.BOTTOM, fill=tk.X)
        self.position_var = tk.DoubleVar()
        self.position_scale = ttk.Scale(slider_frame, from_=0, to=100, orient=tk.HORIZONTAL, variable=self.position_var, command=self.on_slider_change)
        self.position_scale.pack(side=tk.TOP, fill=tk.X, expand=True)
        self.info_label = ttk.Label(slider_frame, text="T·ªïng ƒëi·ªÉm: 0 | Hi·ªÉn th·ªã: 0-0", font=("Arial", 9))
        self.info_label.pack(side=tk.TOP, pady=(5, 0))
        self.update_plot()

    def clear_chart_data(self):
        self.current_start_index = 0
        if hasattr(self, 'auto_follow_var'):
            self.auto_follow_var.set(True)
        self.update_plot()

    def update_plot(self):
        if not (self.chart_window and self.chart_window.winfo_exists()): return
        all_data = list(self.backend.plot_data_points)
        total_points = len(all_data)
        if total_points > self.points_per_view:
            max_start = total_points - self.points_per_view
            self.current_start_index = min(self.current_start_index, max_start)
        start, end = self._update_slider_and_indices(total_points)
        display_data_slice = all_data[start:end]
        self.ax.clear()
        self._setup_plot_style()
        if not display_data_slice:
            self.ax.text(0.5, 0.5, 'Ch∆∞a c√≥ d·ªØ li·ªáu', ha='center', va='center', transform=self.ax.transAxes, fontsize=16, color='gray')
            self.info_label.config(text="T·ªïng ƒëi·ªÉm: 0 | Hi·ªÉn th·ªã: 0-0")
        else:
            indices, values, times, unit, threshold = self._prepare_plot_data(display_data_slice, start)
            self._setup_plot_style(unit)
            self._draw_plot_elements(indices, values, threshold, unit)
            self._configure_plot_axes(start, end, total_points, indices, times)
        self.canvas.draw()

    def _update_slider_and_indices(self, total_points):
        if total_points <= self.points_per_view:
            self.position_scale.config(state="disabled")
            self.current_start_index = 0
            self._is_updating_slider = True
            self.position_scale.set(0)
            self._is_updating_slider = False
        else:
            self.position_scale.config(state="normal")
            if self.auto_follow_var.get():
                self.current_start_index = max(0, total_points - self.points_per_view)

        if total_points > self.points_per_view:
            max_start_idx = max(0, total_points - self.points_per_view)
            pos_percent = (self.current_start_index / max_start_idx) * 100 if max_start_idx > 0 else 100
        else:
            pos_percent = 100

        self._is_updating_slider = True
        self.position_scale.set(pos_percent)
        self._is_updating_slider = False
    
        start = self.current_start_index
        end = min(total_points, start + self.points_per_view)
        return start, end
        
    def _prepare_plot_data(self, data_slice, start_index):
        unit = self.unit_selector.get()
        conversion_factor = self.CONVERSION_FACTORS.get(unit, 1.0)
        indices = range(start_index, start_index + len(data_slice))
        values = [item[1] * conversion_factor for item in data_slice]
        times = [item[0] for item in data_slice]
        threshold = self.backend.threshold * conversion_factor
        return indices, values, times, unit, threshold

    def _setup_plot_style(self, unit='Gi√° tr·ªã'):
        self.ax.set_title('D·ªØ li·ªáu C·∫£m bi·∫øn Theo Th·ªùi Gian', fontsize=14, fontweight='bold')
        self.ax.set_xlabel('Th·ªùi gian', fontsize=12)
        self.ax.set_ylabel(f'Gi√° tr·ªã ({unit})', fontsize=12)
        self.ax.grid(True, which='major', linestyle='--', alpha=0.6)

    def _draw_plot_elements(self, indices, values, threshold, unit):
        safe_indices, safe_values = [], []; warn_indices, warn_values = [], []
        for i, val in zip(indices, values):
            (warn_indices if val > threshold else safe_indices).append(i)
            (warn_values if val > threshold else safe_values).append(val)
        self.ax.plot(indices, values, color='gray', linestyle='-', linewidth=1, alpha=0.5, zorder=3)
        self.ax.scatter(safe_indices, safe_values, color='green', s=40, label='An to√†n', zorder=5)
        self.ax.scatter(warn_indices, warn_values, color='red', s=40, label='V∆∞·ª£t ng∆∞·ª°ng', zorder=5)
        self.ax.axhline(y=threshold, color='darkorange', linestyle='--', linewidth=2, alpha=0.9, label=f'Ng∆∞·ª°ng ({threshold:.2f} {unit})')

    def _configure_plot_axes(self, start, end, total_points, indices, times):
        self.ax.set_xlim(left=start - 0.5, right=start + self.points_per_view - 0.5)
        num_ticks = min(len(indices), 8)
        if num_ticks > 1:
            tick_indices_in_slice = np.linspace(0, len(indices) - 1, num_ticks, dtype=int)
            self.ax.set_xticks([indices[i] for i in tick_indices_in_slice])
            self.ax.set_xticklabels([times[i].strftime('%H:%M:%S') for i in tick_indices_in_slice], rotation=45, ha='right')
        elif len(indices) == 1:
            self.ax.set_xticks(indices); self.ax.set_xticklabels([t.strftime('%H:%M:%S') for t in times])
        handles, labels = self.ax.get_legend_handles_labels()
        self.ax.legend(dict(zip(labels, handles)).values(), dict(zip(labels, handles)).keys(), loc='upper left')
        self.info_label.config(text=f"T·ªïng ƒëi·ªÉm: {total_points} | Hi·ªÉn th·ªã: {start+1}-{end}")
        try:
            self.fig.tight_layout()
        except (RecursionError, RuntimeError):
            print("C·∫£nh b√°o: L·ªói t·∫°m th·ªùi khi t√≠nh to√°n layout bi·ªÉu ƒë·ªì. S·∫Ω t·ª± ƒëi·ªÅu ch·ªânh ·ªü l·∫ßn c·∫≠p nh·∫≠t sau.")

    def on_auto_follow_toggle(self):
        if self.auto_follow_var.get():
            total_points = len(self.backend.plot_data_points)
            if total_points > self.points_per_view:
                self.current_start_index = max(0, total_points - self.points_per_view)
            else: 
                self.current_start_index = 0
            self.update_plot()

    def on_slider_change(self, value_str):
        if self._is_updating_slider: return
        if self._slider_after_id:
            self.root.after_cancel(self._slider_after_id)
        self._slider_after_id = self.root.after(100, lambda v=value_str: self._perform_slider_update(v))

    def _perform_slider_update(self, value_str):
        self._slider_after_id = None
        if self.auto_follow_var.get():
            self.auto_follow_var.set(False)
    
        total_points = len(self.backend.plot_data_points)
        if total_points <= self.points_per_view: 
            return
        
        max_start_index = total_points - self.points_per_view
        self.current_start_index = int((float(value_str) / 100) * max_start_index)
        self.update_plot()

    def on_chart_close(self):
        if self._slider_after_id:
            self.root.after_cancel(self._slider_after_id)
            self._slider_after_id = None
        plt.close(self.fig)
        self.chart_window.destroy()
        self.chart_window = None

# ==============================================================================
# KH·ªêI ƒêI·ªÄU KHI·ªÇN CH√çNH (MAIN CONTROLLER) - Kh√¥ng thay ƒë·ªïi
# ==============================================================================
class MainController:
    def __init__(self, backend, command_queue):
        self.backend = backend
        self.command_queue = command_queue
        self.app_instance = None
        self.root = ttk.Window()
        self.root.withdraw()

    def run(self):
        self.check_for_commands()
        self.root.mainloop()

    def check_for_commands(self):
        try:
            command = self.command_queue.get_nowait()
            if command == 'show': self.create_gui_window()
            elif command == 'exit': self.handle_shutdown()
            elif command == 'restart': self.handle_restart()
        except queue.Empty: pass
        finally:
            if not self.backend.exiting and self.root.winfo_exists(): 
                self.root.after(100, self.check_for_commands)

    def create_gui_window(self):
        if self.app_instance and self.app_instance.root.winfo_exists():
            print("Giao di·ªán ƒë√£ ƒëang ch·∫°y."); self.app_instance.root.lift(); return
        
        print("ƒêang kh·ªüi ƒë·ªông giao di·ªán ng∆∞·ªùi d√πng...")
        toplevel_window = tk.Toplevel(self.root)
        self.app_instance = AppGUI(toplevel_window, self.backend, self.on_gui_close)

    def on_gui_close(self, shutdown=False):
        self.app_instance = None
        if shutdown: self.command_queue.put('exit')

    def handle_shutdown(self, silent=False):
        if not silent: print(" -> Nh·∫≠n l·ªánh tho√°t...")
        if self.app_instance: self.app_instance.destroy_all_windows(); self.app_instance = None
        self.backend.shutdown(silent=silent)
        if self.root.winfo_exists(): self.root.destroy()

    def handle_restart(self):
        print(" -> Nh·∫≠n l·ªánh kh·ªüi ƒë·ªông l·∫°i...")
        global needs_restart; needs_restart = True
        self.backend.save_session_data(silent=True)
        self.handle_shutdown(silent=True)

# ==============================================================================
# KH·ªêI TH·ª∞C THI CH√çNH (MAIN) - Kh√¥ng thay ƒë·ªïi
# ==============================================================================
needs_restart = False
command_queue = queue.Queue()

def console_input_listener(cmd_queue: queue.Queue):
    while True:
        try:
            command = input().strip().lower()
            if command: cmd_queue.put(command)
            if command in ['exit', 'restart']: break
        except (EOFError, KeyboardInterrupt):
            cmd_queue.put('exit'); break

def signal_handler(signum, frame):
    print("\nNh·∫≠n t√≠n hi·ªáu ng·∫Øt (Ctrl+C), ƒëang tho√°t...")
    if not command_queue.empty():
        try: command_queue.get_nowait()
        except queue.Empty: pass
    command_queue.put('exit')

if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal_handler)
    backend_instance = Backend()
    backend_instance.start_background_tasks()
    
    console_thread = threading.Thread(target=console_input_listener, args=(command_queue,), daemon=True)
    console_thread.start()
    
    print("Ch∆∞∆°ng tr√¨nh ƒë√£ s·∫µn s√†ng.")
    print("G√µ 'show' ƒë·ªÉ m·ªü giao di·ªán, 'exit' ƒë·ªÉ tho√°t, 'restart' ƒë·ªÉ kh·ªüi ƒë·ªông l·∫°i.")
    
    main_controller = MainController(backend_instance, command_queue)
    command_queue.put('show')
    
    main_controller.run()
    
    if needs_restart:
        print("\n" + "="*50); print("KH·ªûI ƒê·ªòNG L·∫†I CH∆Ø∆†NG TR√åNH..."); print("="*50 + "\n")
        try: os.execv(sys.executable, ['python'] + sys.argv)
        except Exception as e: print(f"L·ªñI KH√îNG TH·ªÇ KH·ªûI ƒê·ªòNG L·∫†I: {e}")
    else: print("Ch∆∞∆°ng tr√¨nh ƒë√£ k·∫øt th√∫c.")
