import tkinter as tk
from tkinter import messagebox, filedialog, Toplevel
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
import json
from datetime import datetime
import threading
import time
import warnings
import configparser
import signal
import os
import sys
import queue
from collections import deque
import logging
from logging.handlers import TimedRotatingFileHandler
import atexit
import subprocess
import psutil
import traceback

# Bỏ qua cảnh báo không cần thiết và thiết lập môi trường
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1"
warnings.filterwarnings("ignore", category=DeprecationWarning)

# --- CÁC THƯ VIỆN ĐẶC THÙ PI ---
try:
    import RPi.GPIO as GPIO
    import pygame
    IS_RASPBERRY_PI = True
except (ImportError, RuntimeError):
    IS_RASPBERRY_PI = False

# --- Cấu hình logging ---
logger = logging.getLogger()
logger.setLevel(logging.INFO)
info_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
info_handler = TimedRotatingFileHandler('sensor_monitor_info.log', when='midnight', interval=1, backupCount=7, encoding='utf-8')
info_handler.setLevel(logging.INFO)
info_handler.setFormatter(info_formatter)
info_handler.addFilter(lambda record: record.levelno < logging.ERROR)
logger.addHandler(info_handler)
error_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(pathname)s:%(lineno)d - %(message)s')
error_handler = TimedRotatingFileHandler('sensor_monitor_error.log', when='midnight', interval=1, backupCount=30, encoding='utf-8')
error_handler.setLevel(logging.ERROR)
error_handler.setFormatter(error_formatter)
logger.addHandler(error_handler)
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
console_handler.setFormatter(console_formatter)
logger.addHandler(console_handler)

# ==============================================================================
# QUẢN LÝ HẰNG SỐ
# ==============================================================================
class Constants:
    CONFIG_FILE = 'config.ini'
    SHIFTING_PID_FILE = "shifting.pid"
    LED1_PIN = 3
    LED2_PIN = 27
    MAX_PLOT_POINTS = 10000
    DEFAULT_BROKER = "localhost"
    DEFAULT_PORT = 1883
    DEFAULT_USER = ""
    DEFAULT_PASS = ""
    DEFAULT_WARN_THRESHOLD = 1.0
    DEFAULT_CRIT_THRESHOLD = 1.2
    DATA_CLEAR_SIGNAL = "CLEAR_ALL_DATA"

# ==============================================================================
# LỚP LOGIC NỀN (BACKEND) - PHIÊN BẢN BỘ CHỈ HUY
# ==============================================================================
class Backend:
    def __init__(self):
        self.listening = False
        self.exiting = False
        self.status_text = "THỦ CÔNG"
        self.status_color = "danger"
        
        self.config = configparser.ConfigParser()
        self.broker = Constants.DEFAULT_BROKER
        self.port = Constants.DEFAULT_PORT
        self.username = Constants.DEFAULT_USER
        self.password = Constants.DEFAULT_PASS
        self.water_topics = []
        self.gnss_topics = []
        self.warning_threshold = Constants.DEFAULT_WARN_THRESHOLD
        self.critical_threshold = Constants.DEFAULT_CRIT_THRESHOLD
        self.velocity_classification_table = []
        
        self.mixer_initialized = False
        self.shifting_process = None
        self.last_shifting_heartbeat = time.time()
        
        self.gui_update_queue = queue.Queue()
        self.latest_full_report = {}
        
        self.displacement_history = deque(maxlen=Constants.MAX_PLOT_POINTS)
        self.water_level_history = deque(maxlen=Constants.MAX_PLOT_POINTS)
        self.anomaly_score_history = deque(maxlen=Constants.MAX_PLOT_POINTS)
        self.threat_score_history = deque(maxlen=Constants.MAX_PLOT_POINTS)

        self._cleanup_old_shifting_process()
        self.setup_audio_mixer()
        self.setup_gpio()
        self.load_config()

        self._shifting_liveness_thread = threading.Thread(target=self._check_shifting_liveness, daemon=True)
        self._shifting_liveness_thread.start()

        atexit.register(self.cleanup_on_exit)

    def _check_shifting_liveness(self):
        HEARTBEAT_TIMEOUT = 90
        while not self.exiting:
            if self.listening and self.shifting_process and self.shifting_process.poll() is None:
                time_since_last_heartbeat = time.time() - self.last_shifting_heartbeat
                if time_since_last_heartbeat > HEARTBEAT_TIMEOUT:
                    logger.critical("Không nhận được nhịp tim từ shifting.py! Có thể nó đã bị treo. Đang khởi động lại...")
                    self.stop_shifting_process()
                    time.sleep(2)
                    self.start_shifting_process()
            time.sleep(30)

    def _cleanup_old_shifting_process(self):
        pid_file = Constants.SHIFTING_PID_FILE
        if os.path.exists(pid_file):
            try:
                with open(pid_file, 'r') as f:
                    old_pid = int(f.read().strip())
                if psutil.pid_exists(old_pid):
                    logger.warning(f"Phát hiện tiến trình shifting.py mồ côi với PID {old_pid}. Đang dừng nó...")
                    process = psutil.Process(old_pid)
                    process.kill()
            except (ValueError, psutil.NoSuchProcess, psutil.AccessDenied) as e:
                logger.warning(f"Lỗi khi dọn dẹp tiến trình cũ: {e}")
            finally:
                if os.path.exists(pid_file): os.remove(pid_file)

    def start_shifting_process(self):
        if self.shifting_process and self.shifting_process.poll() is None:
            logger.info("Tiến trình shifting.py đã đang chạy.")
            return
        if not self.gnss_topics and not self.water_topics:
            logger.warning("Chưa cấu hình topic. Không khởi động shifting.py.")
            self.status_text, self.status_color = "LỖI: CHƯA CÓ TOPIC", "danger"
            self.listening = False
            return
        try:
            command = [
                sys.executable, '-u', 'shifting.py',
                '--broker', self.broker, '--port', str(self.port),
                '--pid-file', Constants.SHIFTING_PID_FILE,
                '--water-warn-threshold', str(self.warning_threshold),
                '--water-crit-threshold', str(self.critical_threshold),
            ]
            if self.username: command.extend(['--username', self.username])
            if self.password: command.extend(['--password', self.password])
            for topic in self.gnss_topics: command.extend(['--gnss-topic', topic])
            for topic in self.water_topics: command.extend(['--water-topic', topic])
            
            logger.info(f"Đang khởi chạy shifting.py với lệnh: {' '.join(command)}")
            self.shifting_process = subprocess.Popen(
                command, 
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE, 
                stderr=subprocess.PIPE,
                encoding='utf-8', 
                bufsize=1, 
                universal_newlines=True
            )
            threading.Thread(target=self._read_shifting_output, args=(self.shifting_process.stdout,), daemon=True).start()
            threading.Thread(target=self._log_process_errors, args=(self.shifting_process.stderr,), daemon=True).start()
            logger.info("Đã khởi động tiến trình shifting.py và các luồng giám sát.")
            self.status_text, self.status_color = "TỰ ĐỘNG", "success"
        except Exception as e:
            logger.error(f"Lỗi nghiêm trọng khi khởi động shifting.py: {e}\n{traceback.format_exc()}")
            if self.shifting_process: self.shifting_process.kill()
            self.shifting_process = None
            self.status_text, self.status_color = "LỖI KHỞI ĐỘNG SHIFTING", "danger"
            self.listening = False

    def _log_process_errors(self, pipe):
        for line in iter(pipe.readline, ''): logger.error(f"[SHIFTING_STDERR]: {line.strip()}")

    def _read_shifting_output(self, pipe):
        for line in iter(pipe.readline, ''):
            if self.exiting: break
            line_str = line.strip()
            if not line_str: continue
            try:
                data = json.loads(line_str)
                packet_type = data.get("type")
                if packet_type in ["ASTCS_ANALYSIS_REPORT", "HEARTBEAT", "REQUEST_FOR_CONFIRMATION", "SYSTEM_NOTIFICATION"]:
                    self.gui_update_queue.put((packet_type, data))
                    if packet_type != "ASTCS_ANALYSIS_REPORT": # Báo cáo đầy đủ không phải là heartbeat
                        self.last_shifting_heartbeat = time.time()
            except json.JSONDecodeError:
                logger.warning(f"Nhận được dòng không phải JSON từ shifting.py: {line_str}")
            except Exception as e:
                logger.error(f"Lỗi trong luồng đọc shifting.py: {e}")
        logger.info("Luồng đọc kết quả từ shifting.py đã dừng.")

    def stop_shifting_process(self):
        if self.shifting_process and self.shifting_process.poll() is None:
            try:
                logger.info("Đang dừng tiến trình shifting.py...")
                self.shifting_process.terminate()
                self.shifting_process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                logger.warning("Tiến trình shifting.py không phản hồi, buộc dừng (kill).")
                self.shifting_process.kill()
            except Exception as e:
                logger.error(f"Lỗi khi dừng shifting.py: {e}")
        self.shifting_process = None

    def setup_audio_mixer(self):
        if not IS_RASPBERRY_PI: return
        try:
            pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=4096)
            self.mixer_initialized = True
            logger.info("Pygame mixer đã khởi tạo thành công.")
        except Exception as e:
            logger.error(f"Không thể khởi tạo pygame mixer: {e}")
            self.mixer_initialized = False

    def send_command_to_shifting(self, command_packet):
        if self.shifting_process and self.shifting_process.poll() is None:
            try:
                if self.shifting_process.stdin.writable():
                    self.shifting_process.stdin.write(json.dumps(command_packet) + '\n')
                    self.shifting_process.stdin.flush()
                    logger.info(f"Đã gửi lệnh '{command_packet.get('command')}' cho shifting.py.")
                    return True
                else: return False
            except Exception as e:
                logger.error(f"Lỗi khi gửi lệnh: {e}")
        return False

    def update_and_reconnect(self, settings: dict):
        self.broker = settings['broker']; self.port = int(settings['port'])
        self.username = settings['username']; self.password = settings['password']
        self.water_topics = [t.strip() for t in settings.get('water_topics', '').splitlines() if t.strip()]
        self.gnss_topics = [t.strip() for t in settings.get('gnss_topics', '').splitlines() if t.strip()]
        self.warning_threshold = float(settings['warning_threshold'])
        self.critical_threshold = float(settings['critical_threshold'])
        self.save_config()
        if self.listening:
            logger.info("Phát hiện thay đổi cấu hình, đang khởi động lại shifting.py...")
            self.stop_shifting_process(); time.sleep(1); self.start_shifting_process()

    def load_config(self):
        try:
            if not os.path.exists(Constants.CONFIG_FILE):
                logger.warning(f"File cấu hình '{Constants.CONFIG_FILE}' không tồn tại. Tạo mới.")
                self.velocity_classification_table = [
                    {"speed_class": 7, "name": "Extremely Rapid", "threshold_mmps": 5000.0},
                    {"speed_class": 6, "name": "Very Rapid", "threshold_mmps": 50.0},
                    {"speed_class": 5, "name": "Rapid", "threshold_mmps": 0.5},
                    {"speed_class": 4, "name": "Moderate", "threshold_mmps": 0.016},
                    {"speed_class": 3, "name": "Slow", "threshold_mmps": 0.0005},
                    {"speed_class": 2, "name": "Very Slow", "threshold_mmps": 0.000005},
                    {"speed_class": 1, "name": "Extremely Slow", "threshold_mmps": 0.0}]
                self.save_config()
                return
            
            self.config.read(Constants.CONFIG_FILE, encoding='utf-8')
            mqtt_cfg = self.config['MQTT']
            self.broker = mqtt_cfg.get("broker", Constants.DEFAULT_BROKER); self.port = mqtt_cfg.getint("port", Constants.DEFAULT_PORT)
            self.username = mqtt_cfg.get("username", Constants.DEFAULT_USER); self.password = mqtt_cfg.get("password", Constants.DEFAULT_PASS)
            self.water_topics = [t.strip() for t in mqtt_cfg.get("water_sub_topic", "").splitlines() if t.strip()]
            self.gnss_topics = [t.strip() for t in mqtt_cfg.get("gnss_sub_topic", "").splitlines() if t.strip()]
            settings_cfg = self.config['Settings']
            self.warning_threshold = settings_cfg.getfloat("warning_threshold", Constants.DEFAULT_WARN_THRESHOLD)
            self.critical_threshold = settings_cfg.getfloat("critical_threshold", Constants.DEFAULT_CRIT_THRESHOLD)
            
            if "VelocityClassification" in self.config and self.config["VelocityClassification"]:
                self.velocity_classification_table = []
                sorted_keys = sorted(self.config["VelocityClassification"].keys())
                for key in sorted_keys:
                    value = self.config["VelocityClassification"][key]; parts = value.split(',')
                    self.velocity_classification_table.append({"speed_class": int(parts[0]), "name": parts[1], "threshold_mmps": float(parts[2])})
                self.velocity_classification_table.sort(key=lambda x: x['threshold_mmps'], reverse=True)
                logger.info("Đã tải bảng phân loại vận tốc tùy chỉnh từ config.")
        except Exception as e:
            logger.error(f"Lỗi tải cấu hình: {e}")

    def save_config(self):
        try:
            self.config['MQTT'] = {'broker': self.broker, 'port': self.port, 'username': self.username, 'password': self.password, 'water_sub_topic': "\n".join(self.water_topics), 'gnss_sub_topic': "\n".join(self.gnss_topics)}
            self.config['Settings'] = {'warning_threshold': self.warning_threshold, 'critical_threshold': self.critical_threshold}
            self.config['VelocityClassification'] = {}
            for i, item in enumerate(self.velocity_classification_table):
                self.config['VelocityClassification'][f'level_{i}'] = f"{item['speed_class']},{item['name']},{item['threshold_mmps']}"
            with open(Constants.CONFIG_FILE, 'w', encoding='utf-8') as f: self.config.write(f)
            logger.info("Đã lưu cấu hình.")
        except Exception as e:
            logger.error(f"Lỗi lưu cấu hình: {e}")

    def cleanup_on_exit(self):
        if self.exiting: return
        self.exiting = True; logger.info("Bắt đầu quá trình dọn dẹp để thoát...")
        self.stop_shifting_process()
        if IS_RASPBERRY_PI: GPIO.cleanup()
        logger.info("Backend đã dừng.")

    def setup_gpio(self):
        if not IS_RASPBERRY_PI: logger.warning("Không phải Raspberry Pi, bỏ qua cài đặt GPIO."); return
        try:
            GPIO.setmode(GPIO.BCM); GPIO.setwarnings(False)
            GPIO.setup(Constants.LED1_PIN, GPIO.OUT, initial=GPIO.LOW); GPIO.setup(Constants.LED2_PIN, GPIO.OUT, initial=GPIO.LOW)
            logger.info("GPIO setup successful.")
        except Exception as e:
            logger.error(f"Lỗi khi cài đặt GPIO: {e}. Vui lòng chạy với quyền sudo.")

    def flash_led(self, pin, duration=0.3):
        if not IS_RASPBERRY_PI: return
        try: GPIO.output(pin, GPIO.HIGH); time.sleep(duration); GPIO.output(pin, GPIO.LOW)
        except Exception as e: logger.error(f"Lỗi nháy LED trên pin {pin}: {e}")

    def toggle_on(self):
        if self.listening: return
        self.listening = True; self.status_text, self.status_color = "ĐANG KHỞI ĐỘNG...", "warning"
        self.start_shifting_process()

    def toggle_off(self):
        if not self.listening: return
        self.listening = False; self.stop_shifting_process(); self.status_text, self.status_color = "THỦ CÔNG", "danger"

    def check_leds(self):
        if not IS_RASPBERRY_PI: logger.warning("Không phải Raspberry Pi, không thể kiểm tra LED."); return True
        if self.listening: logger.warning("Không thể kiểm tra LED ở chế độ TỰ ĐỘNG."); return False
        threading.Thread(target=self._run_led_check, daemon=True).start(); return True

    def _run_led_check(self):
        logger.info("Kiểm tra LED..."); self.flash_led(Constants.LED1_PIN, 0.5); time.sleep(0.1); self.flash_led(Constants.LED2_PIN, 0.5)

    def clear_all_data(self):
        self.latest_full_report = {}; self.displacement_history.clear(); self.water_level_history.clear()
        self.anomaly_score_history.clear(); self.threat_score_history.clear()
        self.gui_update_queue.put((Constants.DATA_CLEAR_SIGNAL, None))
        logger.info("Đã xóa dữ liệu nền và lịch sử.")

    def get_gui_updates(self):
        updates = []
        while not self.gui_update_queue.empty():
            try: updates.append(self.gui_update_queue.get_nowait())
            except queue.Empty: break
        return updates

# ==============================================================================
# LỚP GIAO DIỆN NGƯỜI DÙNG (GUI)
# ==============================================================================
class AppGUI:
    def __init__(self, root: tk.Toplevel, backend: Backend, on_close_callback):
        self.root = root; self.backend = backend; self.on_close_callback = on_close_callback
        self.root.title("ASTCS - Bảng điều khiển Tình báo")
        self.root.geometry(f"{self.root.winfo_screenwidth()}x{self.root.winfo_screenheight()-70}+0+0")
        
        self.warning_threshold_var = tk.StringVar()
        self.critical_threshold_var = tk.StringVar()
        self.interactive_dialog_open = False
        
        self.create_widgets()
        self.load_initial_data()
        self.root.after(250, self.periodic_update)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close_window)

    def create_widgets(self):
        main = ttk.Frame(self.root, padding=10); main.pack(fill="both", expand=True)
        main.grid_columnconfigure(1, weight=1); main.grid_columnconfigure(0, weight=0); main.grid_rowconfigure(0, weight=1)
        self.create_left_panel(main); self.create_right_panel(main)

    def create_left_panel(self, parent):
        left = ttk.LabelFrame(parent, text="Cài đặt & Điều khiển", padding=10)
        left.grid(row=0, column=0, sticky="nsw", padx=(0, 15))

        def add_labeled_entry(frame, label_text, row, **kwargs):
            ttk.Label(frame, text=label_text).grid(row=row, column=0, sticky="w", pady=3, padx=5)
            entry = ttk.Entry(frame, **kwargs); entry.grid(row=row, column=1, sticky="ew", pady=3, padx=5)
            return entry
        
        mqtt_frame = ttk.LabelFrame(left, text="Cấu hình MQTT", padding=10); mqtt_frame.pack(fill="x", pady=5)
        self.broker_entry = add_labeled_entry(mqtt_frame, "Broker:", 0); self.port_entry = add_labeled_entry(mqtt_frame, "Port:", 1)
        self.user_entry = add_labeled_entry(mqtt_frame, "Username:", 2); self.pass_entry = add_labeled_entry(mqtt_frame, "Password:", 3, show="*")

        topic_frame = ttk.LabelFrame(left, text="Topics Cảm biến", padding=10); topic_frame.pack(fill="x", pady=5)
        ttk.Label(topic_frame, text="GNSS Sub Topics:").pack(anchor="w"); self.gnss_topic_entry = tk.Text(topic_frame, height=4, width=35); self.gnss_topic_entry.pack(fill="x", expand=True, pady=(0, 5))
        ttk.Label(topic_frame, text="Water Sub Topics:").pack(anchor="w"); self.water_topic_entry = tk.Text(topic_frame, height=4, width=35); self.water_topic_entry.pack(fill="x", expand=True, pady=(0, 5))

        threshold_frame = ttk.LabelFrame(left, text="Ngưỡng Cảnh báo Nước", padding=10); threshold_frame.pack(fill="x", pady=5)
        add_labeled_entry(threshold_frame, "Cảnh báo (m):", 0, textvariable=self.warning_threshold_var)
        add_labeled_entry(threshold_frame, "Nguy hiểm (m):", 1, textvariable=self.critical_threshold_var)
        
        adv_frame = ttk.LabelFrame(left, text="Cài đặt Nâng cao", padding=10); adv_frame.pack(fill="x", pady=5)
        ttk.Button(adv_frame, text="Tùy chỉnh Phân loại Tốc độ...", command=self.open_classification_window).pack(fill="x")
        
        ttk.Button(left, text="Lưu & Áp dụng Cấu hình MQTT", command=self.apply_and_save_config, bootstyle="primary").pack(fill="x", pady=(10, 5))

    def create_right_panel(self, parent):
        right = ttk.Frame(parent); right.grid(row=0, column=1, sticky="nsew")
        right.grid_rowconfigure(1, weight=1); right.grid_columnconfigure(0, weight=1)
        self.status_label = ttk.Label(right, text="Khởi tạo...", font=("Arial", 11, "bold")); self.status_label.grid(row=0, column=0, sticky="ew", pady=(0, 5), padx=5)
        dashboard_frame = ttk.Frame(right); dashboard_frame.grid(row=1, column=0, sticky="nsew"); self.create_dashboard_widgets(dashboard_frame)
        self.create_control_panel(right)

    def create_dashboard_widgets(self, parent):
        parent.grid_columnconfigure(0, weight=1); parent.grid_columnconfigure(1, weight=2)
        status_frame = ttk.LabelFrame(parent, text="TRẠNG THÁI HỆ THỐNG", padding=15); status_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=5, padx=5); status_frame.grid_columnconfigure(0, weight=1)
        self.final_status_label = ttk.Label(status_frame, text="CHỜ DỮ LIỆU", font=("Helvetica", 28, "bold"), anchor="center"); self.final_status_label.grid(row=0, column=0, sticky="ew")
        self.summary_text_label = ttk.Label(status_frame, text="Chuyển sang chế độ TỰ ĐỘNG để bắt đầu giám sát.", font=("Helvetica", 11), wraplength=700, justify="center"); self.summary_text_label.grid(row=1, column=0, sticky="ew", pady=(5,0))
        
        primary_frame = ttk.LabelFrame(parent, text="Chỉ số Chính", padding=10); primary_frame.grid(row=1, column=0, sticky="nsew", pady=5, padx=5)
        self.disp_label = ttk.Label(primary_frame, text="Dịch chuyển 3D: -- mm", font=("Arial", 12)); self.disp_label.pack(pady=5, anchor="w")
        self.velo_label = ttk.Label(primary_frame, text="Vận tốc 3D: -- mm/s", font=("Arial", 12)); self.velo_label.pack(pady=5, anchor="w")
        self.water_label = ttk.Label(primary_frame, text="Mực nước: -- m", font=("Arial", 12)); self.water_label.pack(pady=5, anchor="w")
        self.water_roc_label = ttk.Label(primary_frame, text="Tốc độ nước: -- mm/phút", font=("Arial", 12)); self.water_roc_label.pack(pady=5, anchor="w")

        ai_frame = ttk.LabelFrame(parent, text="Phân tích Tình báo", padding=10); ai_frame.grid(row=1, column=1, sticky="nsew", pady=5, padx=5)
        self.threat_score_label = ttk.Label(ai_frame, text="Điểm Rủi ro: --", font=("Arial", 12)); self.threat_score_label.pack(pady=5, anchor="w")
        self.anomaly_label = ttk.Label(ai_frame, text="Điểm Bất thường AI: --", font=("Arial", 12)); self.anomaly_label.pack(pady=5, anchor="w")
        self.sentry_label = ttk.Label(ai_frame, text="Lính canh: --", font=("Arial", 12)); self.sentry_label.pack(pady=5, anchor="w")
        self.velo_class_label = ttk.Label(ai_frame, text="Phân loại IUGS: --", font=("Arial", 12)); self.velo_class_label.pack(pady=5, anchor="w")

    def create_control_panel(self, parent_frame):
        bottom_part = ttk.Frame(parent_frame); bottom_part.grid(row=2, column=0, sticky="ew", pady=(10, 0), padx=5)
        ctrl = ttk.Frame(bottom_part); ctrl.pack(side=tk.TOP, fill=tk.X, expand=True)
        for i in range(4): ctrl.grid_columnconfigure(i, weight=1)
        ttk.Button(ctrl, text="Tự động (ON)", command=self.backend.toggle_on, bootstyle="success").grid(row=0, column=0, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Thủ công (OFF)", command=self.backend.toggle_off, bootstyle="danger").grid(row=0, column=1, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Xóa Lịch sử", command=self.clear_gui_data, bootstyle="warning").grid(row=0, column=2, padx=2, sticky="ew")
        ttk.Button(ctrl, text="Xem Biểu Đồ", command=self.show_chart_window, bootstyle="primary").grid(row=0, column=3, padx=2, sticky="ew")
        led_panel = ttk.LabelFrame(bottom_part, text="Thiết bị & Hệ thống", padding=5); led_panel.pack(side=tk.TOP, fill=tk.X, expand=True, pady=(10, 0))
        led_panel.grid_columnconfigure(0, weight=3); led_panel.grid_columnconfigure(1, weight=1)
        ttk.Button(led_panel, text="Kiểm tra LED", command=self.on_check_led_click).grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        ttk.Button(led_panel, text="Thoát", command=self.exit_program_graceful, bootstyle="secondary-outline").grid(row=0, column=1, padx=5, pady=5, sticky="ew")

    def periodic_update(self):
        if not self.root.winfo_exists(): return
        self.update_status_label()
        new_packets = self.backend.get_gui_updates()
        full_report, latest_hb = None, None
        for p_type, data in new_packets:
            if p_type == "FULL_REPORT": full_report = data
            elif p_type == "HEARTBEAT": latest_hb = data
            elif p_type in ["REQUEST_FOR_CONFIRMATION", "ACTION_RECOMMENDATION"] and not self.interactive_dialog_open: self.handle_interactive_request(data)
            elif p_type == "SYSTEM_NOTIFICATION": messagebox.showinfo(data['title'], data['message'], parent=self.root)
            elif p_type == Constants.DATA_CLEAR_SIGNAL: self.reset_dashboard(); logger.info("GUI đã nhận tín hiệu và xóa hiển thị.")
        if full_report: self.process_full_report(full_report)
        elif latest_hb: self.process_heartbeat(latest_hb)
        self.root.after(250, self.periodic_update)

    def process_full_report(self, report):
        self.backend.latest_full_report = report; ts = datetime.fromtimestamp(report.get('timestamp', time.time()))
        assessment = report.get('final_assessment', {}); status_code = assessment.get('status_code', 'UNKNOWN'); summary = assessment.get('summary_text', 'Mất kết nối...'); threat_score = assessment.get('overall_threat_score', 0)
        primary = report.get('primary_state', {}); disp = primary.get('displacement_3d_mm', 0); velo = primary.get('displacement_velocity_mmps', 0); water = primary.get('water_level_m', 0); water_roc = primary.get('water_level_roc_mm_per_min', 0)
        context = report.get('contextual_analysis', {}); sentry_reason = context.get('sentry_reason', 'N/A')
        ai = report.get('ai_analysis', {}); anomaly_score = ai.get('anomaly_score', 0)
        velo_class_info = primary.get('velocity_class_info', {}); velo_name = velo_class_info.get('name', 'N/A')
        
        color_map = {"SAFE": "#28A745", "MONITOR": "#17A2B8", "WARNING": "#FFC107", "CRITICAL": "#DC3545", "ADAPTING": "#6C757D", "INITIALIZING": "#6C757D"}
        self.final_status_label.config(text=status_code, foreground=color_map.get(status_code, "black")); self.summary_text_label.config(text=summary)
        self.disp_label.config(text=f"Dịch chuyển 3D: {disp:.2f} mm"); self.velo_label.config(text=f"Vận tốc 3D: {velo:.3f} mm/s")
        self.water_label.config(text=f"Mực nước: {water:.3f} m"); self.water_roc_label.config(text=f"Tốc độ nước: {water_roc:.2f} mm/phút")
        self.threat_score_label.config(text=f"Điểm Rủi ro: {threat_score:.0f}"); self.anomaly_label.config(text=f"Điểm Bất thường AI: {anomaly_score:.3f}")
        self.sentry_label.config(text=f"Lính canh: {sentry_reason}"); self.velo_class_label.config(text=f"Phân loại IUGS: {velo_name}")
        
        self.backend.displacement_history.append((ts, disp)); self.backend.water_level_history.append((ts, water)); self.backend.anomaly_score_history.append((ts, anomaly_score)); self.backend.threat_score_history.append((ts, threat_score))

    def process_heartbeat(self, hb):
        status_code = hb.get('status_code', 'UNKNOWN'); disp = hb.get('displacement_3d_mm', 0); water = hb.get('water_level_m', 0)
        self.disp_label.config(text=f"Dịch chuyển 3D: {disp:.2f} mm"); self.water_label.config(text=f"Mực nước: {water:.3f} m")
        color_map = {"SAFE": "#28A745", "MONITOR": "#17A2B8", "WARNING": "#FFC107", "CRITICAL": "#DC3545", "ADAPTING": "#6C757D", "INITIALIZING": "#6C757D"}
        self.final_status_label.config(foreground=color_map.get(status_code, "black"))

    def reset_dashboard(self):
        self.final_status_label.config(text="CHỜ DỮ LIỆU", foreground="black"); self.summary_text_label.config(text="Chuyển sang chế độ TỰ ĐỘNG để bắt đầu giám sát.")
        self.disp_label.config(text="Dịch chuyển 3D: -- mm"); self.velo_label.config(text="Vận tốc 3D: -- mm/s"); self.water_label.config(text="Mực nước: -- m"); self.water_roc_label.config(text="Tốc độ nước: -- mm/phút")
        self.threat_score_label.config(text="Điểm Rủi ro: --"); self.anomaly_label.config(text="Điểm Bất thường AI: --"); self.sentry_label.config(text="Lính canh: --"); self.velo_class_label.config(text="Phân loại IUGS: --")

    def load_initial_data(self):
        self.broker_entry.insert(0, self.backend.broker); self.port_entry.insert(0, str(self.backend.port))
        self.user_entry.insert(0, self.backend.username); self.pass_entry.insert(0, self.backend.password)
        self.water_topic_entry.insert("1.0", "\n".join(self.backend.water_topics)); self.gnss_topic_entry.insert("1.0", "\n".join(self.backend.gnss_topics))
        self.warning_threshold_var.set(str(self.backend.warning_threshold)); self.critical_threshold_var.set(str(self.backend.critical_threshold))

    def apply_and_save_config(self):
        settings = {'broker': self.broker_entry.get(), 'port': self.port_entry.get(), 'username': self.user_entry.get(), 'password': self.pass_entry.get(), 'water_topics': self.water_topic_entry.get("1.0", "end-1c").strip(), 'gnss_topics': self.gnss_topic_entry.get("1.0", "end-1c").strip(), 'warning_threshold': self.warning_threshold_var.get(), 'critical_threshold': self.critical_threshold_var.get()}
        self.backend.update_and_reconnect(settings)
        messagebox.showinfo("Thành công", "Đã lưu và áp dụng cấu hình MQTT. Hệ thống phân tích sẽ khởi động lại nếu đang chạy.", parent=self.root)

    def update_status_label(self):
        text = f"Trạng thái Bộ chỉ huy: {self.backend.status_text}"; style = f"{self.backend.status_color}.Inverse"
        if self.status_label.cget("text") != text or self.status_label.cget("bootstyle") != style:
            self.status_label.config(text=text, bootstyle=style)

    def clear_gui_data(self):
        if messagebox.askokcancel("Xác nhận", "Bạn có chắc muốn xóa toàn bộ lịch sử hiển thị?", parent=self.root): self.backend.clear_all_data()

    def show_chart_window(self): messagebox.showinfo("Sắp ra mắt", "Chức năng biểu đồ nâng cao đang được phát triển!", parent=self.root)
    def on_check_led_click(self):
        if not self.backend.check_leds(): messagebox.showwarning("Cảnh báo", "Chỉ có thể kiểm tra LED ở chế độ THỦ CÔNG (OFF).", parent=self.root)
    def on_close_window(self):
        logger.info("Đã đóng cửa sổ giao diện. Gõ 'show' trong terminal để mở lại."); self.on_close_callback()
        if self.root.winfo_exists(): self.root.destroy()
    def exit_program_graceful(self):
        if messagebox.askokcancel("Xác nhận", "Bạn có chắc muốn thoát hoàn toàn chương trình?", parent=self.root): self.on_close_callback(shutdown=True)

    def open_classification_window(self):
        win = Toplevel(self.root); win.title("Tùy chỉnh Phân loại Tốc độ Dịch chuyển"); win.transient(self.root); win.grab_set()
        entries_frame = ttk.Frame(win, padding=10); entries_frame.pack(fill="x", padx=10, pady=5)
        ttk.Label(entries_frame, text="Tên Phân loại", font='-weight bold').grid(row=0, column=1, padx=5)
        ttk.Label(entries_frame, text="Ngưỡng dưới (mm/s)", font='-weight bold').grid(row=0, column=2, padx=5)
        entry_vars = []
        sorted_table = sorted(self.backend.velocity_classification_table, key=lambda x: x['speed_class'], reverse=True)
        for i, item in enumerate(sorted_table):
            name_var, threshold_var = tk.StringVar(value=item['name']), tk.StringVar(value=str(item['threshold_mmps']))
            entry_vars.append((item['speed_class'], name_var, threshold_var))
            ttk.Label(entries_frame, text=f"Cấp {item['speed_class']}:").grid(row=i+1, column=0, sticky='e', padx=5)
            ttk.Entry(entries_frame, textvariable=name_var).grid(row=i+1, column=1, sticky='ew', padx=5, pady=2)
            ttk.Entry(entries_frame, textvariable=threshold_var).grid(row=i+1, column=2, sticky='ew', padx=5, pady=2)
        button_frame = ttk.Frame(win, padding=10); button_frame.pack(fill="x", side="bottom")
        def on_save():
            try:
                new_table = [{"speed_class": sc, "name": nv.get().strip(), "threshold_mmps": float(tv.get())} for sc, nv, tv in entry_vars]
                self.backend.velocity_classification_table = new_table; self.backend.save_config()
                command = {"type": "CONTROL_COMMAND", "command": "UPDATE_VELOCITY_CLASSIFICATION", "payload": new_table}
                self.backend.send_command_to_shifting(command)
                messagebox.showinfo("Thành công", "Đã lưu và gửi cập nhật bảng phân loại.", parent=win); win.destroy()
            except ValueError: messagebox.showerror("Lỗi", "Ngưỡng vận tốc phải là một con số.", parent=win)
        ttk.Button(button_frame, text="Lưu và Áp dụng", command=on_save, bootstyle="success").pack(side="right", padx=5)
        ttk.Button(button_frame, text="Hủy", command=win.destroy, bootstyle="secondary").pack(side="right", padx=5)

    def handle_interactive_request(self, request_data):
        self.interactive_dialog_open = True
        dialog = Toplevel(self.root); dialog.title(request_data['title']); dialog.transient(self.root); dialog.grab_set()
        message_label = ttk.Label(dialog, text=request_data['message'], wraplength=400, padding=20); message_label.pack()
        button_frame = ttk.Frame(dialog, padding=10); button_frame.pack()
        def on_button_click(option):
            self.backend.send_user_response(request_data, option)
            self.interactive_dialog_open = False; dialog.destroy()
        for option in request_data.get('options', []):
            btn = ttk.Button(button_frame, text=option.replace('_', ' ').title(), command=lambda o=option: on_button_click(o))
            btn.pack(side="left", padx=10)
        dialog.protocol("WM_DELETE_WINDOW", lambda: on_button_click("dismissed"))

# ===========================
# KHỐI ĐIỀU KHIỂN CHÍNH 
# ===========================
class MainController:
    def __init__(self, backend, command_queue):
        self.backend = backend; self.command_queue = command_queue
        self.app_instance = None; self.root = ttk.Window(); self.root.withdraw()
    def run(self): self.check_for_commands(); self.root.mainloop()
    def check_for_commands(self):
        try:
            command = self.command_queue.get_nowait()
            if command == 'show': self.create_gui_window()
            elif command == 'exit': self.handle_shutdown()
            elif command == 'restart': self.handle_restart()
        except queue.Empty: pass
        finally:
            if not self.backend.exiting and self.root.winfo_exists(): self.root.after(100, self.check_for_commands)
    def create_gui_window(self):
        if self.app_instance and self.app_instance.root.winfo_exists(): self.app_instance.root.lift(); return
        logger.info("Đang khởi động giao diện người dùng..."); toplevel = Toplevel(self.root)
        self.app_instance = AppGUI(toplevel, self.backend, self.on_gui_close)
    def on_gui_close(self, shutdown=False):
        self.app_instance = None
        if shutdown: self.command_queue.put('exit')
    def handle_shutdown(self):
        logger.info("Nhận lệnh thoát...")
        if self.app_instance and self.app_instance.root.winfo_exists(): self.app_instance.root.destroy()
        self.backend.exiting = True
        if self.root.winfo_exists(): self.root.destroy()
    def handle_restart(self):
        logger.info("Nhận lệnh khởi động lại..."); global needs_restart; needs_restart = True
        self.handle_shutdown()

# ==============================================================================
# KHỐI THỰC THI CHÍNH (MAIN)
# ==============================================================================
needs_restart = False
command_queue = queue.Queue()
def console_input_listener(cmd_queue: queue.Queue):
    while True:
        try:
            command = input().strip().lower()
            if command: cmd_queue.put(command)
            if command in ['exit', 'restart']: break
        except (EOFError, KeyboardInterrupt): cmd_queue.put('exit'); break
def signal_handler(signum, frame):
    logger.info("\nNhận tín hiệu ngắt (Ctrl+C), đang thoát..."); command_queue.put('exit')
if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal_handler)
    backend_instance = Backend()
    console_thread = threading.Thread(target=console_input_listener, args=(command_queue,), daemon=True); console_thread.start()
    logger.info("="*50); logger.info("Chương trình đã sẵn sàng."); logger.info("Gõ 'show' để mở giao diện, 'exit' để thoát."); logger.info("="*50)
    main_controller = MainController(backend_instance, command_queue)
    command_queue.put('show'); main_controller.run()
    if needs_restart:
        logger.info("\n" + "="*50); logger.info("KHỞI ĐỘNG LẠI CHƯƠNG TRÌNH..."); logger.info("="*50 + "\n")
        try: os.execv(sys.executable, ['python'] + sys.argv)
        except Exception as e: logger.critical(f"LỖI KHÔNG THỂ KHỞI ĐỘNG LẠI: {e}")
    else: logger.info("Chương trình đã kết thúc.")
