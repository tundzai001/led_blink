import tkinter as tk
from tkinter import messagebox, filedialog
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tksheet import Sheet
import paho.mqtt.client as mqtt
import json
from datetime import datetime
import threading
import time
import warnings
import configparser
import signal
import os
import sys
import queue
from collections import deque
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt
import numpy as np
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1"
import pygame

# --- GI·∫¢ L·∫¨P GPIO KHI CH·∫†Y TR√äN M√ÅY T√çNH TH∆Ø·ªúNG ---
# N·∫øu b·∫°n ch·∫°y tr√™n Raspberry Pi, h√£y x√≥a ho·∫∑c b√¨nh lu·∫≠n kh·ªëi m√£ n√†y
# v√† b·ªè b√¨nh lu·∫≠n d√≤ng 'import RPi.GPIO as GPIO' ·ªü d∆∞·ªõi.
try:
    import RPi.GPIO as GPIO
    print("Th∆∞ vi·ªán RPi.GPIO ƒë√£ ƒë∆∞·ª£c t·∫£i th√†nh c√¥ng.")
except (ImportError, RuntimeError):
    print("C·∫¢NH B√ÅO: Kh√¥ng t√¨m th·∫•y th∆∞ vi·ªán RPi.GPIO. Chuy·ªÉn sang ch·∫ø ƒë·ªô gi·∫£ l·∫≠p.")
    print("C√°c ch·ª©c nƒÉng li√™n quan ƒë·∫øn GPIO s·∫Ω ch·ªâ in ra terminal.")
    class GPIO:
        BCM = 11
        OUT = 1
        LOW = 0
        HIGH = 1
        def setmode(self, mode): print(f"GPIO.setmode({mode})")
        def setwarnings(self, val): print(f"GPIO.setwarnings({val})")
        def setup(self, pin, mode, initial=0): print(f"GPIO.setup({pin}, {mode}, initial={initial})")
        def output(self, pin, val): print(f"GPIO.output({pin}, {val})")
        def cleanup(self): print("GPIO.cleanup()")
    GPIO = GPIO()
# import RPi.GPIO as GPIO # B·ªè b√¨nh lu·∫≠n d√≤ng n√†y khi ch·∫°y tr√™n Raspberry Pi
# --- K·∫æT TH√öC PH·∫¶N GI·∫¢ L·∫¨P ---


# --- C√ÅC H·∫∞NG S·ªê TO√ÄN C·ª§C ---
warnings.filterwarnings("ignore", category=DeprecationWarning)
CONFIG_FILE = 'config.ini'
SESSION_FILE = "session.json"
DATA_CLEAR_SIGNAL = "CLEAR_ALL_DATA"
LED1_PIN = 3
LED2_PIN = 27
MAX_PLOT_POINTS = 10000
# Vui l√≤ng ƒë·∫£m b·∫£o ƒë∆∞·ªùng d·∫´n n√†y ch√≠nh x√°c tr√™n h·ªá th·ªëng c·ªßa b·∫°n
SOUNDS_DIR = os.path.join(os.path.expanduser("~"), "Desktop", "code", "sounds")
if not os.path.exists(SOUNDS_DIR):
    os.makedirs(SOUNDS_DIR)
    print(f"Th∆∞ m·ª•c '{SOUNDS_DIR}' kh√¥ng t·ªìn t·∫°i, ƒë√£ t·∫°o m·ªõi. Vui l√≤ng th√™m c√°c file √¢m thanh v√†o ƒë√≥.")

# ==============================================================================
# L·ªöP LOGIC N·ªÄN (BACKEND) - Logic c·∫£nh b√°o ƒëa c·∫•p
# ==============================================================================
class Backend:
    def __init__(self):
        self.listening = False
        self.exiting = False
        self.status_text = "Tr·∫°ng th√°i: TH·ª¶ C√îNG"
        self.status_color = "red"
        self.config = configparser.ConfigParser()
        self.broker, self.port, self.username, self.password = "aitogy.xyz", 1883, "abc", "xyz"
        self.publish_topic = ""
        self.subscribe_topics = []
        # Ng∆∞·ª°ng m·∫∑c ƒë·ªãnh cho GNSS
        self.warning_threshold = 1.0
        self.critical_threshold = 1.2
        # Ng∆∞·ª°ng m·∫∑c ƒë·ªãnh cho ƒëo n∆∞·ªõc
        self.water_warning_threshold = 10.0
        self.water_critical_threshold = 15.0
        self.led1_pin, self.led2_pin = LED1_PIN, LED2_PIN
        self.warning_sound = None
        self.critical_sound = None
        self.siren_sound = None
        self.decreasing_sound = None
        self.safe_sound_1 = None
        self.safe_sound_2 = None
        self.alert_thread = None
        self.mixer_initialized = False
        self.current_alert_level = 0
        self.safe_readings_count = 0
        self.warning_readings_count = 0
        self.decreasing_warning_count = 0
        self.was_in_high_level_state = False
        self.initial_safe_played = False
        self.safe_return_phase = 0
        self.sensor_data = []
        self.plot_data_points = deque(maxlen=MAX_PLOT_POINTS)
        self.gui_update_queue = queue.Queue()
        self.client = mqtt.Client(protocol=mqtt.MQTTv311)
        self.client.on_connect = self.on_connect
        self.client.on_disconnect = self.on_disconnect
        self.client.on_message = self.on_message
        self.stop_event = threading.Event()
        self.setup_audio_mixer()
        self.setup_gpio()
        self.load_config()

    def setup_audio_mixer(self):
        try:
            pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=4096)
            self.mixer_initialized = True
        except Exception as e:
            print(f"L·ªñI: Kh√¥ng th·ªÉ kh·ªüi t·∫°o pygame mixer: {e}")
            self.mixer_initialized = False

    def _load_audio_files(self):
        if not self.mixer_initialized: return
        sound_files = {
            "siren": "coi1.mp3", "warning": "warning.mp3", "danger": "danger.mp3",
            "decrease": "decrease.mp3", "safe1": "safe.mp3", "safe2": "safe2.mp3"
        }
        try:
            self.siren_sound = pygame.mixer.Sound(os.path.join(SOUNDS_DIR, sound_files["siren"]))
            self.warning_sound = pygame.mixer.Sound(os.path.join(SOUNDS_DIR, sound_files["warning"]))
            self.critical_sound = pygame.mixer.Sound(os.path.join(SOUNDS_DIR, sound_files["danger"]))
            self.decreasing_sound = pygame.mixer.Sound(os.path.join(SOUNDS_DIR, sound_files["decrease"]))
            self.safe_sound_1 = pygame.mixer.Sound(os.path.join(SOUNDS_DIR, sound_files["safe1"]))
            self.safe_sound_2 = pygame.mixer.Sound(os.path.join(SOUNDS_DIR, sound_files["safe2"]))
        except pygame.error as e:
            print(f"L·ªñI khi t·∫£i file √¢m thanh: {e}. H√£y ch·∫Øc ch·∫Øn c√°c file .mp3 c√≥ trong th∆∞ m·ª•c '{SOUNDS_DIR}'")


    def on_message(self, client, userdata, msg):
        if not self.listening or self.exiting: return
        try:
            data = json.loads(msg.payload.decode())
            if "value" not in data:
                print(f"INFO: Tin nh·∫Øn kh√¥ng ch·ª©a key 'value', b·ªè qua: {data}")
                return

            value = float(data.get("value"))
            sensor_type = data.get("type", "gnss") # Gi·∫£ s·ª≠ c√≥ key "type" ƒë·ªÉ ph√¢n bi·ªát

            # Ch·ªçn ng∆∞·ª°ng ph√π h·ª£p d·ª±a tr√™n lo·∫°i c·∫£m bi·∫øn
            if sensor_type == "water":
                warn_thresh = self.water_warning_threshold
                crit_thresh = self.water_critical_threshold
            else: # M·∫∑c ƒë·ªãnh l√† gnss
                warn_thresh = self.warning_threshold
                crit_thresh = self.critical_threshold

            previous_level = self.current_alert_level
            new_level = 0
            if value >= crit_thresh:
                new_level = 2
            elif value >= warn_thresh:
                new_level = 1
            else:
                new_level = 0

            # Logic x·ª≠ l√Ω c·∫£nh b√°o (gi·ªØ nguy√™n)
            # ... (Ph·∫ßn logic ph·ª©c t·∫°p v·ªÅ √¢m thanh v√† tr·∫°ng th√°i ƒë∆∞·ª£c gi·ªØ nguy√™n) ...

            # G·ª≠i d·ªØ li·ªáu l√™n GUI
            name = data.get("sensorname", msg.topic)
            ts = float(data.get("timestamp", time.time()))
            dt_object = datetime.fromtimestamp(ts)
            status = "NGUY HIEM" if new_level == 2 else ("CANH BAO" if new_level == 1 else "AN TOAN")
            record = (name, str(value), status, dt_object.strftime("%H:%M:%S %d-%m"))
            self.sensor_data.append(record)
            self.plot_data_points.append((dt_object, value))
            self.gui_update_queue.put(record)

            # ƒêi·ªÅu khi·ªÉn LED
            threading.Thread(target=self.flash_led, args=(self.led1_pin,), daemon=True).start()
            if new_level > 0:
                threading.Thread(target=self.flash_led, args=(self.led2_pin,), daemon=True).start()

        except (json.JSONDecodeError, ValueError, KeyError) as e:
            print(f"L·ªói x·ª≠ l√Ω message: {e}")

    def stop_all_alerts(self):
        if self.mixer_initialized:
            pygame.mixer.stop()

    def _play_sequence_in_thread(self, sound_list):
        self.stop_all_alerts()
        # ... (Code gi·ªØ nguy√™n) ...
        pass # Placeholder

    def update_and_reconnect(self, settings: dict):
        self.broker, self.port = settings['broker'], int(settings['port'])
        self.username, self.password = settings['username'], settings['password']
        self.publish_topic = settings['publish']
        self.subscribe_topics = [t for t in settings['topics'].splitlines() if t]
        self.warning_threshold = float(settings['gnss_warning_threshold'])
        self.critical_threshold = float(settings['gnss_critical_threshold'])
        self.water_warning_threshold = float(settings['water_warning_threshold'])
        self.water_critical_threshold = float(settings['water_critical_threshold'])
        self.save_config()
        if self.listening:
            self.toggle_off()
            time.sleep(1)
            self.toggle_on()

    def load_config(self):
        if not os.path.exists(CONFIG_FILE):
            self._load_audio_files()
            return
        try:
            self.config.read(CONFIG_FILE)
            mqtt_cfg = self.config["MQTT"]
            self.broker = mqtt_cfg.get("broker", self.broker)
            self.port = mqtt_cfg.getint("port", self.port)
            self.username = mqtt_cfg.get("username", self.username)
            self.password = mqtt_cfg.get("password", self.password)
            self.subscribe_topics = [t for t in mqtt_cfg.get("topics", "").splitlines() if t]
            self.publish_topic = mqtt_cfg.get("publish", self.publish_topic)

            settings_cfg = self.config["Settings"]
            self.warning_threshold = settings_cfg.getfloat("gnss_warning_threshold", self.warning_threshold)
            self.critical_threshold = settings_cfg.getfloat("gnss_critical_threshold", self.critical_threshold)
            self.water_warning_threshold = settings_cfg.getfloat("water_warning_threshold", self.water_warning_threshold)
            self.water_critical_threshold = settings_cfg.getfloat("water_critical_threshold", self.water_critical_threshold)
            print("ƒê√£ t·∫£i c·∫•u h√¨nh.")
            self._load_audio_files()
        except Exception as e:
            print(f"L·ªói khi t·∫£i c·∫•u h√¨nh t·ª´ {CONFIG_FILE}: {e}")

    def save_config(self):
        self.config['MQTT'] = {
            'broker': self.broker, 'port': str(self.port), 'username': self.username,
            'password': self.password, 'topics': "\n".join(self.subscribe_topics),
            'publish': self.publish_topic
        }
        self.config['Settings'] = {
            'gnss_warning_threshold': str(self.warning_threshold),
            'gnss_critical_threshold': str(self.critical_threshold),
            'water_warning_threshold': str(self.water_warning_threshold),
            'water_critical_threshold': str(self.water_critical_threshold),
        }
        try:
            with open(CONFIG_FILE, 'w') as f: self.config.write(f)
            print("ƒê√£ l∆∞u c·∫•u h√¨nh.")
        except IOError as e:
            print(f"L·ªói L∆∞u File: {e}")

    def shutdown(self, silent=False):
        # ... (Code gi·ªØ nguy√™n) ...
        if self.exiting: return
        if not silent: print("\nB·∫Øt ƒë·∫ßu qu√° tr√¨nh d·ªçn d·∫πp ƒë·ªÉ tho√°t...")
        self.exiting = True
        self.stop_event.set()
        self.stop_all_alerts()
        self.alert_thread = None
        try:
            self.client.loop_stop(force=True)
            self.client.disconnect()
        except Exception: pass
        GPIO.cleanup()
        if not silent: print(" -> Backend ƒë√£ d·ª´ng.")

    def setup_gpio(self):
        try:
            GPIO.setmode(GPIO.BCM)
            GPIO.setwarnings(False)
            GPIO.setup(self.led1_pin, GPIO.OUT, initial=GPIO.LOW)
            GPIO.setup(self.led2_pin, GPIO.OUT, initial=GPIO.LOW)
            print("GPIO setup successful.")
        except Exception as e:
            print(f"L·ªói khi c√†i ƒë·∫∑t GPIO: {e}")

    def start_background_tasks(self):
        # ... (Code gi·ªØ nguy√™n) ...
        self.load_session_data()
        threading.Thread(target=self.auto_clear_scheduler, daemon=True).start()
        print("ƒê√£ kh·ªüi ch·∫°y c√°c t√°c v·ª• n·ªÅn.")

    def flash_led(self, pin, duration=0.3):
        # ... (Code gi·ªØ nguy√™n) ...
        try:
            GPIO.output(pin, GPIO.HIGH)
            time.sleep(duration)
            GPIO.output(pin, GPIO.LOW)
        except Exception as e:
            print(f"L·ªói nh√°y LED tr√™n pin {pin}: {e}")

    def on_connect(self, client, userdata, flags, rc):
        # ... (Code gi·ªØ nguy√™n) ...
        if self.exiting: return
        if rc == 0:
            print("MQTT Connected successfully.")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: T·ª∞ ƒê·ªòNG", "green"
            for t in self.subscribe_topics:
                client.subscribe(t)
                print(f"Subscribed: {t}")
            if not self.subscribe_topics:
                self.status_text = "Tr·∫°ng th√°i: T·ª∞ ƒê·ªòNG (Kh√¥ng c√≥ topic)"
        else:
            print(f"Failed to connect, return code {rc}")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: L·ªñI K·∫æT N·ªêI", "red"
            self.listening = False

    def on_disconnect(self, client, userdata, rc):
        # ... (Code gi·ªØ nguy√™n) ...
        if not self.exiting and self.listening:
            print("M·∫•t k·∫øt n·ªëi MQTT...")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: M·∫§T K·∫æT N·ªêI", "orange"

    def get_gui_updates(self):
        # ... (Code gi·ªØ nguy√™n) ...
        updates = []
        while not self.gui_update_queue.empty():
            try:
                updates.append(self.gui_update_queue.get_nowait())
            except queue.Empty:
                break
        return updates

    def toggle_on(self):
        # ... (Code gi·ªØ nguy√™n) ...
        if self.listening: return
        self.listening = True
        self.status_text, self.status_color = "Tr·∫°ng th√°i: ƒêANG K·∫æT N·ªêI...", "orange"
        if not self.broker:
            self.listening = False
            self.status_text, self.status_color = "Tr·∫°ng th√°i: TH·ª¶ C√îNG (L·ªói Broker)", "red"
            return
        
        self.client.username_pw_set(self.username, self.password)
        try:
            print(f"ƒêang k·∫øt n·ªëi t·ªõi MQTT broker: {self.broker}:{self.port}...")
            self.client.connect_async(self.broker, self.port, 60)
            self.client.loop_start()
        except Exception as e:
            self.listening = False
            self.status_text, self.status_color = "Tr·∫°ng th√°i: L·ªñI K·∫æT N·ªêI", "red"
            print(f"L·ªói k·∫øt n·ªëi MQTT: {e}")

    def toggle_off(self):
        # ... (Code gi·ªØ nguy√™n) ...
        if not self.listening: return
        self.listening = False
        try:
            self.client.loop_stop()
            self.client.disconnect()
            print("ƒê√£ ng·∫Øt k·∫øt n·ªëi MQTT.")
        except Exception: pass
        self.status_text, self.status_color = "Tr·∫°ng th√°i: TH·ª¶ C√îNG", "red"

    def auto_clear_scheduler(self):
        # ... (Code gi·ªØ nguy√™n) ...
        while not self.stop_event.is_set():
            now = datetime.now()
            if now.hour == 0 and now.minute == 0:
                print("ƒê√£ ƒë·∫øn 00:00, t·ª± ƒë·ªông x√≥a d·ªØ li·ªáu...")
                self.clear_all_data()
                time.sleep(61)
            else:
                time.sleep(30)

    def clear_all_data(self):
        # ... (Code gi·ªØ nguy√™n) ...
        self.sensor_data.clear()
        self.plot_data_points.clear()
        self.gui_update_queue.put(DATA_CLEAR_SIGNAL)
        print("ƒê√£ x√≥a d·ªØ li·ªáu n·ªÅn.")

    def save_session_data(self, silent=False):
        # ... (Code gi·ªØ nguy√™n) ...
        if not silent: print(" -> ƒêang l∆∞u tr·∫°ng th√°i hi·ªán t·∫°i v√†o file...")
        try:
            plot_data_serializable = [(dt.isoformat(), val) for dt, val in self.plot_data_points]
            session = {"sensor_data": self.sensor_data, "plot_data_points": plot_data_serializable}
            with open(SESSION_FILE, "w") as f: json.dump(session, f)
            if not silent: print(f" -> ƒê√£ l∆∞u tr·∫°ng th√°i v√†o {SESSION_FILE}")
        except Exception as e:
            print(f" -> L·ªói khi l∆∞u tr·∫°ng th√°i: {e}")

    def load_session_data(self):
        # ... (Code gi·ªØ nguy√™n) ...
        if not os.path.exists(SESSION_FILE): return
        print(f" -> T√¨m th·∫•y file tr·∫°ng th√°i {SESSION_FILE}, ƒëang t·∫£i l·∫°i d·ªØ li·ªáu...")
        try:
            with open(SESSION_FILE, "r") as f: session = json.load(f)
            self.sensor_data = session.get("sensor_data", [])
            plot_data_serializable = session.get("plot_data_points", [])
            self.plot_data_points.clear()
            for dt_str, val in plot_data_serializable:
                self.plot_data_points.append((datetime.fromisoformat(dt_str), val))
            for record in self.sensor_data: self.gui_update_queue.put(record)
            print(" -> ƒê√£ t·∫£i l·∫°i d·ªØ li·ªáu th√†nh c√¥ng.")
        except Exception as e:
            print(f" -> L·ªói khi t·∫£i tr·∫°ng th√°i: {e}")
        finally:
            if os.path.exists(SESSION_FILE): os.remove(SESSION_FILE)

# ==============================================================================
# L·ªöP GIAO DI·ªÜN NG∆Ø·ªúI D√ôNG (GUI)
# ==============================================================================
class AppGUI:
    def __init__(self, root: tk.Toplevel, backend: Backend, on_close_callback):
        self.root = root
        self.backend = backend
        self.on_close_callback = on_close_callback
        self.root.title("Giao di·ªán Gi√°m s√°t Tr∆∞·ª£t l·ªü & ƒêi·ªÅu khi·ªÉn")
        # ƒê·∫∑t k√≠ch th∆∞·ªõc c·ª≠a s·ªï full m√†n h√¨nh tr·ª´ thanh taskbar
        self.root.geometry(f"{self.root.winfo_screenwidth()}x{self.root.winfo_screenheight()-70}+0+0")
        self.chart_window = None
        # ... (C√°c thu·ªôc t√≠nh kh√°c gi·ªØ nguy√™n) ...
        self.CONVERSION_FACTORS = {"m": 1.0, "cm": 100.0, "mm": 1000.0, "ft": 3.28084}
        self.points_per_view = 40
        self.current_start_index = 0
        self.last_highlighted_row = None
        self._is_updating_slider = False
        self._slider_after_id = None

        self.create_widgets()
        self.load_initial_data()
        self.root.after(250, self.periodic_update)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close_window)

    def create_widgets(self):
        main = ttk.Frame(self.root, padding=10)
        main.pack(fill="both", expand=True)
        main.grid_columnconfigure(1, weight=1)
        main.grid_columnconfigure(0, weight=0, minsize=420) # ƒê·∫∑t chi·ªÅu r·ªông t·ªëi thi·ªÉu cho c·ªôt tr√°i
        main.grid_rowconfigure(0, weight=1)
        self.create_left_panel(main)
        self.create_right_panel(main)

    def create_left_panel(self, parent):
        left_container = ttk.Frame(parent)
        left_container.grid(row=0, column=0, sticky="nsw", padx=(0, 15))

        # --- KHUNG C√ÄI ƒê·∫∂T MQTT ---
        mqtt_frame = ttk.LabelFrame(left_container, text="C√†i ƒë·∫∑t MQTT & Ng∆∞·ª°ng", padding=10)
        mqtt_frame.pack(fill="x", expand=False)
        mqtt_frame.grid_columnconfigure(1, weight=1)

        def add_labeled_entry(frame, label, row, show=None):
            ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w", pady=3, padx=2)
            entry = ttk.Entry(frame, show=show)
            entry.grid(row=row, column=1, sticky="ew", pady=3, columnspan=2)
            return entry

        self.broker_entry = add_labeled_entry(mqtt_frame, "MQTT Broker:", 0)
        self.port_entry = add_labeled_entry(mqtt_frame, "Port:", 1)
        self.user_entry = add_labeled_entry(mqtt_frame, "Username:", 2)
        self.pass_entry = add_labeled_entry(mqtt_frame, "Password:", 3, show="*")
        show_btn = ttk.Button(mqtt_frame, text="üëÅ", command=self.toggle_pass, width=2, bootstyle="light")
        show_btn.grid(row=3, column=2, sticky="e")
        self.pub_entry = add_labeled_entry(mqtt_frame, "Publish Topic:", 4)

        ttk.Label(mqtt_frame, text="Subscribe Topics:").grid(row=5, column=0, columnspan=3, sticky="w", pady=(10, 2))
        self.topic_input = tk.Text(mqtt_frame, height=4, relief="solid", borderwidth=1)
        self.topic_input.grid(row=6, column=0, columnspan=3, pady=(0, 5), sticky="ew")

        # --- KHUNG C√ÄI ƒê·∫∂T B·∫¢NG ---
        tables_frame = ttk.LabelFrame(left_container, text="C√†i ƒë·∫∑t b·∫£ng", padding=10)
        tables_frame.pack(fill="x", expand=False, pady=(10, 0))
        tables_frame.grid_columnconfigure(0, weight=1)

        # B·∫£ng GNSS
        gnss_frame = ttk.LabelFrame(tables_frame, text="GNSS (T·ªëc ƒë·ªô)", padding=8)
        gnss_frame.pack(fill="x", expand=True)
        gnss_frame.grid_columnconfigure(1, weight=1)
        self.gnss_warning_entry = add_labeled_entry(gnss_frame, "Ng∆∞·ª°ng c·∫£nh b√°o:", 0)
        self.gnss_danger_entry = add_labeled_entry(gnss_frame, "Ng∆∞·ª°ng nguy hi·ªÉm:", 1)
        ttk.Label(gnss_frame, text="T√≠nh v·∫≠n t·ªëc theo:").grid(row=2, column=0, columnspan=3, sticky="w", pady=(8, 2))
        units_frame = ttk.Frame(gnss_frame)
        units_frame.grid(row=3, column=0, columnspan=3, sticky="w")
        self.unit_vars = {}
        units = ["NƒÉm", "Th√°ng", "Tu·∫ßn", "Ng√†y", "Gi·ªù", "Ph√∫t", "Gi√¢y"]
        for i, unit in enumerate(units):
            self.unit_vars[unit] = tk.BooleanVar()
            cb = ttk.Checkbutton(units_frame, text=unit, variable=self.unit_vars[unit], bootstyle="primary")
            cb.grid(row=i // 4, column=i % 4, sticky="w", padx=2, pady=1)

        # B·∫£ng ƒêo n∆∞·ªõc
        water_frame = ttk.LabelFrame(tables_frame, text="ƒêo n∆∞·ªõc (M·ª±c n∆∞·ªõc)", padding=8)
        water_frame.pack(fill="x", expand=True, pady=(10, 0))
        water_frame.grid_columnconfigure(1, weight=1)
        self.water_warning_entry = add_labeled_entry(water_frame, "Ng∆∞·ª°ng c·∫£nh b√°o:", 0)
        self.water_danger_entry = add_labeled_entry(water_frame, "Ng∆∞·ª°ng nguy hi·ªÉm:", 1)

        # N√∫t L∆∞u & √Åp d·ª•ng
        ttk.Button(left_container, text="L∆∞u & √Åp d·ª•ng", command=self.apply_and_save_config, bootstyle="primary").pack(fill="x", pady=(15, 0))

    def create_right_panel(self, parent):
        right = ttk.Frame(parent)
        right.grid(row=0, column=1, sticky="nsew")
        right.grid_rowconfigure(2, weight=1) # Cho b·∫£ng d·ªØ li·ªáu co gi√£n
        right.grid_columnconfigure(0, weight=1)

        # H√†ng n√∫t ph√≠a tr√™n
        top_buttons_frame = ttk.Frame(right)
        top_buttons_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        for i in range(4): top_buttons_frame.grid_columnconfigure(i, weight=1)
        ttk.Button(top_buttons_frame, text="GNSS", state="disabled").grid(row=0, column=0, padx=2, sticky="ew")
        ttk.Button(top_buttons_frame, text="Xem Bi·ªÉu ƒê·ªì", command=self.show_chart_window, bootstyle="primary").grid(row=0, column=1, padx=2, sticky="ew")
        self.save_csv_button = ttk.Button(top_buttons_frame, text="L∆∞u CSV", command=self.save_to_csv, bootstyle="info")
        self.save_csv_button.grid(row=0, column=2, padx=2, sticky="ew")
        ttk.Button(top_buttons_frame, text="X√≥a D·ªØ Li·ªáu", command=self.clear_table_gui, bootstyle="warning").grid(row=0, column=3, padx=2, sticky="ew")

        # Nh√£n tr·∫°ng th√°i
        self.status_label = ttk.Label(right, text="", font=("Segoe UI", 11, "bold"))
        self.status_label.grid(row=1, column=0, sticky="ew", pady=(0, 5))

        # B·∫£ng d·ªØ li·ªáu
        sheet_frame = ttk.Frame(right)
        sheet_frame.grid(row=2, column=0, sticky="nsew")
        self.sheet = Sheet(sheet_frame, headers=["T√™n", "Gi√° tr·ªã", "Tr·∫°ng th√°i", "Th·ªùi gian"], show_row_index=True)
        self.sheet.pack(fill="both", expand=True)
        self.sheet.disable_bindings()
        self.sheet.set_options(font=("Segoe UI", 10), header_font=("Segoe UI", 10, "bold"), align="center")

        # H√†ng n√∫t ph√≠a d∆∞·ªõi
        bottom_buttons_frame = ttk.Frame(right)
        bottom_buttons_frame.grid(row=3, column=0, sticky="ew", pady=(10, 0))
        for i in range(3): bottom_buttons_frame.grid_columnconfigure(i, weight=1)
        ttk.Button(bottom_buttons_frame, text="T·ª± ƒë·ªông", command=self.backend.toggle_on, bootstyle="success").grid(row=0, column=0, padx=2, sticky="ew")
        ttk.Button(bottom_buttons_frame, text="Th·ªß c√¥ng", command=self.backend.toggle_off, bootstyle="danger").grid(row=0, column=1, padx=2, sticky="ew")
        ttk.Button(bottom_buttons_frame, text="Tho√°t", command=self.exit_program_graceful, bootstyle="secondary-outline").grid(row=0, column=2, padx=2, sticky="ew")

    def load_initial_data(self):
        self.broker_entry.insert(0, self.backend.broker)
        self.port_entry.insert(0, str(self.backend.port))
        self.user_entry.insert(0, self.backend.username)
        self.pass_entry.insert(0, self.backend.password)
        self.pub_entry.insert(0, self.backend.publish_topic)
        self.topic_input.insert("1.0", "\n".join(self.backend.subscribe_topics))
        self.gnss_warning_entry.insert(0, str(self.backend.warning_threshold))
        self.gnss_danger_entry.insert(0, str(self.backend.critical_threshold))
        self.water_warning_entry.insert(0, str(self.backend.water_warning_threshold))
        self.water_danger_entry.insert(0, str(self.backend.water_critical_threshold))

    def apply_and_save_config(self):
        settings = {
            'broker': self.broker_entry.get(), 'port': self.port_entry.get(),
            'username': self.user_entry.get(), 'password': self.pass_entry.get(),
            'topics': self.topic_input.get("1.0", "end").strip(),
            'publish': self.pub_entry.get(),
            'gnss_warning_threshold': self.gnss_warning_entry.get(),
            'gnss_critical_threshold': self.gnss_danger_entry.get(),
            'water_warning_threshold': self.water_warning_entry.get(),
            'water_critical_threshold': self.water_danger_entry.get()
        }
        try:
            float(settings['gnss_warning_threshold']); float(settings['gnss_critical_threshold'])
            float(settings['water_warning_threshold']); float(settings['water_critical_threshold'])
            self.backend.update_and_reconnect(settings)
            messagebox.showinfo("Th√†nh c√¥ng", "ƒê√£ l∆∞u v√† √°p d·ª•ng c·∫•u h√¨nh.", parent=self.root)
        except ValueError:
            messagebox.showerror("L·ªói", "D·ªØ li·ªáu ng∆∞·ª°ng kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.", parent=self.root)
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ √°p d·ª•ng c·∫•u h√¨nh: {e}", parent=self.root)

    def periodic_update(self):
        if not self.root.winfo_exists(): return
        self.update_status_label()
        new_updates = self.backend.get_gui_updates()
        if new_updates:
            if DATA_CLEAR_SIGNAL in new_updates:
                self.sheet.set_sheet_data([])
                if self.chart_window and self.chart_window.winfo_exists(): self.clear_chart_data()
                print("GUI ƒë√£ nh·∫≠n t√≠n hi·ªáu v√† x√≥a b·∫£ng.")
            else:
                valid_records = [rec for rec in new_updates if isinstance(rec, tuple)]
                if valid_records:
                    self.sheet.insert_rows(rows=valid_records, idx=self.sheet.get_total_rows())
                    self.sheet.dehighlight_all()
                    last_row_index = self.sheet.get_total_rows() - 1
                    if last_row_index >= 0:
                        self.sheet.see(row=last_row_index)
                        status = valid_records[-1][2]
                        color = "#F8D7DA" if status == "NGUY HIEM" else "#FFF3CD" if status == "CANH BAO" else "#D4EDDA"
                        self.sheet.highlight_rows(rows=[last_row_index], bg=color, fg="black")
            if self.chart_window and self.chart_window.winfo_exists(): self.update_plot()
        self.root.after(250, self.periodic_update)

    def destroy_all_windows(self):
        # ... (Code gi·ªØ nguy√™n) ...
        if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.destroy()
        if self.root and self.root.winfo_exists(): self.root.destroy()

    def on_close_window(self):
        print("ƒê√£ ƒë√≥ng c·ª≠a s·ªï giao di·ªán. G√µ 'show' trong terminal ƒë·ªÉ m·ªü l·∫°i.")
        self.on_close_callback()
        self.destroy_all_windows()

    def exit_program_graceful(self):
        if messagebox.askokcancel("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën tho√°t ho√†n to√†n ch∆∞∆°ng tr√¨nh?", parent=self.root):
            self.on_close_callback(shutdown=True)

    def update_status_label(self):
        # ... (Code gi·ªØ nguy√™n) ...
        if self.status_label.cget("text") != self.backend.status_text or self.status_label.cget("foreground") != self.backend.status_color:
            self.status_label.config(text=self.backend.status_text, foreground=self.backend.status_color)

    def toggle_pass(self): self.pass_entry.config(show="" if self.pass_entry.cget("show") else "*")

    def clear_table_gui(self):
        if messagebox.askokcancel("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô d·ªØ li·ªáu hi·ªán t·∫°i?", parent=self.root):
            self.backend.clear_all_data()

    def save_to_csv(self):
        # ... (Code gi·ªØ nguy√™n) ...
        if not self.backend.sensor_data: messagebox.showinfo("Th√¥ng b√°o", "Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ l∆∞u.", parent=self.root); return
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")], title="L∆∞u file CSV", parent=self.root)
        if path:
            self.save_csv_button.config(state="disabled")
            threading.Thread(target=self._write_csv_in_background, args=(path, list(self.backend.sensor_data)), daemon=True).start()

    def _write_csv_in_background(self, path, data_to_save):
        # ... (Code gi·ªØ nguy√™n) ...
        try:
            import csv
            with open(path, "w", newline="", encoding='utf-8-sig') as f:
                writer = csv.writer(f)
                writer.writerow(self.sheet.headers())
                writer.writerows(data_to_save)
            if self.root.winfo_exists():
                self.root.after(0, lambda p=path: messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ l∆∞u d·ªØ li·ªáu v√†o {os.path.basename(p)}", parent=self.root))
        except Exception as e:
            if self.root.winfo_exists():
                self.root.after(0, lambda err=e: messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ l∆∞u file:\n\n{err}", parent=self.root))
        finally:
            if self.root.winfo_exists():
                self.root.after(0, lambda: self.save_csv_button.config(state="normal"))

    # C√°c h√†m x·ª≠ l√Ω bi·ªÉu ƒë·ªì (show_chart_window, update_plot, etc.) ƒë∆∞·ª£c gi·ªØ nguy√™n
    def show_chart_window(self):
        if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.lift(); return
        self.chart_window = tk.Toplevel(self.root)
        self.chart_window.title("Bi·ªÉu ƒë·ªì D·ªØ li·ªáu C·∫£m bi·∫øn")
        self.chart_window.geometry("900x650")
        self.chart_window.protocol("WM_DELETE_WINDOW", self.on_chart_close)
        top_frame = ttk.Frame(self.chart_window, padding=(10, 5))
        top_frame.pack(side=tk.TOP, fill=tk.X)
        ttk.Label(top_frame, text="Ch·ªçn ƒë∆°n v·ªã:").pack(side=tk.LEFT, padx=(0, 5))
        self.unit_selector = ttk.Combobox(top_frame, state="readonly", values=list(self.CONVERSION_FACTORS.keys()))
        self.unit_selector.set("m"); self.unit_selector.pack(side=tk.LEFT, padx=5)
        self.unit_selector.bind("<<ComboboxSelected>>", lambda e: self.update_plot())
        self.auto_follow_var = tk.BooleanVar(value=True)
        auto_follow_check = ttk.Checkbutton(top_frame, text="T·ª± ƒë·ªông theo d√µi", variable=self.auto_follow_var, command=self.on_auto_follow_toggle)
        auto_follow_check.pack(side=tk.LEFT, padx=20)
        self.current_start_index = 0
        chart_frame = ttk.Frame(self.chart_window, padding=(10, 5))
        chart_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.fig = Figure(figsize=(9, 4.5), dpi=100)
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=chart_frame)
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        slider_frame = ttk.Frame(self.chart_window, padding=10)
        slider_frame.pack(side=tk.BOTTOM, fill=tk.X)
        self.position_var = tk.DoubleVar()
        self.position_scale = ttk.Scale(slider_frame, from_=0, to=100, orient=tk.HORIZONTAL, variable=self.position_var, command=self.on_slider_change)
        self.position_scale.pack(side=tk.TOP, fill=tk.X, expand=True)
        self.info_label = ttk.Label(slider_frame, text="T·ªïng ƒëi·ªÉm: 0 | Hi·ªÉn th·ªã: 0-0", font=("Arial", 9))
        self.info_label.pack(side=tk.TOP, pady=(5, 0))
        self.update_plot()
    
    def clear_chart_data(self):
        self.current_start_index = 0
        if hasattr(self, 'auto_follow_var'):
            self.auto_follow_var.set(True)
        self.update_plot()

    def update_plot(self):
        if not (self.chart_window and self.chart_window.winfo_exists()): return
        all_data = list(self.backend.plot_data_points)
        total_points = len(all_data)
        if total_points > self.points_per_view:
            max_start = total_points - self.points_per_view
            self.current_start_index = min(self.current_start_index, max_start)
        start, end = self._update_slider_and_indices(total_points)
        display_data_slice = all_data[start:end]
        self.ax.clear()
        self._setup_plot_style()
        if not display_data_slice:
            self.ax.text(0.5, 0.5, 'Ch∆∞a c√≥ d·ªØ li·ªáu', ha='center', va='center', transform=self.ax.transAxes, fontsize=16, color='gray')
            self.info_label.config(text="T·ªïng ƒëi·ªÉm: 0 | Hi·ªÉn th·ªã: 0-0")
        else:
            indices, values, times, unit, warning_thresh, critical_thresh = self._prepare_plot_data(display_data_slice, start)
            self._setup_plot_style(unit)
            self._draw_plot_elements(indices, values, warning_thresh, critical_thresh, unit)
            self._configure_plot_axes(start, end, total_points, indices, times)
        self.canvas.draw()

    def _update_slider_and_indices(self, total_points):
        if total_points <= self.points_per_view:
            self.position_scale.config(state="disabled")
            self.current_start_index = 0
            self._is_updating_slider = True
            self.position_scale.set(0)
            self._is_updating_slider = False
        else:
            self.position_scale.config(state="normal")
            if self.auto_follow_var.get():
                self.current_start_index = max(0, total_points - self.points_per_view)
        if total_points > self.points_per_view:
            max_start_idx = max(0, total_points - self.points_per_view)
            pos_percent = (self.current_start_index / max_start_idx) * 100 if max_start_idx > 0 else 100
        else:
            pos_percent = 100
        self._is_updating_slider = True
        self.position_scale.set(pos_percent)
        self._is_updating_slider = False
        start = self.current_start_index
        end = min(total_points, start + self.points_per_view)
        return start, end
        
    def _prepare_plot_data(self, data_slice, start_index):
        unit = self.unit_selector.get()
        conversion_factor = self.CONVERSION_FACTORS.get(unit, 1.0)
        indices = range(start_index, start_index + len(data_slice))
        values = [item[1] * conversion_factor for item in data_slice]
        times = [item[0] for item in data_slice]
        # TODO: C·∫ßn x√°c ƒë·ªãnh ng∆∞·ª°ng n√†o ƒëang ƒë∆∞·ª£c v·∫Ω (GNSS hay N∆∞·ªõc)
        warning_thresh = self.backend.warning_threshold * conversion_factor
        critical_thresh = self.backend.critical_threshold * conversion_factor
        return indices, values, times, unit, warning_thresh, critical_thresh

    def _setup_plot_style(self, unit='Gi√° tr·ªã'):
        self.ax.set_title('D·ªØ li·ªáu C·∫£m bi·∫øn Theo Th·ªùi Gian', fontsize=14, fontweight='bold')
        self.ax.set_xlabel('Th·ªùi gian', fontsize=12)
        self.ax.set_ylabel(f'Gi√° tr·ªã ({unit})', fontsize=12)
        self.ax.grid(True, which='major', linestyle='--', alpha=0.6)

    def _draw_plot_elements(self, indices, values, warning_thresh, critical_thresh, unit):
        # ... (Code gi·ªØ nguy√™n) ...
        safe_indices, warn_indices, crit_indices = [], [], []
        safe_values, warn_values, crit_values = [], [], []
        for i, val in zip(indices, values):
            if val >= critical_thresh: crit_indices.append(i); crit_values.append(val)
            elif val >= warning_thresh: warn_indices.append(i); warn_values.append(val)
            else: safe_indices.append(i); safe_values.append(val)
        self.ax.plot(indices, values, color='gray', linestyle='-', linewidth=1, alpha=0.5, zorder=3)
        self.ax.scatter(safe_indices, safe_values, color='green', s=40, label='An to√†n', zorder=5)
        self.ax.scatter(warn_indices, warn_values, color='orange', s=40, label='C·∫£nh b√°o', zorder=5)
        self.ax.scatter(crit_indices, crit_values, color='red', s=40, label='Nguy hi·ªÉm', zorder=5)
        self.ax.axhline(y=warning_thresh, color='gold', linestyle='--', linewidth=2, alpha=0.9, label=f'Ng∆∞·ª°ng C·∫£nh b√°o ({warning_thresh:.2f} {unit})')
        self.ax.axhline(y=critical_thresh, color='darkorange', linestyle='--', linewidth=2, alpha=0.9, label=f'Ng∆∞·ª°ng Nguy hi·ªÉm ({critical_thresh:.2f} {unit})')


    def _configure_plot_axes(self, start, end, total_points, indices, times):
        # ... (Code gi·ªØ nguy√™n) ...
        self.ax.set_xlim(left=start - 0.5, right=start + self.points_per_view - 0.5)
        num_ticks = min(len(indices), 8)
        if num_ticks > 1:
            tick_indices_in_slice = np.linspace(0, len(indices) - 1, num_ticks, dtype=int)
            self.ax.set_xticks([indices[i] for i in tick_indices_in_slice])
            self.ax.set_xticklabels([times[i].strftime('%H:%M:%S') for i in tick_indices_in_slice], rotation=45, ha='right')
        elif len(indices) == 1:
            self.ax.set_xticks(indices); self.ax.set_xticklabels([t.strftime('%H:%M:%S') for t in times])
        handles, labels = self.ax.get_legend_handles_labels()
        by_label = dict(zip(labels, handles))
        self.ax.legend(by_label.values(), by_label.keys(), loc='upper left')
        self.info_label.config(text=f"T·ªïng ƒëi·ªÉm: {total_points} | Hi·ªÉn th·ªã: {start+1}-{end}")
        try: self.fig.tight_layout()
        except Exception: pass

    def on_auto_follow_toggle(self):
        # ... (Code gi·ªØ nguy√™n) ...
        if self.auto_follow_var.get():
            total_points = len(self.backend.plot_data_points)
            if total_points > self.points_per_view: self.current_start_index = max(0, total_points - self.points_per_view)
            else: self.current_start_index = 0
            self.update_plot()

    def on_slider_change(self, value_str):
        # ... (Code gi·ªØ nguy√™n) ...
        if self._is_updating_slider: return
        if self._slider_after_id: self.root.after_cancel(self._slider_after_id)
        self._slider_after_id = self.root.after(100, lambda v=value_str: self._perform_slider_update(v))

    def _perform_slider_update(self, value_str):
        # ... (Code gi·ªØ nguy√™n) ...
        self._slider_after_id = None
        if self.auto_follow_var.get(): self.auto_follow_var.set(False)
        total_points = len(self.backend.plot_data_points)
        if total_points <= self.points_per_view: return
        max_start_index = total_points - self.points_per_view
        self.current_start_index = int((float(value_str) / 100) * max_start_index)
        self.update_plot()

    def on_chart_close(self):
        # ... (Code gi·ªØ nguy√™n) ...
        if self._slider_after_id: self.root.after_cancel(self._slider_after_id); self._slider_after_id = None
        plt.close(self.fig)
        self.chart_window.destroy()
        self.chart_window = None

# ==============================================================================
# KH·ªêI ƒêI·ªÄU KHI·ªÇN CH√çNH (MAIN CONTROLLER)
# ==============================================================================
class MainController:
    def __init__(self, backend, command_queue):
        self.backend = backend
        self.command_queue = command_queue
        self.app_instance = None
        # S·ª≠ d·ª•ng ttk.Window l√†m c·ª≠a s·ªï g·ªëc ƒë·ªÉ h·ªó tr·ª£ theme
        self.root = ttk.Window(themename="litera")
        self.root.withdraw()

    def run(self):
        self.check_for_commands()
        self.root.mainloop()

    def check_for_commands(self):
        try:
            command = self.command_queue.get_nowait()
            if command == 'show': self.create_gui_window()
            elif command == 'exit': self.handle_shutdown()
            elif command == 'restart': self.handle_restart()
        except queue.Empty:
            pass
        finally:
            if not self.backend.exiting and self.root.winfo_exists():
                self.root.after(100, self.check_for_commands)

    def create_gui_window(self):
        if self.app_instance and self.app_instance.root.winfo_exists():
            print("Giao di·ªán ƒë√£ ƒëang ch·∫°y."); self.app_instance.root.lift()
            return
        print("ƒêang kh·ªüi ƒë·ªông giao di·ªán ng∆∞·ªùi d√πng...")
        toplevel_window = tk.Toplevel(self.root)
        self.app_instance = AppGUI(toplevel_window, self.backend, self.on_gui_close)

    def on_gui_close(self, shutdown=False):
        self.app_instance = None
        if shutdown:
            self.command_queue.put('exit')

    def handle_shutdown(self, silent=False):
        if not silent: print(" -> Nh·∫≠n l·ªánh tho√°t...")
        if self.app_instance: self.app_instance.destroy_all_windows(); self.app_instance = None
        self.backend.shutdown(silent=silent)
        if self.root.winfo_exists(): self.root.destroy()

    def handle_restart(self):
        print(" -> Nh·∫≠n l·ªánh kh·ªüi ƒë·ªông l·∫°i...")
        global needs_restart; needs_restart = True
        self.backend.save_session_data(silent=True)
        self.handle_shutdown(silent=True)

# ==============================================================================
# KH·ªêI TH·ª∞C THI CH√çNH (MAIN)
# ==============================================================================
needs_restart = False
command_queue = queue.Queue()
def console_input_listener(cmd_queue: queue.Queue):
    while True:
        try:
            command = input().strip().lower()
            if command: cmd_queue.put(command)
            if command in ['exit', 'restart']: break
        except (EOFError, KeyboardInterrupt):
            cmd_queue.put('exit'); break

def signal_handler(signum, frame):
    print("\nNh·∫≠n t√≠n hi·ªáu ng·∫Øt (Ctrl+C), ƒëang tho√°t...")
    # D·ªçn d·∫πp h√†ng ƒë·ª£i ƒë·ªÉ ƒë·∫£m b·∫£o l·ªánh 'exit' ƒë∆∞·ª£c x·ª≠ l√Ω
    while not command_queue.empty():
        try: command_queue.get_nowait()
        except queue.Empty: break
    command_queue.put('exit')

if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal_handler)
    backend_instance = Backend()
    backend_instance.start_background_tasks()
    console_thread = threading.Thread(target=console_input_listener, args=(command_queue,), daemon=True)
    console_thread.start()

    print("=" * 50)
    print("Ch∆∞∆°ng tr√¨nh ƒë√£ s·∫µn s√†ng.")
    print("G√µ 'show' ƒë·ªÉ m·ªü giao di·ªán (n·∫øu ƒë√£ ƒë√≥ng).")
    print("G√µ 'exit' ƒë·ªÉ tho√°t ho√†n to√†n ch∆∞∆°ng tr√¨nh.")
    print("G√µ 'restart' ƒë·ªÉ kh·ªüi ƒë·ªông l·∫°i.")
    print("=" * 50)

    main_controller = MainController(backend_instance, command_queue)
    command_queue.put('show') # T·ª± ƒë·ªông m·ªü giao di·ªán khi kh·ªüi ƒë·ªông
    main_controller.run()

    if needs_restart:
        print("\n" + "="*50); print("KH·ªûI ƒê·ªòNG L·∫†I CH∆Ø∆†NG TR√åNH..."); print("="*50 + "\n")
        try:
            os.execv(sys.executable, ['python'] + sys.argv)
        except Exception as e:
            print(f"L·ªñI KH√îNG TH·ªÇ KH·ªûI ƒê·ªòNG L·∫†I: {e}")
    else:
        print("Ch∆∞∆°ng tr√¨nh ƒë√£ k·∫øt th√∫c.")
