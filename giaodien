import tkinter as tk
from tkinter import messagebox, filedialog, Toplevel
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tksheet import Sheet
import paho.mqtt.client as mqtt
import json
from datetime import datetime
import threading
import time
import warnings
import configparser
import signal
import os
import sys
import queue
from collections import deque
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt
import numpy as np
import logging
from logging.handlers import TimedRotatingFileHandler
import atexit
import subprocess
import math
import traceback

# --- THIẾT LẬP MÔI TRƯỜỜNG VÀ CẢNH BÁO ---
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1"
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", message="Unable to import Axes3D")

# --- CÁC THƯ VIỆN ĐẶC THÙ PI ---
try:
    import RPi.GPIO as GPIO
    import pygame
    IS_PI = True
except (ImportError, RuntimeError):
    IS_PI = False
    print("CẢNH BÁO: Không tìm thấy thư viện RPi.GPIO hoặc pygame. Chương trình sẽ chạy ở chế độ không có phần cứng (no-hardware mode).")

# --- Cấu hình logging nâng cao ---
LOG_DIRECTORY = "sensor_monitor"
os.makedirs(LOG_DIRECTORY, exist_ok=True)
logger = logging.getLogger()
logger.setLevel(logging.INFO)
if not logger.handlers:
    file_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    console_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    log_file_path = os.path.join(LOG_DIRECTORY, 'sensor_monitor.log')
    file_handler = TimedRotatingFileHandler(log_file_path, when='midnight', interval=1, backupCount=30, encoding='utf-8')
    file_handler.setLevel(logging.INFO)
    file_handler.setFormatter(file_formatter)
    logger.addHandler(file_handler)
    error_log_file_path = os.path.join(LOG_DIRECTORY, 'sensor_monitor_error.log')
    error_file_handler = TimedRotatingFileHandler(error_log_file_path, when='midnight', interval=1, backupCount=30, encoding='utf-8')
    error_file_handler.setLevel(logging.ERROR)
    error_file_handler.setFormatter(file_formatter)
    logger.addHandler(error_file_handler)
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)

# ==============================================================================
# QUẢN LÝ HẰNG SỐ
# ==============================================================================
class Constants:
    CONFIG_FILE = 'config.ini'
    SESSION_FILE = "session.json"
    DEFAULT_SOUNDS_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "sounds")
    SIREN_RELAY_PIN = 5
    MAX_PLOT_POINTS = 10000
    MAX_SENSOR_RECORDS = 10000
    CHART_POINTS_PER_VIEW = 40
    WARNING_REPEAT_SECONDS = 60
    DECREASING_REPEAT_SECONDS = 100
    SAFE_READINGS_REQUIRED_INITIAL = 10
    SAFE_READINGS_REQUIRED_RETURN_1 = 10
    SAFE_READINGS_REQUIRED_RETURN_2 = 15

# ==============================================================================
# CÁC HÀM TIỆN ÍCH
# ==============================================================================
def haversine_3d(p1, p2):
    R = 6371000
    lat1, lon1, h1 = p1.get("lat"), p1.get("lon"), p1.get("h")
    lat2, lon2, h2 = p2.get("lat"), p2.get("lon"), p2.get("h")
    if any(v is None for v in [lat1, lon1, h1, lat2, lon2, h2]): return float('inf')
    lat1_rad, lon1_rad, lat2_rad, lon2_rad = map(math.radians, [lat1, lon1, lat2, lon2])
    dlat = lat2_rad - lat1_rad; dlon = lon2_rad - lon1_rad
    a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2
    dist_2d = R * 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    return math.sqrt(dist_2d**2 + (h2 - h1)**2)

# ==============================================================================
# QUẢN LÝ CẢNH BÁO ĐA KÊNH VỚI MÁY TRẠNG THÁI CON
# ==============================================================================
class WaterStateMachine:
    def __init__(self, alert_manager):
        self.alert_manager = alert_manager; self.backend = alert_manager.backend
        self.current_level = 0; self.safe_readings_count = 0; self.warning_readings_count = 0
        self.decreasing_warning_count = 0; self.was_in_high_level_state = False
        self.initial_safe_played = False; self.safe_return_phase = 0

    def process_new_value(self, value):
        previous_level = self.current_level
        new_level = self._calculate_alert_level(value)
        if new_level != previous_level: logger.info(f"[Water SM] Chuyển trạng thái {previous_level} -> {new_level}")
        action_request = None
        if new_level == 0: action_request = self._handle_safe_state()
        elif new_level == 1: action_request = self._handle_warning_state(previous_level)
        elif new_level == 2: action_request = self._handle_critical_state()
        self.current_level = new_level
        if action_request: self.alert_manager.request_action(action_request)
        return new_level

    def _calculate_alert_level(self, value):
        if self.backend.critical_threshold is not None and value >= self.backend.critical_threshold: return 2
        elif self.backend.warning_threshold is not None and value >= self.backend.warning_threshold: return 1
        return 0

    def _handle_safe_state(self):
        self.warning_readings_count, self.decreasing_warning_count = 0, 0
        self.safe_readings_count += 1
        if not self.was_in_high_level_state:
            if not self.initial_safe_played and self.safe_readings_count == Constants.SAFE_READINGS_REQUIRED_INITIAL:
                logger.info("[Water SM] Đạt 10 lần đo an toàn ban đầu."); return "SAFE_INITIAL"
        else:
            if self.safe_return_phase == 0: self.safe_return_phase = 1
            if self.safe_return_phase == 1 and self.safe_readings_count == Constants.SAFE_READINGS_REQUIRED_RETURN_1:
                logger.info("[Water SM] Trở về an toàn, đạt 10 lần đo."); self.safe_return_phase = 2; return "SAFE_RETURN_1"
            elif self.safe_return_phase == 2 and self.safe_readings_count == Constants.SAFE_READINGS_REQUIRED_RETURN_2:
                logger.info("[Water SM] Trở về an toàn, đạt 15 lần đo.")
                self.was_in_high_level_state, self.initial_safe_played, self.safe_return_phase = False, True, 0
                return "SAFE_RETURN_2"
        return None

    def _handle_warning_state(self, previous_level):
        self.safe_readings_count, self.safe_return_phase = 0, 0
        self.was_in_high_level_state = True
        if previous_level == 0:
            logger.info("[Water SM] Mực nước TĂNG lên mức Cảnh báo.")
            self.warning_readings_count, self.decreasing_warning_count = 1, 0
            return "WATER_WARN_RISING"
        elif previous_level == 2:
            logger.info("[Water SM] Mực nước GIẢM xuống mức Cảnh báo.")
            self.decreasing_warning_count, self.warning_readings_count = 1, 0
            return "WATER_WARN_DECREASING"
        elif previous_level == 1:
            if self.warning_readings_count > 0:
                self.warning_readings_count += 1
                if self.warning_readings_count % Constants.WARNING_REPEAT_INTERVAL == 0:
                    logger.info(f"[Water SM] Lặp lại cảnh báo TĂNG lần thứ {self.warning_readings_count}."); return "WATER_WARN_RISING"
            elif self.decreasing_warning_count > 0:
                self.decreasing_warning_count += 1
                if self.decreasing_warning_count % Constants.DECREASING_REPEAT_INTERVAL == 0:
                    logger.info(f"[Water SM] Lặp lại cảnh báo GIẢM lần thứ {self.decreasing_warning_count}."); return "WATER_WARN_DECREASING"
        return None

    def _handle_critical_state(self):
        self.safe_readings_count, self.warning_readings_count, self.decreasing_warning_count, self.safe_return_phase = 0, 0, 0, 0
        self.was_in_high_level_state = True; logger.critical("[Water SM] Mực nước ở mức NGUY HIỂM."); return "WATER_CRITICAL"

class GnssStateMachine:
    def __init__(self, alert_manager):
        self.alert_manager = alert_manager; self.backend = alert_manager.backend
        self.current_level = 0; self.moderate_readings_count = 0
        self.safe_readings_count = 0; self.was_in_high_level_state = False

    def process_new_report(self, report):
        classification_name = report.get('classification_name', 'N/A').lower()
        previous_level = self.current_level; new_level = 0
        if "rapid" in classification_name: new_level = 3 if "extremely" in classification_name or "very" in classification_name else 2
        elif "moderate" in classification_name: new_level = 1
        if new_level != previous_level: logger.info(f"[GNSS SM] Chuyển trạng thái {previous_level} -> {new_level} (Phân loại: {report.get('classification_name', 'N/A')})")
        action_request = None
        if new_level == 0: action_request = self._handle_safe_state()
        elif new_level == 1: action_request = self._handle_moderate_state(previous_level)
        elif new_level >= 2: action_request = self._handle_rapid_state()
        self.current_level = new_level
        if action_request: self.alert_manager.request_action(action_request)

    def _handle_safe_state(self):
        self.moderate_readings_count = 0
        if self.was_in_high_level_state:
            self.safe_readings_count += 1
            if self.safe_readings_count >= 10:
                logger.info("[GNSS SM] Trở về an toàn, đạt 10 lần đo.")
                self.was_in_high_level_state = False; self.safe_readings_count = 0; return "SAFE_RETURN_GNSS"
        return None

    def _handle_moderate_state(self, previous_level):
        self.safe_readings_count = 0; self.was_in_high_level_state = True
        if previous_level == 0:
            logger.info("[GNSS SM] Dịch chuyển TĂNG lên mức Vừa.")
            self.moderate_readings_count = 1; return "GNSS_WARN"
        elif previous_level == 1:
             self.moderate_readings_count += 1
             if self.moderate_readings_count % 4 == 0:
                logger.info(f"[GNSS SM] Lặp lại cảnh báo Vừa lần thứ {self.moderate_readings_count}."); return "GNSS_WARN"
        return None

    def _handle_rapid_state(self):
        self.safe_readings_count, self.moderate_readings_count = 0, 0
        self.was_in_high_level_state = True; logger.critical("[GNSS SM] Dịch chuyển ở mức NHANH hoặc cao hơn."); return "GNSS_CRITICAL"

class AlertManager:
    def __init__(self, backend_ref):
        self.backend = backend_ref
        self.water_sm = WaterStateMachine(self); self.gnss_sm = GnssStateMachine(self)
        self.active_alert_name = "SAFE"; self.alert_thread = None
        self.ALERT_PRIORITY = {
            "SAFE": 0, "SAFE_INITIAL": 1, "SAFE_RETURN_1": 2, "SAFE_RETURN_2": 2, "SAFE_RETURN_GNSS": 2,
            "WATER_WARN_DECREASING": 3, "WATER_WARN_RISING": 4, 
            "GNSS_WARN": 5, "FUSED_HIGH": 6,
            "WATER_CRITICAL": 7, "GNSS_CRITICAL": 8, "FUSED_CRITICAL": 9, "FUSED_MAXIMUM": 10 }

    def process_new_gnss_report(self, report): self.gnss_sm.process_new_report(report); self._update_composite_alert()
    def process_new_water_value(self, value):
        if self.backend.critical_threshold is None or self.backend.warning_threshold is None: return -1
        new_level = self.water_sm.process_new_value(value); self._update_composite_alert(); return new_level

    def request_action(self, action_name): logger.info(f"[AlertManager] Nhận yêu cầu hành động: {action_name}"); self.trigger_alert_by_name(action_name)

    def _update_composite_alert(self):
        w = self.water_sm.current_level; g = self.gnss_sm.current_level; new_composite = "SAFE"
        if w >= 2 and g >= 2: new_composite = "FUSED_MAXIMUM"
        elif (w >= 2 and g == 1) or (w == 1 and g >= 2): new_composite = "FUSED_CRITICAL"
        elif w == 1 and g == 1: new_composite = "FUSED_HIGH"
        if new_composite != "SAFE": self.trigger_alert_by_name(new_composite)
        elif w == 0 and g == 0:
            if self.ALERT_PRIORITY.get(self.active_alert_name, 0) > self.ALERT_PRIORITY["SAFE_RETURN_2"]: self.trigger_alert_by_name("SAFE")

    def trigger_alert_by_name(self, alert_name):
        sound_map = {
            "SAFE_INITIAL": ([self.backend.safe_sound_1], False, False),
            "SAFE_RETURN_1": ([self.backend.safe_sound_2], False, False),
            "SAFE_RETURN_2": ([self.backend.safe_sound_2], False, False),
            "SAFE_RETURN_GNSS": ([self.backend.safe_sound_2], False, False),
            "WATER_WARN_RISING": ([self.backend.siren_sound, self.backend.warning_sound], False, True),
            "WATER_WARN_DECREASING": ([self.backend.decreasing_sound], False, True),
            "WATER_CRITICAL": ([self.backend.siren_sound, self.backend.danger_sound, self.backend.siren_sound], False, True),
            "GNSS_WARN": ([self.backend.siren_sound, self.backend.gnss_moderate_sound], False, True),
            "GNSS_CRITICAL": ([self.backend.siren_sound, self.backend.gnss_rapid_sound], False, True),
            "FUSED_HIGH": ([self.backend.siren_sound, self.backend.fused_high_sound], True, True),
            "FUSED_CRITICAL": ([self.backend.siren_sound, self.backend.fused_critical_sound], True, True),
            "FUSED_MAXIMUM": ([self.backend.siren_sound, self.backend.fused_maximum_sound], True, True),
            "SAFE": ([], False, False), }
        sounds, loop, relay = sound_map.get(alert_name, ([], False, False))
        self._play_sequence_in_thread(alert_name, sounds, loop, relay)

    def _play_sequence_in_thread(self, alert_name, sound_list, loop=False, activate_relay=False):
        current_priority = self.ALERT_PRIORITY.get(self.active_alert_name, 0); new_priority = self.ALERT_PRIORITY.get(alert_name, 0)
        if new_priority < current_priority and "SAFE" not in self.active_alert_name:
            logger.info(f"Bỏ qua '{alert_name}' (ưu tiên {new_priority}) vì '{self.active_alert_name}' (ưu tiên {current_priority}) đang hoạt động.")
            return
        self.stop_all_alerts(); self.active_alert_name = alert_name
        if alert_name == "SAFE": return
        def target():
            if not self.backend.mixer_initialized: return
            if activate_relay: self.backend.activate_siren_relay()
            try:
                while not self.backend.exiting and self.active_alert_name == alert_name:
                    for sound in sound_list:
                        if sound and not self.backend.exiting and self.active_alert_name == alert_name:
                            sound.play()
                            while IS_PI and pygame.mixer.get_busy() and not self.backend.exiting and self.active_alert_name == alert_name: time.sleep(0.1)
                    if not loop: break
            except Exception as e: logger.error(f"Lỗi trong luồng phát âm thanh: {e}")
            finally:
                if self.active_alert_name == alert_name:
                    if not loop: self.active_alert_name = "SAFE"
                    if not loop and activate_relay: self.backend.deactivate_siren_relay()
                self.alert_thread = None
        self.alert_thread = threading.Thread(target=target, daemon=True); self.alert_thread.start()

    def stop_all_alerts(self):
        if self.active_alert_name != "SAFE": logger.info(f"Đang dừng cảnh báo: {self.active_alert_name}")
        self.active_alert_name = "SAFE"
        if self.backend.mixer_initialized: pygame.mixer.stop()
        self.backend.deactivate_siren_relay()

# ==============================================================================
# LỚP LOGIC NỀN (BACKEND)
# ==============================================================================
class Backend:
    def __init__(self):
        self.listening = False; self.exiting = False; self.status_text = "Trạng thái: THỦ CÔNG"; self.status_color = "red"
        self.temp_status_text = None; self.config = configparser.ConfigParser()
        self.broker = ""; self.port = 1883; self.username = ""; self.password = ""
        self.publish_topic = ""; self.water_topics = []; self.gnss_topics = []; self.subscribe_topics = []
        self.warning_threshold = None; self.critical_threshold = None
        self.sounds_dir = Constants.DEFAULT_SOUNDS_DIR; self.test_sound_file_path = ""
        self.mixer_initialized = False; self.siren_sound = None; self.warning_sound, self.danger_sound = None, None
        self.decreasing_sound, self.safe_sound_1, self.safe_sound_2 = None, None, None
        self.gnss_moderate_sound, self.gnss_rapid_sound = None, None
        self.fused_high_sound, self.fused_critical_sound, self.fused_maximum_sound = None, None, None
        self.overview_log_data = deque(maxlen=Constants.MAX_SENSOR_RECORDS); self.water_data = deque(maxlen=Constants.MAX_SENSOR_RECORDS)
        self.gnss_analysis_data = deque(maxlen=Constants.MAX_SENSOR_RECORDS); self.plot_data_points = deque(maxlen=Constants.MAX_PLOT_POINTS)
        self.gui_update_queue = queue.Queue()
        self.client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2, protocol=mqtt.MQTTv311)
        self.client.on_connect = self.on_connect; self.client.on_disconnect = self.on_disconnect; self.client.on_message = self.on_message
        self.shifting_process = None; self.alert_manager = AlertManager(self)
        self.gnss_speed_classification = []; self.last_shifting_heartbeat = 0; self.is_shifting_responsive = True
        self.load_config(); self.setup_audio_mixer(); self.setup_gpio(); atexit.register(self.cleanup_on_exit)

    def log_to_overview(self, source, message, status, timestamp=None):
        ts = timestamp if timestamp else time.time(); dt_object = datetime.fromtimestamp(ts)
        record = (dt_object.strftime("%H:%M:%S"), source, message, status)
        self.overview_log_data.append(record); self.gui_update_queue.put(("overview_log", record))

    def on_message(self, client, userdata, msg):
        if not self.listening or self.exiting: return
        if msg.topic in self.gnss_topics: return
        try:
            data = json.loads(msg.payload.decode('utf-8'))
            if "value" in data:
                value = float(data.get("value"))
                current_water_level = self.alert_manager.process_new_water_value(value)
                if current_water_level == -1: return
                name = data.get("sensorname", msg.topic); ts = float(data.get("timestamp", time.time()))
                status = "NGUY HIEM" if current_water_level == 2 else ("CANH BAO" if current_water_level == 1 else "AN TOAN")
                water_record = (name, f"{value:.4f}", status, datetime.fromtimestamp(ts).strftime("%H:%M:%S %d-%m"))
                self.log_to_overview(f"Cảm biến Nước ({name})", f"Giá trị: {value:.4f}", status, ts)
                self.water_data.append(water_record); self.plot_data_points.append((datetime.fromtimestamp(ts), value))
                self.gui_update_queue.put(("water_sensor", water_record))
                if self.publish_topic: self.client.publish(self.publish_topic, json.dumps({"sensor": name, "value": value, "status": status, "timestamp": ts}))
        except (json.JSONDecodeError, ValueError, KeyError) as e: logger.error(f"Lỗi xử lý message: {e} | Payload: {msg.payload.decode('utf-8', errors='ignore')}")

    def _read_shifting_output(self, pipe):
        for line in iter(pipe.readline, ''):
            try:
                line_str = line.strip()
                if not line_str or not line_str.startswith('{'): continue
                data = json.loads(line_str)
                if data.get("type") == "ultimate_analysis_report": self.alert_manager.process_new_gnss_report(data)
                self.gui_update_queue.put(("gnss_report", data))
            except json.JSONDecodeError: logger.warning(f"Nhận được dòng không phải JSON từ shifting.py: {line_str}")
            except Exception as e: logger.error(f"Lỗi trong luồng đọc shifting.py: {e}"); break
        pipe.close(); logger.info("Luồng đọc kết quả từ shifting.py đã dừng.")

    def clear_all_data(self): self.overview_log_data.clear(); self.water_data.clear(); self.gnss_analysis_data.clear(); self.plot_data_points.clear(); self.gui_update_queue.put(("clear_all", None)); logger.info("Đã xóa dữ liệu nền.")
    def save_session_data(self, silent=False):
        if not silent: logger.info("Đang lưu trạng thái hiện tại vào file...")
        try:
            plot_data_serializable = [(dt.isoformat(), val) for dt, val in self.plot_data_points]
            session = {"overview_log_data": list(self.overview_log_data), "water_data": list(self.water_data), "gnss_analysis_data": list(self.gnss_analysis_data), "plot_data_points": plot_data_serializable}
            with open(Constants.SESSION_FILE, "w", encoding='utf-8') as f: json.dump(session, f)
            if not silent: logger.info(f"Đã lưu trạng thái vào {Constants.SESSION_FILE}")
        except Exception as e: logger.error(f"Lỗi khi lưu trạng thái: {e}")

    def load_session_data(self):
        if not os.path.exists(Constants.SESSION_FILE): return
        logger.info(f"Tìm thấy file trạng thái {Constants.SESSION_FILE}, đang tải lại dữ liệu...")
        try:
            with open(Constants.SESSION_FILE, "r", encoding='utf-8') as f: session = json.load(f)
            for record in session.get("overview_log_data", []): self.overview_log_data.append(tuple(record)); self.gui_update_queue.put(("overview_log", tuple(record)))
            for record in session.get("water_data", []): self.water_data.append(tuple(record)); self.gui_update_queue.put(("water_sensor", tuple(record)))
            for record in session.get("gnss_analysis_data", []): self.gnss_analysis_data.append(tuple(record)); self.gui_update_queue.put(("gnss_analysis_record", tuple(record)))
            plot_data_serializable = session.get("plot_data_points", [])
            self.plot_data_points.clear()
            for dt_str, val in plot_data_serializable: self.plot_data_points.append((datetime.fromisoformat(dt_str), val))
            logger.info("Đã tải lại dữ liệu thành công.")
        except Exception as e: logger.error(f"Lỗi khi tải trạng thái: {e}")
        finally:
            if os.path.exists(Constants.SESSION_FILE): os.remove(Constants.SESSION_FILE)

    def apply_new_config(self):
        logger.info("Đang áp dụng cấu hình mới từ file...")
        old_shifting_signature = (f"{self.broker}-{self.port}-{self.username}-{self.password}-{'-'.join(sorted(self.gnss_topics))}-{json.dumps(self.gnss_speed_classification, sort_keys=True)}")
        old_water_topics = set(self.water_topics)
        self.load_config()
        new_shifting_signature = (f"{self.broker}-{self.port}-{self.username}-{self.password}-{'-'.join(sorted(self.gnss_topics))}-{json.dumps(self.gnss_speed_classification, sort_keys=True)}")
        new_water_topics = set(self.water_topics)
        needs_shifting_restart = (old_shifting_signature != new_shifting_signature)
        needs_mqtt_reconnect = (old_water_topics != new_water_topics or needs_shifting_restart)
        if not self.listening: logger.info("Cấu hình đã được tải lại. Hệ thống đang ở chế độ Thủ công."); return True
        if needs_shifting_restart:
            logger.info("Phát hiện thay đổi trong cài đặt GNSS hoặc Broker. Đang khởi động lại toàn bộ hệ thống...")
            self.toggle_off(); time.sleep(1); self.toggle_on()
        elif needs_mqtt_reconnect:
            logger.info("Phát hiện thay đổi trong Topic Nước. Chỉ kết nối lại MQTT...")
            try: self.client.loop_stop(); self.client.disconnect()
            except Exception: pass
            time.sleep(1)
            try: self.client.connect_async(self.broker, self.port, 60); self.client.loop_start()
            except Exception as e: logger.error(f"Lỗi khi kết nối lại MQTT: {e}"); self.status_text, self.status_color = "Trạng thái: LỖI KẾT NỐI", "red"; return False
        else: logger.info("Các cài đặt không ảnh hưởng đến kết nối đã được cập nhật và tải lại.")
        return True

    def _reset_gnss_to_default(self):
        logger.info("Đang khôi phục bảng phân loại GNSS về tiêu chuẩn Cruden-Varnes 1996 + IUGS.")
        self.gnss_speed_classification = [
            {'name': 'Extremely Rapid', 'mm_giay': '5000.0'}, {'name': 'Very Rapid', 'mm_giay': '50.0'},
            {'name': 'Rapid', 'mm_giay': '0.5'}, {'name': 'Moderate', 'mm_giay': '0.00061'},
            {'name': 'Slow', 'mm_giay': '0.000051'}, {'name': 'Very Slow', 'mm_giay': '0.00000051'},
            {'name': 'Extremely Slow', 'mm_giay': '0.0'} ]

    def start_background_tasks(self):
        self.load_session_data()
        threading.Thread(target=self.auto_clear_scheduler, daemon=True).start()
        threading.Thread(target=self.check_shifting_health, daemon=True).start()
        logger.info("Đã khởi chạy các tác vụ nền.")

    def check_shifting_health(self):
        while not self.exiting:
            if self.listening and self.shifting_process and self.shifting_process.poll() is None:
                if time.time() - self.last_shifting_heartbeat > 60 and self.last_shifting_heartbeat != 0:
                    if self.is_shifting_responsive:
                        logger.critical("TIẾN TRÌNH SHIFTING KHÔNG PHẢN HỒI! Đang thử khởi động lại...")
                        self.is_shifting_responsive = False; self.temp_status_text = "LỖI: Tiến trình phân tích không phản hồi!"
                        self.stop_shifting_process(); time.sleep(2); self.start_shifting_process()
            time.sleep(15)

    def start_shifting_process(self):
        if self.shifting_process and self.shifting_process.poll() is None: logger.info("Tiến trình shifting.py đã đang chạy."); return
        if not self.gnss_topics: logger.warning("Không có topic GNSS nào để khởi động shifting.py."); return
        try:
            classification_table_json = json.dumps(self.gnss_speed_classification)
            command = [sys.executable, '-u', 'shifting.py', '--broker', self.broker, '--port', str(self.port), '--classification-table', classification_table_json]
            if self.username: command.extend(['--username', self.username])
            if self.password: command.extend(['--password', self.password])
            for topic in self.gnss_topics: command.extend(['--topic', topic])
            logger.info(f"Đang khởi chạy shifting.py...")
            self.shifting_process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8', errors='ignore')
            threading.Thread(target=self._read_shifting_output, args=(self.shifting_process.stdout,), daemon=True).start()
            threading.Thread(target=self._log_process_errors, args=(self.shifting_process.stderr, "SHIFTING"), daemon=True).start()
            logger.info("Đã khởi động tiến trình shifting.py và luồng đọc kết quả.")
        except Exception as e:
            logger.error(f"Lỗi khởi động shifting.py: {e}")
            if self.shifting_process: self.shifting_process.kill()
            self.shifting_process = None

    def _log_process_errors(self, pipe, process_name):
        for line in iter(pipe.readline, ''):
            error_message = line.strip()
            if error_message: logger.error(f"[{process_name}_ERROR]: {error_message}")
        pipe.close()

    def stop_shifting_process(self):
        if self.shifting_process and self.shifting_process.poll() is None:
            try:
                logger.info("Đang dừng tiến trình shifting.py..."); self.shifting_process.terminate()
                self.shifting_process.wait(timeout=5); logger.info(f"Đã dừng thành công tiến trình shifting.py.")
            except subprocess.TimeoutExpired: logger.warning("Tiến trình shifting.py không phản hồi, buộc dừng (kill)."); self.shifting_process.kill()
            except Exception as e: logger.error(f"Lỗi khi dừng shifting.py: {e}")
        self.shifting_process = None

    def setup_audio_mixer(self):
        if not IS_PI: self.mixer_initialized = False; return
        try:
            logger.info("Đang khởi tạo audio mixer...")
            pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=4096)
            self.mixer_initialized = True
            self.siren_sound = self._load_sound("coi1.mp3")
            self.warning_sound = self._load_sound("warning.mp3")
            self.danger_sound = self._load_sound("danger.mp3")
            self.decreasing_sound = self._load_sound("decrease.mp3")
            self.safe_sound_1 = self._load_sound("safe.mp3")
            self.safe_sound_2 = self._load_sound("safe2.mp3")
            self.gnss_moderate_sound = self._load_sound("gnss_warning.mp3")
            self.gnss_rapid_sound = self._load_sound("gnss_critical.mp3")
            self.fused_high_sound = self._load_sound("fused_high.mp3")
            self.fused_critical_sound = self._load_sound("fused_critical.mp3")
            self.fused_maximum_sound = self._load_sound("fused_maximum.mp3")
            logger.info("Audio mixer đã sẵn sàng.")
        except Exception as e: logger.error(f"Không thể khởi tạo pygame mixer: {e}"); self.mixer_initialized = False

    def _load_sound(self, filename):
        if not self.mixer_initialized: return None
        path = os.path.join(self.sounds_dir, filename)
        if os.path.exists(path):
            try: return pygame.mixer.Sound(path)
            except Exception as e: logger.error(f"Lỗi khi tải file âm thanh '{path}': {e}"); return None
        logger.warning(f"Không tìm thấy file âm thanh: {path}"); return None

    def load_config(self):
        if not os.path.exists(Constants.CONFIG_FILE):
            logger.warning(f"File cấu hình '{Constants.CONFIG_FILE}' không tồn tại. Vui lòng cấu hình hệ thống qua giao diện.")
            self._reset_gnss_to_default(); return
        logger.info(f"Đang tải cấu hình từ {Constants.CONFIG_FILE}...")
        try:
            self.config.read(Constants.CONFIG_FILE, encoding='utf-8')
            if "MQTT" in self.config:
                mqtt_cfg = self.config["MQTT"]
                self.broker = mqtt_cfg.get("broker", ""); self.port = mqtt_cfg.getint("port", 1883)
                self.username = mqtt_cfg.get("username", ""); self.password = mqtt_cfg.get("password", "")
                self.water_topics = [t.strip() for t in mqtt_cfg.get("water_sub_topic", "").splitlines() if t.strip()]
                self.gnss_topics = [t.strip() for t in mqtt_cfg.get("gnss_sub_topic", "").splitlines() if t.strip()]
                self.subscribe_topics = self.water_topics; self.publish_topic = mqtt_cfg.get("publish", "")
            if "Settings" in self.config:
                settings_cfg = self.config["Settings"]
                self.warning_threshold = settings_cfg.getfloat("warning_threshold", None)
                self.critical_threshold = settings_cfg.getfloat("critical_threshold", None)
                self.sounds_dir = settings_cfg.get("sounds_dir", Constants.DEFAULT_SOUNDS_DIR)
                self.test_sound_file_path = settings_cfg.get("test_sound_path", "")
            if "GNSS_Classification" in self.config and self.config['GNSS_Classification']: self._load_gnss_from_config(self.config["GNSS_Classification"])
            else: self._reset_gnss_to_default()
            if self.mixer_initialized: self.setup_audio_mixer() 
        except Exception as e:
            logger.error(f"Lỗi tải cấu hình: {e}. Sử dụng các giá trị trống."); self._reset_gnss_to_default()

    def _load_gnss_from_config(self, gnss_cfg):
        items_dict = {};
        for key, value in gnss_cfg.items():
            if key.startswith('item_'):
                parts = key.split('_', 2)
                if len(parts) == 3:
                    item_index, attr_name = int(parts[1]), parts[2]
                    if item_index not in items_dict: items_dict[item_index] = {}
                    items_dict[item_index][attr_name] = value
        if items_dict: self.gnss_speed_classification = [items_dict[i] for i in sorted(items_dict.keys())]

    def save_config(self, settings):
        try:
            self.config['MQTT'] = {'broker': settings['broker'], 'port': settings['port'], 'username': settings['username'], 'password': settings['password'],
                                   'water_sub_topic': settings.get('water_topics', "\n".join(self.water_topics)), 
                                   'gnss_sub_topic': settings.get('gnss_topics', "\n".join(self.gnss_topics)), 'publish': settings['publish']}
            self.config['Settings'] = {'warning_threshold': settings['warning_threshold'], 'critical_threshold': settings['critical_threshold'],
                                       'sounds_dir': settings['sounds_dir'], 'test_sound_path': settings['test_sound_path']}
            gnss_section = {};
            for i, item in enumerate(self.gnss_speed_classification):
                for key, value in item.items(): gnss_section[f'item_{i}_{key}'] = str(value)
            self.config['GNSS_Classification'] = gnss_section
            with open(Constants.CONFIG_FILE, 'w', encoding='utf-8') as f: self.config.write(f)
            logger.info(f"Đã lưu cấu hình vào {Constants.CONFIG_FILE}"); return True
        except Exception as e: logger.error(f"Lỗi lưu cấu hình: {e}"); return False

    def cleanup_on_exit(self):
        if self.exiting: return
        logger.info("Bắt đầu quá trình dọn dẹp để thoát..."); self.exiting = True; self.stop_shifting_process()
        try:
            if self.client and self.client.is_connected(): self.client.loop_stop(); self.client.disconnect()
        except Exception as e: logger.error(f"Lỗi khi ngắt kết nối MQTT: {e}")
        self.save_session_data(silent=True)
        if IS_PI: GPIO.cleanup()
        logger.info("Backend đã dừng.")

    def setup_gpio(self):
        if not IS_PI: return
        try:
            GPIO.setmode(GPIO.BCM); GPIO.setwarnings(False); GPIO.setup(Constants.SIREN_RELAY_PIN, GPIO.OUT, initial=GPIO.LOW)
            logger.info(f"GPIO setup successful for Siren Relay on pin {Constants.SIREN_RELAY_PIN}.")
        except Exception as e: logger.error(f"Lỗi khi cài đặt GPIO: {e}. Vui lòng chạy với quyền sudo.")

    def activate_siren_relay(self):
        if not IS_PI: return
        try: GPIO.output(Constants.SIREN_RELAY_PIN, GPIO.HIGH); logger.info("Rơ-le còi báo động đã được KÍCH HOẠT (ON).")
        except Exception as e: logger.error(f"Lỗi kích hoạt rơ-le: {e}")

    def deactivate_siren_relay(self):
        if not IS_PI: return
        try: GPIO.output(Constants.SIREN_RELAY_PIN, GPIO.LOW); logger.info("Rơ-le còi báo động đã được NGẮT (OFF).")
        except Exception as e: logger.error(f"Lỗi ngắt rơ-le: {e}")

    def on_connect(self, client, userdata, flags, reason_code, properties):
        if self.exiting: return
        if reason_code.value == 0:
            logger.info("MQTT Connected successfully.")
            self.status_text, self.status_color = "Trạng thái: TỰ ĐỘNG", "green"
            if self.subscribe_topics:
                for t in self.subscribe_topics: client.subscribe(t); logger.info(f"Subscribed: {t}")
            else: logger.warning("Không có topic nước nào để subscribe.")
        else:
            logger.error(f"Failed to connect to MQTT, return code {reason_code.value}")
            self.status_text, self.status_color = "Trạng thái: LỖI KẾT NỐI", "red"; self.listening = False
    
    def on_disconnect(self, client, userdata, flags, reason_code, properties):
        if not self.exiting and self.listening: logger.warning("Mất kết nối MQTT..."); self.status_text, self.status_color = "Trạng thái: MẤT KẾT NỐI", "orange"
    
    def get_gui_updates(self):
        updates = [];
        while not self.gui_update_queue.empty():
            try: updates.append(self.gui_update_queue.get_nowait())
            except queue.Empty: break
        return updates

    def toggle_off(self):
        if not self.listening: return
        self.listening = False; self.stop_shifting_process()
        try: self.client.loop_stop(); self.client.disconnect(); logger.info("Đã ngắt kết nối MQTT.")
        except Exception: pass
        self.status_text, self.status_color = "Trạng thái: THỦ CÔNG", "red"; self.temp_status_text = None

    def toggle_on(self):
        if self.listening: return
        if not self.broker:
            logger.error("Không thể bật, chưa cấu hình MQTT Broker."); messagebox.showerror("Chưa cấu hình", "Vui lòng cấu hình MQTT Broker trước khi bật chế độ Tự động."); return
        self.listening = True; self.status_text, self.status_color = "Trạng thái: ĐANG KẾT NỐI...", "orange"
        try:
            self.client.username_pw_set(self.username, self.password)
            logger.info(f"Đang kết nối tới MQTT broker: {self.broker}:{self.port}...")
            self.client.connect_async(self.broker, self.port, 60); self.client.loop_start()
            if self.gnss_topics: self.last_shifting_heartbeat = time.time(); self.is_shifting_responsive = True; self.start_shifting_process()
        except Exception as e:
            self.listening = False; self.status_text, self.status_color = "Trạng thái: LỖI KẾT NỐI", "red"; logger.error(f"Lỗi khi kết nối MQTT: {e}")

    def test_siren_relay(self):
        if self.listening: messagebox.showwarning("Cảnh báo", "Chỉ có thể kiểm tra còi ở chế độ THỦ CÔNG (OFF)."); return False
        if not IS_PI: messagebox.showwarning("Cảnh báo", "Không thể kiểm tra còi, không phải môi trường Raspberry Pi."); return False
        threading.Thread(target=self._test_siren_thread, daemon=True).start(); return True
    
    def _test_siren_thread(self): logger.info("Đang kiểm tra còi báo động..."); self.activate_siren_relay(); time.sleep(2); self.deactivate_siren_relay(); logger.info("Kiểm tra còi hoàn tất.")

    def test_specific_sound(self, filepath):
        if not IS_PI or not self.mixer_initialized: logger.warning("Không thể kiểm tra âm thanh, pygame mixer chưa sẵn sàng."); return "Mixer not ready"
        if not os.path.exists(filepath): logger.error(f"File âm thanh kiểm tra không tồn tại: {filepath}"); return "File not found"
        threading.Thread(target=self._test_sound_thread, args=(filepath,), daemon=True).start(); return "OK"
    
    def _test_sound_thread(self, filepath):
        try:
            logger.info(f"Đang phát file kiểm tra: {os.path.basename(filepath)}"); pygame.mixer.stop()
            test_sound = pygame.mixer.Sound(filepath); test_sound.play()
        except Exception as e: logger.error(f"Lỗi khi phát file kiểm tra '{filepath}': {e}")
    
    def auto_clear_scheduler(self):
        while not self.exiting:
            now = datetime.now()
            if now.hour == 0 and now.minute == 0: logger.info("Đã đến 00:00, tự động xóa dữ liệu..."); self.clear_all_data(); time.sleep(61)
            else: time.sleep(30)

# ==============================================================================
# LỚP CỬA SỔ BIỂU ĐỒ
# ==============================================================================
class ChartWindow:
    def __init__(self, parent_root, backend):
        self.root = Toplevel(parent_root)
        self.backend = backend
        self.root.title("Biểu đồ Dữ liệu Cảm biến Nước")
        self.root.geometry("900x650")
        self.root.transient(parent_root)
        self.current_start_index = 0
        self._is_updating_slider = False
        self._slider_after_id = None
        self.points_per_view = Constants.CHART_POINTS_PER_VIEW
        self.CONVERSION_FACTORS = {"m": 1.0, "cm": 100.0, "mm": 1000.0, "ft": 3.28084}
        self.create_widgets()
        self.update_plot()
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)

    def create_widgets(self):
        top_frame = ttk.Frame(self.root, padding=(10, 5)); top_frame.pack(side=tk.TOP, fill=tk.X)
        ttk.Label(top_frame, text="Chọn đơn vị:").pack(side=tk.LEFT, padx=(0, 5))
        self.unit_selector = ttk.Combobox(top_frame, state="readonly", values=list(self.CONVERSION_FACTORS.keys()))
        self.unit_selector.set("m"); self.unit_selector.pack(side=tk.LEFT, padx=5)
        self.unit_selector.bind("<<ComboboxSelected>>", lambda e: self.update_plot())
        self.auto_follow_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(top_frame, text="Tự động theo dõi", variable=self.auto_follow_var, command=self.on_auto_follow_toggle).pack(side=tk.LEFT, padx=20)
        chart_frame = ttk.Frame(self.root, padding=(10, 5)); chart_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.fig = Figure(figsize=(9, 4.5), dpi=100)
        self.ax = self.fig.add_subplot(111); self.canvas = FigureCanvasTkAgg(self.fig, master=chart_frame)
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        slider_frame = ttk.Frame(self.root, padding=10); slider_frame.pack(side=tk.BOTTOM, fill=tk.X)
        self.position_var = tk.DoubleVar()
        self.position_scale = ttk.Scale(slider_frame, from_=0, to=100, orient=tk.HORIZONTAL, variable=self.position_var, command=self.on_slider_change)
        self.position_scale.pack(side=tk.TOP, fill=tk.X, expand=True)
        self.info_label = ttk.Label(slider_frame, text="Tổng điểm: 0 | Hiển thị: 0-0", font=("Arial", 9))
        self.info_label.pack(side=tk.TOP, pady=(5, 0))

    def on_close(self):
        if self._slider_after_id: self.root.after_cancel(self._slider_after_id)
        plt.close(self.fig); self.root.destroy()
        app_gui_instance = self.root.master.app_instance 
        if app_gui_instance: app_gui_instance.chart_window = None
    
    def update_plot(self):
        if not self.root.winfo_exists(): return
        all_data = list(self.backend.plot_data_points); total_points = len(all_data)
        start, end = self._update_slider_and_indices(total_points); self.ax.clear()
        warn_thresh_val = self.backend.warning_threshold; crit_thresh_val = self.backend.critical_threshold
        if not all_data or warn_thresh_val is None or crit_thresh_val is None:
            self._setup_plot_style(); msg = 'Chưa có dữ liệu' if not all_data else 'Chưa cấu hình ngưỡng'
            self.ax.text(0.5, 0.5, msg, ha='center', va='center', transform=self.ax.transAxes, fontsize=16, color='gray')
            self.info_label.config(text="Tổng điểm: 0 | Hiển thị: 0-0")
        else:
            data_slice = all_data[start:end]
            if not data_slice: self.canvas.draw(); return
            indices, values, times, unit, warn_thresh, crit_thresh = self._prepare_plot_data(data_slice, start)
            self._setup_plot_style(unit); self._draw_plot_elements(indices, values, warn_thresh, crit_thresh); self._configure_plot_axes(start, end, total_points, indices, times)
        self.canvas.draw()
    
    def _update_slider_and_indices(self, total_points):
        max_start_idx = max(0, total_points - self.points_per_view)
        if total_points <= self.points_per_view: self.position_scale.config(state="disabled"); self.current_start_index = 0
        else:
            self.position_scale.config(state="normal")
            if self.auto_follow_var.get(): self.current_start_index = max_start_idx
            else: self.current_start_index = min(self.current_start_index, max_start_idx)
        self._is_updating_slider = True
        self.position_var.set((self.current_start_index / max_start_idx) * 100 if max_start_idx > 0 else 100)
        self._is_updating_slider = False
        return self.current_start_index, min(total_points, self.current_start_index + self.points_per_view)
    
    def _prepare_plot_data(self, data_slice, start_index):
        unit = self.unit_selector.get(); conversion_factor = self.CONVERSION_FACTORS.get(unit, 1.0)
        return (range(start_index, start_index + len(data_slice)), [i[1] * conversion_factor for i in data_slice], [i[0] for i in data_slice], unit, self.backend.warning_threshold * conversion_factor, self.backend.critical_threshold * conversion_factor)
    
    def _setup_plot_style(self, unit='Giá trị'):
        self.ax.set_title('Dữ liệu Cảm biến Theo Thời Gian', fontsize=14, fontweight='bold')
        self.ax.set_xlabel('Thời gian', fontsize=12); self.ax.set_ylabel(f'Giá trị ({unit})', fontsize=12)
        self.ax.grid(True, which='major', linestyle='--', alpha=0.6)
    
    def _draw_plot_elements(self, indices, values, warning_thresh, critical_thresh):
        self.ax.plot(indices, values, color='gray', linestyle='-', linewidth=1, alpha=0.5, zorder=3)
        colors = ['green' if v < warning_thresh else 'orange' if v < critical_thresh else 'red' for v in values]
        self.ax.scatter(indices, values, c=colors, s=30, zorder=5)
        self.ax.axhline(y=warning_thresh, color='gold', linestyle='--', linewidth=2, label=f'Ngưỡng Cảnh báo ({warning_thresh:.2f} {self.unit_selector.get()})')
        self.ax.axhline(y=critical_thresh, color='darkorange', linestyle='--', linewidth=2, label=f'Ngưỡng Nguy hiểm ({critical_thresh:.2f} {self.unit_selector.get()})')
    
    def _configure_plot_axes(self, start, end, total_points, indices, times):
        self.ax.set_xlim(left=start - 0.5, right=start + self.points_per_view - 0.5)
        num_ticks = min(len(indices), 8)
        if num_ticks > 1:
            tick_indices = np.linspace(0, len(indices) - 1, num_ticks, dtype=int)
            self.ax.set_xticks([indices[i] for i in tick_indices]); self.ax.set_xticklabels([times[i].strftime('%H:%M:%S') for i in tick_indices], rotation=25, ha='right')
        elif indices: self.ax.set_xticks(indices); self.ax.set_xticklabels([t.strftime('%H:%M:%S') for t in times])
        self.ax.legend(); self.info_label.config(text=f"Tổng điểm: {total_points} | Hiển thị: {start+1}-{end}"); self.fig.tight_layout()
    
    def on_auto_follow_toggle(self):
        if self.auto_follow_var.get(): self.update_plot()
    
    def on_slider_change(self, value_str):
        if self._is_updating_slider: return
        if self._slider_after_id: self.root.after_cancel(self._slider_after_id)
        self._slider_after_id = self.root.after(100, lambda: self._perform_slider_update(float(value_str)))
    
    def _perform_slider_update(self, value):
        self._slider_after_id = None; self.auto_follow_var.set(False)
        total_points = len(self.backend.plot_data_points)
        if total_points > self.points_per_view: self.current_start_index = int((value / 100) * (total_points - self.points_per_view)); self.update_plot()
        
# ==============================================================================
# LỚP GIAO DIỆN NGƯỜI DÙNG (GUI)
# ==============================================================================
class AppGUI:
    def __init__(self, root: tk.Toplevel, backend: Backend, on_close_callback):
        self.root = root; self.backend = backend; self.on_close_callback = on_close_callback
        self.root.title("Giao diện Giám sát Sạt lở & Cảnh báo Sớm"); self.root.geometry(f"{self.root.winfo_screenwidth()}x{self.root.winfo_screenheight()-70}+0+0")
        self.main_settings_window, self.chart_window, self.settings_window, self.classification_win = None, None, None, None
        self.broker_var, self.port_var, self.user_var, self.pass_var, self.pub_topic_var = tk.StringVar(), tk.StringVar(), tk.StringVar(), tk.StringVar(), tk.StringVar()
        self.warning_threshold_var, self.critical_threshold_var, self.sounds_dir_var, self.test_sound_path_var = tk.StringVar(), tk.StringVar(), tk.StringVar(), tk.StringVar()
        self.create_widgets(); self.load_initial_data_to_vars(); self.root.after(250, self.periodic_update)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close_window); self.root.app_instance = self
    
    def create_widgets(self):
        main = ttk.Frame(self.root, padding=10); main.pack(fill="both", expand=True)
        main.grid_columnconfigure(1, weight=1); main.grid_columnconfigure(0, weight=0, minsize=300); main.grid_rowconfigure(0, weight=1)
        self.create_left_panel(main); self.create_right_panel(main)

    def create_left_panel(self, parent):
        left = ttk.Frame(parent); left.grid(row=0, column=0, sticky="ns", padx=(0, 15))
        control_frame = ttk.LabelFrame(left, text="Điều khiển Chính", padding=(10, 5)); control_frame.pack(fill=tk.X, expand=False, pady=(0, 10))
        control_frame.grid_columnconfigure((0, 1), weight=1)
        ttk.Button(control_frame, text="Tự động (ON)", command=self.backend.toggle_on, bootstyle="success").grid(row=0, column=0, sticky='ew', padx=2, pady=2)
        ttk.Button(control_frame, text="Thủ công (OFF)", command=self.backend.toggle_off, bootstyle="danger").grid(row=0, column=1, sticky='ew', padx=2, pady=2)
        settings_frame = ttk.LabelFrame(left, text="Cài đặt & Chức năng", padding=10); settings_frame.pack(fill=tk.X, expand=False, pady=10)
        ttk.Button(settings_frame, text="Cài đặt Hệ thống & MQTT", command=self.open_main_settings_window, bootstyle="primary").pack(fill=tk.X, pady=2)
        ttk.Button(settings_frame, text="Cài đặt Nâng cao (Âm thanh, GNSS...)", command=self.open_advanced_settings_window, bootstyle="secondary").pack(fill=tk.X, pady=2)
        ttk.Button(settings_frame, text="Tải lại & Áp dụng Cấu hình", command=self.apply_config_from_main, bootstyle="info").pack(fill=tk.X, pady=(10,2))
        ttk.Button(settings_frame, text="Kiểm tra Còi", command=self.on_test_siren_click).pack(fill=tk.X, pady=(10, 2))
        ttk.Button(settings_frame, text="Xóa Toàn bộ Dữ liệu", command=self.clear_all_gui_data, bootstyle="warning").pack(fill=tk.X, pady=2)
        ttk.Button(left, text="Thoát Chương trình", command=self.exit_program_graceful, bootstyle="secondary-outline").pack(side=tk.BOTTOM, fill=tk.X, pady=(15,0))

    def create_right_panel(self, parent):
        right = ttk.Frame(parent); right.grid(row=0, column=1, sticky="nsew")
        right.grid_rowconfigure(1, weight=1); right.grid_columnconfigure(0, weight=1)
        self.status_label = ttk.Label(right, text="", font=("Arial", 11, "bold")); self.status_label.grid(row=0, column=0, sticky="ew", pady=(0, 5))
        self.notebook = ttk.Notebook(right); self.notebook.grid(row=1, column=0, sticky="nsew")
        tabs = {'gnss': ' Phân tích Dịch chuyển GNSS ', 'water': ' Cảnh báo Nước ', 'overview': ' Nhật ký Tổng quan ', 'long_term': ' Phân tích Dài hạn '}
        for key, text in tabs.items(): setattr(self, f"{key}_tab", ttk.Frame(self.notebook, padding=5)); self.notebook.add(getattr(self, f"{key}_tab"), text=text)
        self.create_gnss_tab(self.gnss_tab); self.create_water_tab(self.water_tab); self.create_overview_tab(self.overview_tab); self.create_long_term_tab(self.long_term_tab)
    
    def create_gnss_tab(self, parent_tab):
        parent_tab.grid_rowconfigure(1, weight=1); parent_tab.grid_columnconfigure(0, weight=1)
        dashboard_frame = ttk.LabelFrame(parent_tab, text="Bảng điều khiển Giám sát Dịch chuyển", padding=10); dashboard_frame.grid(row=0, column=0, sticky="ew", pady=5)
        self.create_gnss_dashboard(dashboard_frame)
        sheet_frame = ttk.Frame(parent_tab); sheet_frame.grid(row=1, column=0, sticky="nsew", pady=(10,0))
        gnss_headers = ["Thời gian", "Tốc độ ngang\n(mm/s)", "Tốc độ đứng\n(mm/s)", "Hướng\n(°)", "Gia tốc ngang\n(mm/s²)", "Tổng dịch chuyển\n(m)", "Phân loại"]
        self.sheet_gnss = Sheet(sheet_frame, headers=gnss_headers, show_row_index=True); self.sheet_gnss.pack(fill=tk.BOTH, expand=True)
        self.sheet_gnss.set_options(font=("Arial", 10, "normal"), header_font=("Arial", 9, "bold"), align="center")
        self.sheet_gnss.column_width(column=0, width=80); self.sheet_gnss.column_width(column=6, width=120)
        ttk.Button(parent_tab, text="Lưu Bảng Phân tích GNSS (CSV)", command=self.save_gnss_to_csv, bootstyle="info-outline").grid(row=2, column=0, sticky='e', pady=5)

    def create_water_tab(self, parent_tab):
        parent_tab.grid_rowconfigure(0, weight=1); parent_tab.grid_columnconfigure(0, weight=1)
        sheet_frame = ttk.Frame(parent_tab); sheet_frame.grid(row=0, column=0, sticky="nsew")
        water_headers = ["Tên Cảm biến", "Giá trị (m)", "Trạng thái", "Thời gian"]
        self.sheet_water = Sheet(sheet_frame, headers=water_headers, show_row_index=True); self.sheet_water.pack(fill=tk.BOTH, expand=True)
        self.sheet_water.set_options(font=("Arial", 10, "normal"), header_font=("Arial", 10, "bold"), align="center")
        button_frame = ttk.Frame(parent_tab); button_frame.grid(row=1, column=0, sticky='e', pady=5)
        ttk.Button(button_frame, text="Xem Biểu Đồ", command=self.show_chart_window, bootstyle="info-outline").pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Lưu Bảng Nước (CSV)", command=self.save_water_to_csv, bootstyle="info-outline").pack(side=tk.LEFT)

    def create_overview_tab(self, parent_tab):
        parent_tab.grid_rowconfigure(0, weight=1); parent_tab.grid_columnconfigure(0, weight=1)
        sheet_frame = ttk.Frame(parent_tab); sheet_frame.grid(row=0, column=0, sticky="nsew")
        overview_headers = ["Thời gian", "Nguồn", "Thông điệp", "Trạng thái"]; self.sheet_overview = Sheet(sheet_frame, headers=overview_headers, show_row_index=True)
        self.sheet_overview.pack(fill=tk.BOTH, expand=True); self.sheet_overview.set_options(font=("Arial", 10, "normal"), header_font=("Arial", 10, "bold"), align="center")
        ttk.Button(parent_tab, text="Lưu Nhật ký Tổng quan (CSV)", command=self.save_overview_to_csv, bootstyle="info-outline").grid(row=1, column=0, sticky='e', pady=5)

    def create_long_term_tab(self, parent_tab):
        parent_tab.grid_columnconfigure(0, weight=1); parent_tab.grid_rowconfigure(1, weight=1)
        info_frame = ttk.LabelFrame(parent_tab, text="Tóm tắt Dịch chuyển Tích lũy", padding=10)
        info_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=5); info_frame.grid_columnconfigure(1, weight=1)
        self.lt_total_days_var = tk.StringVar(value="Số ngày giám sát: ---"); self.lt_total_disp_var = tk.StringVar(value="Tổng dịch chuyển: --- mm")
        self.lt_avg_speed_var = tk.StringVar(value="Tốc độ trung bình: --- mm/năm")
        ttk.Label(info_frame, textvariable=self.lt_total_days_var, font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky="w", padx=5)
        ttk.Label(info_frame, textvariable=self.lt_total_disp_var, font=('Arial', 10, 'bold')).grid(row=1, column=0, sticky="w", padx=5)
        ttk.Label(info_frame, textvariable=self.lt_avg_speed_var, font=('Arial', 10, 'bold')).grid(row=2, column=0, sticky="w", padx=5)
        chart_frame = ttk.Frame(parent_tab); chart_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", pady=(10,0))
        self.lt_fig = Figure(figsize=(8, 4), dpi=100); self.lt_ax = self.lt_fig.add_subplot(111); self.lt_canvas = FigureCanvasTkAgg(self.lt_fig, master=chart_frame)
        self.lt_canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        ttk.Button(parent_tab, text="Tải và Phân tích Dữ liệu Dài hạn", command=self.run_long_term_analysis, bootstyle="primary").grid(row=2, column=0, sticky="e", pady=10)

    def run_long_term_analysis(self):
        log_path = os.path.join("shifting", "long_term_displacement.jsonl")
        if not os.path.exists(log_path): messagebox.showwarning("Không tìm thấy dữ liệu", "Không tìm thấy file log dài hạn. Hệ thống cần chạy qua ít nhất một ngày để tạo dữ liệu.", parent=self.root); return
        checkpoints = []
        try:
            with open(log_path, "r", encoding='utf-8') as f:
                for line in f:
                    if line.strip(): checkpoints.append(json.loads(line))
        except Exception as e: messagebox.showerror("Lỗi đọc file", f"Không thể đọc hoặc phân tích file log dài hạn:\n{e}", parent=self.root); return
        if len(checkpoints) < 2: messagebox.showinfo("Chưa đủ dữ liệu", "Cần ít nhất 2 điểm chốt (2 ngày) để thực hiện phân tích dài hạn.", parent=self.root); return
        checkpoints.sort(key=lambda p: p["timestamp"]); start_point = checkpoints[0]; start_time = datetime.fromtimestamp(start_point["timestamp"])
        timestamps, displacements_mm = [], []
        for cp in checkpoints:
            current_time = datetime.fromtimestamp(cp["timestamp"]); days_since_start = (current_time - start_time).total_seconds() / (24 * 3600)
            disp_m = haversine_3d({"lat": start_point["lat"], "lon": start_point["lon"], "h": start_point["h"]}, {"lat": cp["lat"], "lon": cp["lon"], "h": cp["h"]})
            timestamps.append(days_since_start); displacements_mm.append(disp_m * 1000)
        total_days = timestamps[-1]; total_disp_mm = displacements_mm[-1]
        self.lt_total_days_var.set(f"Số ngày giám sát: {total_days:.1f} ngày"); self.lt_total_disp_var.set(f"Tổng dịch chuyển: {total_disp_mm:.2f} mm")
        speed_mm_per_year = (total_disp_mm / total_days) * 365.25 if total_days > 0 else 0
        self.lt_avg_speed_var.set(f"Tốc độ trung bình: {speed_mm_per_year:.2f} mm/năm")
        self.lt_ax.clear(); self.lt_ax.plot(timestamps, displacements_mm, marker='o', linestyle='-', color='b')
        self.lt_ax.set_title("Dịch chuyển Tích lũy Theo Thời gian", fontsize=14); self.lt_ax.set_xlabel("Số ngày kể từ khi bắt đầu giám sát", fontsize=12)
        self.lt_ax.set_ylabel("Tổng dịch chuyển (mm)", fontsize=12); self.lt_ax.grid(True); self.lt_fig.tight_layout(); self.lt_canvas.draw()
    
    def create_gnss_dashboard(self, parent):
        parent.grid_columnconfigure(1, weight=1)
        self.compass_canvas = tk.Canvas(parent, width=150, height=150, bg='white', highlightthickness=0)
        self.compass_canvas.grid(row=0, column=0, rowspan=5, padx=(10, 20), pady=5); self.draw_compass_base()
        def add_metric_label(text, row):
            ttk.Label(parent, text=text, font=('Arial', 10, 'bold')).grid(row=row, column=1, sticky='w', padx=5)
            var = tk.StringVar(value="---"); ttk.Label(parent, textvariable=var, font=('Arial', 10, 'normal')).grid(row=row, column=2, sticky='w', padx=5)
            return var
        self.h_speed_var = add_metric_label("Tốc độ ngang:", 0); self.v_speed_var = add_metric_label("Tốc độ đứng:", 1)
        self.direction_var = add_metric_label("Hướng dịch chuyển:", 2); self.acceleration_var = add_metric_label("Gia tốc ngang:", 3)
        self.displacement_var = add_metric_label("Tổng dịch chuyển:", 4)

    def draw_compass_base(self):
        w, h = 150, 150; self.compass_canvas.create_oval(5, 5, w-5, h-5, outline='gray', width=1)
        for i in range(0, 360, 30):
            rad = math.radians(i)
            self.compass_canvas.create_line(w/2 + 65*math.sin(rad), h/2 - 65*math.cos(rad), w/2 + 70*math.sin(rad), h/2 - 70*math.cos(rad), fill='gray')
        self.compass_canvas.create_text(w/2, 15, text="N", font=('Arial', 10, 'bold')); self.compass_canvas.create_text(w/2, h-15, text="S", font=('Arial', 10, 'bold'))
        self.compass_canvas.create_text(15, h/2, text="W", font=('Arial', 10, 'bold')); self.compass_canvas.create_text(w-15, h/2, text="E", font=('Arial', 10, 'bold'))
        self.compass_needle = self.compass_canvas.create_line(w/2, h/2, w/2, 25, arrow=tk.LAST, width=3, fill='red')

    def update_compass_needle(self, angle_deg):
        w, h = 150, 150; angle_rad = math.radians(angle_deg); end_x = w/2 + 60 * math.sin(angle_rad); end_y = h/2 - 60 * math.cos(angle_rad)
        self.compass_canvas.coords(self.compass_needle, w/2, h/2, end_x, end_y)

    def periodic_update(self):
        if not self.root.winfo_exists(): return
        for data_type, item in self.backend.get_gui_updates():
            if data_type == "clear_all":
                self.sheet_overview.set_sheet_data(data=[]); self.sheet_gnss.set_sheet_data(data=[]); self.sheet_water.set_sheet_data(data=[])
                if self.chart_window and self.chart_window.root.winfo_exists(): self.chart_window.update_plot()
                logger.info("GUI đã nhận tín hiệu và xóa tất cả các bảng.")
            elif data_type == "water_sensor": self.update_water_tab(item)
            elif data_type == "overview_log": self.update_overview_tab(item)
            elif data_type == "gnss_report":
                report_type = item.get("type")
                if report_type == "HEARTBEAT":
                    self.backend.last_shifting_heartbeat = time.time()
                    if not self.backend.is_shifting_responsive: logger.info("Tiến trình Shifting đã phản hồi trở lại."); self.backend.is_shifting_responsive = True
                elif report_type == "collection_status": self.backend.temp_status_text = f"SHIFTING: Đang thu thập dữ liệu... [{item.get('collected',0)}/{item.get('total','N/A')}]"
                elif report_type == "ultimate_analysis_report": self.backend.temp_status_text = None; self.update_gnss_tab(item); self.update_overview_with_gnss_report(item)
            elif data_type == "gnss_analysis_record": self.sheet_gnss.insert_row(item)
        self.update_status_label()
        if self.chart_window and self.chart_window.root.winfo_exists(): self.chart_window.update_plot()
        self.root.after(250, self.periodic_update)

    def update_gnss_tab(self, item_data):
        if 'analysis_data' in item_data and item_data['analysis_data']:
            data = item_data['analysis_data']
            h_speed, v_speed, direction, accel, displace = (data.get('horizontal_velocity_mmps', 0), data.get('vertical_velocity_mps', 0), data.get('direction_degrees', 0), data.get('horizontal_acceleration_mmps2', 0), data.get('total_displacement_m', 0))
            self.h_speed_var.set(f"{h_speed:.4f} mm/s"); v_speed_text = f"{abs(v_speed):.4f} mm/s {'(Lún xuống)' if v_speed < 0 else '(Trồi lên)'}"
            self.v_speed_var.set(v_speed_text); self.direction_var.set(f"{direction:.2f}°"); self.acceleration_var.set(f"{accel:.4f} mm/s²"); self.displacement_var.set(f"{displace:.3f} m")
            self.update_compass_needle(direction)
        ts = datetime.fromtimestamp(item_data.get('timestamp', time.time())).strftime("%H:%M:%S")
        analysis = item_data.get('analysis_data', {}); classification = item_data.get('classification_name', 'N/A')
        gnss_record = [ts, f"{analysis.get('horizontal_velocity_mmps', 0):.4f}", f"{analysis.get('vertical_velocity_mps', 0):.4f}", f"{analysis.get('direction_degrees', 0):.2f}", f"{analysis.get('horizontal_acceleration_mmps2', 0):.4f}", f"{analysis.get('total_displacement_m', 0):.3f}", classification]
        self.backend.gnss_analysis_data.append(gnss_record); self.sheet_gnss.insert_row(gnss_record)
        last_row_index = self.sheet_gnss.get_total_rows() - 1
        if last_row_index >= 0:
            self.sheet_gnss.see(row=last_row_index)
            if "rapid" in classification.lower(): self.sheet_gnss.highlight_rows([last_row_index], bg="#F8D7DA")
            elif "moderate" in classification.lower(): self.sheet_gnss.highlight_rows([last_row_index], bg="#FFF3CD")
            else: self.sheet_gnss.highlight_rows([last_row_index], bg="#E9ECEF")

    def update_water_tab(self, record):
        self.sheet_water.insert_row(record); last_row_index = self.sheet_water.get_total_rows() - 1
        if last_row_index >= 0:
            self.sheet_water.see(row=last_row_index); status = record[2]
            if status == "NGUY HIEM": self.sheet_water.highlight_rows([last_row_index], bg="#F8D7DA")
            elif status == "CANH BAO": self.sheet_water.highlight_rows([last_row_index], bg="#FFF3CD")
            else: self.sheet_water.highlight_rows([last_row_index], bg="#D4EDDA")
            
    def update_overview_tab(self, record):
        self.sheet_overview.insert_row(record); last_row_index = self.sheet_overview.get_total_rows() - 1
        if last_row_index >= 0:
            self.sheet_overview.see(row=last_row_index); status = record[3].upper()
            if "MAXIMUM" in status or "CRITICAL" in status or "NGUY HIEM" in status or "RAPID" in status: self.sheet_overview.highlight_rows([last_row_index], bg="#F8D7DA")
            elif "HIGH" in status or "WARN" in status or "CANH BAO" in status or "MODERATE" in status: self.sheet_overview.highlight_rows([last_row_index], bg="#FFF3CD")
            elif "SAFE" in status: self.sheet_overview.highlight_rows([last_row_index], bg="#D4EDDA")
            else: self.sheet_overview.highlight_rows([last_row_index], bg="#E9ECEF")

    def update_overview_with_gnss_report(self, item_data):
        ts = item_data.get('timestamp', time.time()); classification = item_data.get('classification_name', 'N/A')
        vel = item_data.get('classification_velocity_mm_s', 0); message = f"Vận tốc 3D: {vel:.4f} mm/s"
        self.backend.log_to_overview("Phân tích GNSS", message, classification, ts)

    def save_overview_to_csv(self): self._save_data_to_csv(list(self.backend.overview_log_data), ["Thời gian", "Nguồn", "Thông điệp", "Trạng thái"])
    def save_gnss_to_csv(self): self._save_data_to_csv(list(self.backend.gnss_analysis_data), ["Thời gian", "Tốc độ ngang (mm/s)", "Tốc độ đứng (mm/s)", "Hướng (°)", "Gia tốc ngang (mm/s²)", "Tổng dịch chuyển (m)", "Phân loại"])
    def save_water_to_csv(self): self._save_data_to_csv(list(self.backend.water_data), ["Tên Cảm biến", "Giá trị (m)", "Trạng thái", "Thời gian"])

    def _save_data_to_csv(self, data_to_save, headers):
        if not data_to_save: messagebox.showinfo("Thông báo", "Không có dữ liệu để lưu.", parent=self.root); return
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")], title="Lưu file CSV", parent=self.root)
        if not path: return
        threading.Thread(target=self._write_csv_in_background, args=(path, data_to_save, headers), daemon=True).start()

    def _write_csv_in_background(self, path, data_to_save, headers):
        try:
            import csv
            with open(path, "w", newline="", encoding='utf-8-sig') as f:
                writer = csv.writer(f); writer.writerow(headers); writer.writerows(data_to_save)
            if self.root.winfo_exists(): self.root.after(0, lambda: messagebox.showinfo("Thành công", f"Đã lưu dữ liệu vào {os.path.basename(path)}", parent=self.root))
        except Exception as e:
            if self.root.winfo_exists(): self.root.after(0, lambda: messagebox.showerror("Lỗi", f"Không thể lưu file:\n\n{e}", parent=self.root))

    def clear_all_gui_data(self):
        if messagebox.askokcancel("Xác nhận", "Bạn có chắc muốn xóa toàn bộ dữ liệu trên giao diện và trong bộ nhớ?", parent=self.root): self.backend.clear_all_data()

    def on_close_window(self): logger.info("Đã đóng cửa sổ giao diện. Gõ 'show' trong terminal để mở lại."); self.on_close_callback(); self.destroy_all_windows()
    def exit_program_graceful(self):
        if messagebox.askokcancel("Xác nhận Thoát", "Bạn có chắc muốn thoát hoàn toàn chương trình?", parent=self.root): self.on_close_callback(shutdown=True)

    def destroy_all_windows(self):
        for win in [self.main_settings_window, self.settings_window, self.chart_window, self.classification_win, self.root]:
            if win and win.winfo_exists(): win.destroy()
    
    def load_initial_data_to_vars(self):
        self.backend.load_config()
        self.broker_var.set(self.backend.broker); self.port_var.set(str(self.backend.port))
        self.user_var.set(self.backend.username); self.pass_var.set(self.backend.password)
        self.pub_topic_var.set(self.backend.publish_topic)
        self.warning_threshold_var.set(str(self.backend.warning_threshold) if self.backend.warning_threshold is not None else "")
        self.critical_threshold_var.set(str(self.backend.critical_threshold) if self.backend.critical_threshold is not None else "")
        self.sounds_dir_var.set(self.backend.sounds_dir); self.test_sound_path_var.set(self.backend.test_sound_file_path)

    def save_settings_to_file(self, parent_window, context):
        settings = self._get_settings_from_vars(context)
        errors = self._validate_config(settings, context=context)
        if errors: messagebox.showerror("Lỗi Cấu hình", "\n".join(errors), parent=parent_window); return False
        if self.backend.save_config(settings): messagebox.showinfo("Thành công", "Đã lưu cài đặt vào file.", parent=parent_window); return True
        else: messagebox.showerror("Lỗi", "Không thể lưu file cấu hình.", parent=parent_window); return False

    def apply_config_from_main(self):
        if not os.path.exists(Constants.CONFIG_FILE):
            messagebox.showwarning("Chưa có cấu hình", "Không tìm thấy file config.ini. Vui lòng vào cài đặt và lưu trước.", parent=self.root); return
        if messagebox.askokcancel("Xác nhận", "Áp dụng cấu hình sẽ khởi động lại các kết nối cần thiết. Tiếp tục?", parent=self.root):
            if self.backend.apply_new_config(): messagebox.showinfo("Thành công", "Đã áp dụng cấu hình mới.", parent=self.root); self.load_initial_data_to_vars()
            else: messagebox.showerror("Lỗi", "Không thể áp dụng cấu hình.", parent=self.root)

    def _get_settings_from_vars(self, context="all"):
        settings = {'broker': self.broker_var.get(), 'port': self.port_var.get(), 'username': self.user_var.get(), 'password': self.pass_var.get(),
                    'publish': self.pub_topic_var.get(), 'warning_threshold': self.warning_threshold_var.get(), 'critical_threshold': self.critical_threshold_var.get(),
                    'sounds_dir': self.sounds_dir_var.get(), 'test_sound_path': self.test_sound_path_var.get()}
        if context == "mqtt" and self.main_settings_window and self.main_settings_window.winfo_exists():
            settings['water_topics'] = self.water_topic_text.get("1.0", "end-1c").strip()
            settings['gnss_topics'] = self.gnss_topic_text.get("1.0", "end-1c").strip()
        return settings

    def _validate_config(self, settings, context="all"):
        errors = []
        if context in ["mqtt", "all"]:
            if not settings.get('broker'): errors.append("- MQTT Broker không được để trống")
            try:
                port = int(settings.get('port', 0))
                if not (1 <= port <= 65535): errors.append("- Port phải là một số từ 1-65535")
            except (ValueError, TypeError): errors.append("- Port phải là một số nguyên")
        if context in ["advanced", "all"]:
            try:
                warning_str, critical_str = settings.get('warning_threshold', ''), settings.get('critical_threshold', '')
                if not warning_str: errors.append("- Ngưỡng Cảnh Báo không được để trống")
                if not critical_str: errors.append("- Ngưỡng Nguy Hiểm không được để trống")
                if warning_str and critical_str and float(critical_str) <= float(warning_str): errors.append("- Ngưỡng Nguy Hiểm phải lớn hơn Ngưỡng Cảnh Báo")
            except (ValueError, TypeError): errors.append("- Các giá trị ngưỡng phải là số hợp lệ")
            if not os.path.isdir(settings.get('sounds_dir')): errors.append("- Đường dẫn thư mục âm thanh không hợp lệ")
        return errors

    def update_status_label(self):
        if self.backend.temp_status_text:
            text_to_show, color_to_show = self.backend.temp_status_text, "blue" if "Đang thu thập" in self.backend.temp_status_text else "red"
        else:
            am = self.backend.alert_manager
            active_status, w_lv, g_lv = am.active_alert_name, am.water_sm.current_level, am.gnss_sm.current_level
            text_to_show = f"Trạng thái: {active_status} (Nước: L{w_lv}, GNSS: L{g_lv})"
            active_priority = am.ALERT_PRIORITY.get(active_status, 0)
            if active_priority >= 7: color_to_show = "red"
            elif active_priority >= 3: color_to_show = "orange"
            else: color_to_show = "green" if self.backend.listening else "darkgray"
        if self.status_label.cget("text") != text_to_show: self.status_label.config(text=text_to_show, foreground=color_to_show)

    def on_test_siren_click(self):
        if not self.backend.test_siren_relay(): messagebox.showwarning("Không thể thực hiện", "Kiểm tra còi thất bại. Xem log để biết chi tiết.", parent=self.root)
        
    def open_main_settings_window(self):
        if self.main_settings_window and self.main_settings_window.winfo_exists(): self.main_settings_window.lift(); return
        self.main_settings_window = Toplevel(self.root); self.main_settings_window.title("Cài đặt Hệ thống & MQTT"); self.main_settings_window.geometry("550x550")
        self.main_settings_window.minsize(500, 500); self.main_settings_window.transient(self.root); container = ttk.Frame(self.main_settings_window)
        container.pack(fill=tk.BOTH, expand=True); container.grid_rowconfigure(0, weight=1); container.grid_columnconfigure(0, weight=1)
        content_frame = ttk.Frame(container, padding=15); content_frame.grid(row=0, column=0, sticky="nsew")
        def add_labeled_entry(frame, label, row, textvariable, show=None):
            ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w", pady=4, padx=5)
            entry = ttk.Entry(frame, textvariable=textvariable, show=show); entry.grid(row=row, column=1, sticky="ew", pady=4, padx=5); return entry
        mqtt_frame = ttk.LabelFrame(content_frame, text="Cài đặt MQTT", padding=10); mqtt_frame.pack(fill=tk.X, expand=False, pady=(0, 10))
        mqtt_frame.grid_columnconfigure(1, weight=1)
        add_labeled_entry(mqtt_frame, "MQTT Broker:", 0, self.broker_var); add_labeled_entry(mqtt_frame, "Port:", 1, self.port_var)
        add_labeled_entry(mqtt_frame, "Username:", 2, self.user_var); pass_entry = add_labeled_entry(mqtt_frame, "Password:", 3, self.pass_var, show="*")
        def toggle_pass(): pass_entry.config(show="" if pass_entry.cget("show") == "*" else "*")
        ttk.Button(mqtt_frame, text="👁", command=toggle_pass, width=2, bootstyle="light").grid(row=3, column=2, sticky="w", padx=2)
        add_labeled_entry(mqtt_frame, "Publish Topic:", 4, self.pub_topic_var)
        topics_frame = ttk.LabelFrame(content_frame, text="Topics Đăng ký (Subscribe)", padding=10); topics_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        topics_frame.grid_rowconfigure(1, weight=1); topics_frame.grid_rowconfigure(3, weight=1); topics_frame.grid_columnconfigure(0, weight=1)
        ttk.Label(topics_frame, text="Water Sub Topic (mỗi topic một dòng):").grid(row=0, column=0, sticky='w')
        self.water_topic_text = tk.Text(topics_frame, height=4, width=35, relief="solid", borderwidth=1)
        self.water_topic_text.grid(row=1, column=0, sticky='nsew', pady=5); self.water_topic_text.insert("1.0", "\n".join(self.backend.water_topics))
        ttk.Label(topics_frame, text="GNSS Sub Topic (mỗi topic một dòng):").grid(row=2, column=0, sticky='w', pady=(10,0))
        self.gnss_topic_text = tk.Text(topics_frame, height=4, width=35, relief="solid", borderwidth=1)
        self.gnss_topic_text.grid(row=3, column=0, sticky='nsew', pady=5); self.gnss_topic_text.insert("1.0", "\n".join(self.backend.gnss_topics))
        button_frame = ttk.Frame(container, padding=(0, 10, 0, 10)); button_frame.grid(row=1, column=0, sticky="ew")
        ttk.Button(button_frame, text="Đóng", command=self.main_settings_window.destroy, bootstyle="secondary").pack(side=tk.RIGHT)
        ttk.Button(button_frame, text="Lưu Cài đặt", command=lambda: self.save_settings_to_file(self.main_settings_window, 'mqtt'), bootstyle="primary").pack(side=tk.RIGHT, padx=10)

    def open_advanced_settings_window(self):
        if self.settings_window and self.settings_window.winfo_exists(): self.settings_window.lift(); return
        self.settings_window = Toplevel(self.root); self.settings_window.title("Cài đặt Nâng cao"); self.settings_window.geometry("800x600")
        self.settings_window.minsize(600, 500); self.settings_window.transient(self.root); container = ttk.Frame(self.settings_window)
        container.pack(fill=tk.BOTH, expand=True); container.grid_rowconfigure(0, weight=1); container.grid_columnconfigure(0, weight=1)
        notebook = ttk.Notebook(container); notebook.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        general_frame = ttk.Frame(notebook, padding="10"); notebook.add(general_frame, text='Chung & Âm thanh')
        gnss_frame = ttk.Frame(notebook, padding="10"); notebook.add(gnss_frame, text='GNSS')
        water_level_frame = ttk.Frame(notebook, padding="10"); notebook.add(water_level_frame, text='Mực nước')
        sounds_path_frame = ttk.LabelFrame(general_frame, text="Đường dẫn", padding=10); sounds_path_frame.pack(fill="x", expand=False)
        sounds_path_frame.grid_columnconfigure(0, weight=1)
        ttk.Label(sounds_path_frame, text="Thư mục Âm thanh Cảnh báo:").grid(row=0, column=0, sticky="w", pady=5, padx=5)
        ttk.Entry(sounds_path_frame, textvariable=self.sounds_dir_var, state="readonly").grid(row=1, column=0, sticky="ew", pady=5, padx=5)
        ttk.Button(sounds_path_frame, text="Chọn Thư mục...", command=self.select_sounds_directory).grid(row=1, column=1, sticky="w", pady=5, padx=(5,0))
        test_sound_frame = ttk.LabelFrame(general_frame, text="Kiểm tra Loa/Còi thủ công", padding=10); test_sound_frame.pack(fill="x", expand=False, pady=(10, 0))
        test_sound_frame.grid_columnconfigure(0, weight=1)
        ttk.Label(test_sound_frame, text="File âm thanh kiểm tra:").grid(row=0, column=0, columnspan=3, sticky="w", padx=5)
        ttk.Entry(test_sound_frame, textvariable=self.test_sound_path_var, state="readonly").grid(row=1, column=0, sticky="ew", pady=5, padx=5)
        ttk.Button(test_sound_frame, text="Chọn File...", command=self.select_test_sound_file).grid(row=1, column=1, sticky="w", pady=5, padx=(0,5))
        ttk.Button(test_sound_frame, text="Phát Âm thanh", command=self.play_test_sound, bootstyle="success").grid(row=1, column=2, sticky="w", pady=5, padx=5)
        ttk.Button(gnss_frame, text="Thiết lập Phân loại Tốc độ Dịch chuyển...", command=self.open_classification_window, bootstyle="info").pack(pady=(10, 10))
        ttk.Label(gnss_frame, text="Bảng phân loại tốc độ theo tiêu chuẩn Cruden-Varnes (1996).\nĐược dùng bởi tiến trình shifting.py để xác định mức độ nguy hiểm.").pack()
        threshold_frame = ttk.LabelFrame(water_level_frame, text="Ngưỡng cảnh báo Mực nước", padding=10); threshold_frame.pack(fill=tk.X, expand=False, pady=10)
        threshold_frame.grid_columnconfigure(1, weight=1)
        ttk.Label(threshold_frame, text="Ngưỡng Cảnh Báo (m):").grid(row=0, column=0, sticky="w", pady=5, padx=5)
        ttk.Entry(threshold_frame, textvariable=self.warning_threshold_var).grid(row=0, column=1, sticky="ew", pady=5, padx=5)
        ttk.Label(threshold_frame, text="Ngưỡng Nguy Hiểm (m):").grid(row=1, column=0, sticky="w", pady=5, padx=5)
        ttk.Entry(threshold_frame, textvariable=self.critical_threshold_var).grid(row=1, column=1, sticky="ew", pady=5, padx=5)
        button_frame_adv = ttk.Frame(container, padding=(0, 10, 0, 10)); button_frame_adv.grid(row=1, column=0, sticky="ew")
        ttk.Button(button_frame_adv, text="Đóng", command=self.settings_window.destroy, bootstyle="secondary").pack(side=tk.RIGHT)
        ttk.Button(button_frame_adv, text="Lưu Cài đặt", command=lambda: self.save_settings_to_file(self.settings_window, 'advanced'), bootstyle="primary").pack(side=tk.RIGHT, padx=10)

    def select_sounds_directory(self):
        initial_dir = self.sounds_dir_var.get();
        if not os.path.isdir(initial_dir): initial_dir = os.path.dirname(os.path.abspath(__file__))
        directory = filedialog.askdirectory(title="Chọn Thư mục chứa File Âm thanh", initialdir=initial_dir, parent=self.settings_window)
        if directory: self.sounds_dir_var.set(directory)
    
    def select_test_sound_file(self):
        initial_dir = self.sounds_dir_var.get();
        if not os.path.isdir(initial_dir): initial_dir = os.path.dirname(os.path.abspath(__file__))
        filepath = filedialog.askopenfilename(parent=self.settings_window,title="Chọn file âm thanh để kiểm tra",initialdir=initial_dir,filetypes=[("Sound Files", "*.mp3 *.wav"), ("All files", "*.*")])
        if filepath: self.test_sound_path_var.set(filepath)
    
    def play_test_sound(self):
        filepath = self.test_sound_path_var.get()
        if not filepath: messagebox.showwarning("Chưa chọn file", "Vui lòng chọn một file âm thanh để phát.", parent=self.settings_window); return
        result = self.backend.test_specific_sound(filepath)
        if result == "OK": messagebox.showinfo("Đang phát", f"Đang gửi lệnh phát file:\n{os.path.basename(filepath)}", parent=self.settings_window)
        elif result == "File not found": messagebox.showerror("Lỗi", "Không tìm thấy file âm thanh. Vui lòng chọn lại.", parent=self.settings_window)
        else: messagebox.showerror("Lỗi", "Hệ thống âm thanh (mixer) chưa sẵn sàng hoặc không phải môi trường Pi.", parent=self.settings_window)
    
    def open_classification_window(self):
        if self.classification_win and self.classification_win.winfo_exists(): self.classification_win.lift(); return
        self.classification_win = Toplevel(self.settings_window); self.classification_win.title("Bảng Phân Loại Tốc Độ Dịch Chuyển")
        self.classification_win.geometry("500x420"); self.classification_win.transient(self.settings_window); self.classification_win.grab_set()
        main_frame = ttk.Frame(self.classification_win, padding=10); main_frame.pack(fill="both", expand=True)
        classification_frame = ttk.LabelFrame(main_frame, text="Bảng phân loại", padding=10); classification_frame.pack(fill="both", expand=True, pady=(0, 10))
        columns = ("Phân loại", "mm/giây (Ngưỡng tối thiểu)"); self.gnss_tree = ttk.Treeview(classification_frame, columns=columns, show="headings", height=10)
        self.gnss_tree.heading(columns[0], text=columns[0]); self.gnss_tree.column(columns[0], width=200, anchor="w")
        self.gnss_tree.heading(columns[1], text=columns[1]); self.gnss_tree.column(columns[1], width=200, anchor="center")
        tree_scrollbar = ttk.Scrollbar(classification_frame, orient="vertical", command=self.gnss_tree.yview); self.gnss_tree.configure(yscrollcommand=tree_scrollbar.set)
        self.gnss_tree.pack(side="left", fill="both", expand=True); tree_scrollbar.pack(side="right", fill="y"); self.load_gnss_classification_data()
        control_frame = ttk.Frame(main_frame); control_frame.pack(fill="x", pady=(10, 0))
        ttk.Button(control_frame, text="Chỉnh sửa", command=self.edit_gnss_classification).pack(side="left", padx=(0, 5))
        ttk.Button(control_frame, text="Thêm mới", command=self.add_gnss_classification).pack(side="left", padx=5)
        ttk.Button(control_frame, text="Xóa", command=self.delete_gnss_classification).pack(side="left", padx=5)
        ttk.Button(control_frame, text="Khôi phục mặc định", command=self.reset_gnss_classification, bootstyle="danger").pack(side="left", padx=5)

    def load_gnss_classification_data(self):
        for item in self.gnss_tree.get_children(): self.gnss_tree.delete(item)
        sorted_data = sorted(self.backend.gnss_speed_classification, key=lambda x: float(x.get('mm_giay', 0)), reverse=True)
        self.backend.gnss_speed_classification = sorted_data
        for i, classification in enumerate(sorted_data):
            self.gnss_tree.insert("", "end", values=(classification.get("name", ""), classification.get("mm_giay", "")), tags=(str(i),))

    def edit_gnss_classification(self):
        selected = self.gnss_tree.selection();
        if not selected: messagebox.showwarning("Cảnh báo", "Vui lòng chọn một mục để chỉnh sửa.", parent=self.classification_win); return
        self.open_classification_editor(int(self.gnss_tree.item(selected[0])["tags"][0]))

    def add_gnss_classification(self): self.backend.gnss_speed_classification.append({"name": "Phân loại Mới", "mm_giay": "0.0"}); self.load_gnss_classification_data()
    def delete_gnss_classification(self):
        selected = self.gnss_tree.selection()
        if not selected: messagebox.showwarning("Cảnh báo", "Vui lòng chọn một mục để xóa.", parent=self.classification_win); return
        if messagebox.askyesno("Xác nhận", "Bạn có chắc muốn xóa mục này?", parent=self.classification_win):
            del self.backend.gnss_speed_classification[int(self.gnss_tree.item(selected[0])["tags"][0])]; self.load_gnss_classification_data()

    def reset_gnss_classification(self):
        if messagebox.askyesno("Xác nhận", "Bạn có chắc muốn khôi phục bảng về giá trị mặc định?\nThay đổi sẽ được áp dụng sau khi bạn lưu ở cửa sổ Cài đặt Nâng cao.", parent=self.classification_win):
            self.backend._reset_gnss_to_default(); self.load_gnss_classification_data()

    def open_classification_editor(self, index):
        editor_window = Toplevel(self.classification_win); editor_window.title("Chỉnh sửa phân loại tốc độ"); editor_window.geometry("400x150"); editor_window.transient(self.classification_win); editor_window.grab_set()
        classification = self.backend.gnss_speed_classification[index]; vars_dict = {}
        fields = [("Tên phân loại:", "name"), ("Ngưỡng tối thiểu (mm/giây):", "mm_giay")]
        main_frame = ttk.Frame(editor_window, padding="10"); main_frame.pack(fill="both", expand=True)
        for i, (label, key) in enumerate(fields):
            vars_dict[key] = tk.StringVar(value=str(classification.get(key, '')))
            ttk.Label(main_frame, text=label).grid(row=i, column=0, sticky="w", pady=5, padx=5)
            entry = ttk.Entry(main_frame, textvariable=vars_dict[key]); entry.grid(row=i, column=1, sticky="ew", pady=5, padx=5)
        main_frame.grid_columnconfigure(1, weight=1); button_frame = ttk.Frame(editor_window); button_frame.pack(fill="x", pady=10)
        def save_changes():
            try:
                if float(vars_dict['mm_giay'].get()) < 0: raise ValueError
            except ValueError: messagebox.showerror("Lỗi", "Ngưỡng phải là một số không âm.", parent=editor_window); return
            for key, var in vars_dict.items(): classification[key] = var.get().strip()
            self.load_gnss_classification_data(); editor_window.destroy()
        ttk.Button(button_frame, text="Lưu", command=save_changes).pack(side="left", padx=10, expand=True, fill='x')
        ttk.Button(button_frame, text="Hủy", command=editor_window.destroy).pack(side="right", padx=10, expand=True, fill='x')

    def show_chart_window(self):
        if self.chart_window and self.chart_window.root.winfo_exists(): self.chart_window.root.lift(); return
        self.chart_window = ChartWindow(self.root, self.backend)
        
# ===========================
# KHỐI ĐIỀU KHIỂN CHÍNH
# ===========================
class MainController:
    def __init__(self, backend, command_queue):
        self.backend = backend; self.command_queue = command_queue; self.app_instance = None
        self.root = ttk.Window(); self.root.withdraw()
    def run(self): self.check_for_commands(); self.root.mainloop()
    def check_for_commands(self):
        try:
            command = self.command_queue.get_nowait()
            if command == 'show': self.create_gui_window()
            elif command == 'exit': self.handle_shutdown()
        except queue.Empty: pass
        finally:
            if not self.backend.exiting and self.root.winfo_exists(): self.root.after(100, self.check_for_commands)
    def create_gui_window(self):
        if self.app_instance and self.app_instance.root.winfo_exists(): logger.info("Giao diện đã đang chạy."); self.app_instance.root.lift(); return
        logger.info("Đang khởi động giao diện người dùng..."); toplevel_window = Toplevel(self.root); self.app_instance = AppGUI(toplevel_window, self.backend, self.on_gui_close)
    def on_gui_close(self, shutdown=False): 
        self.app_instance = None;
        if shutdown: self.command_queue.put('exit')
    def handle_shutdown(self):
        logger.info("Nhận lệnh thoát...");
        if self.app_instance: self.app_instance.destroy_all_windows()
        self.backend.cleanup_on_exit()
        if self.root.winfo_exists(): self.root.destroy()

def console_input_listener(cmd_queue: queue.Queue):
    while True:
        try:
            command = input().strip().lower()
            if command: cmd_queue.put(command)
            if command in ['exit', 'restart']: break
        except (EOFError, KeyboardInterrupt): cmd_queue.put('exit'); break

def signal_handler(signum, frame): logger.info("\nNhận tín hiệu ngắt (Ctrl+C), đang thoát..."); command_queue.put('exit')

if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal_handler)
    command_queue = queue.Queue()
    backend_instance = Backend()
    backend_instance.start_background_tasks()
    console_thread = threading.Thread(target=console_input_listener, args=(command_queue,), daemon=True)
    console_thread.start()
    logger.info("="*50); logger.info("Chương trình Giám sát Sạt lở đã sẵn sàng."); logger.info("Gõ 'show' để mở giao diện, 'exit' để thoát."); logger.info("="*50)
    main_controller = MainController(backend_instance, command_queue)
    if len(sys.argv) == 1 or 'show' in sys.argv: command_queue.put('show')
    main_controller.run()
    logger.info("Chương trình đã kết thúc.")
