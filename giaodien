# led.py (Phi√™n b·∫£n T·ªïng h·ª£p - 4 Tab Chuy√™n nghi·ªáp)
import tkinter as tk
from tkinter import messagebox, filedialog, Toplevel
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tksheet import Sheet
import paho.mqtt.client as mqtt
import json
from datetime import datetime
import threading
import time
import warnings
import configparser
import signal
import os
import sys
import queue
from collections import deque
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt
import numpy as np
import logging
from logging.handlers import TimedRotatingFileHandler
import atexit
import subprocess
import math
import traceback

# --- THI·∫æT L·∫¨P M√îI TR∆Ø·ªúNG V√Ä C·∫¢NH B√ÅO ---
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1"
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", message="Unable to import Axes3D")

# --- C√ÅC TH∆Ø VI·ªÜN ƒê·∫∂C TH√ô PI ---
try:
    import RPi.GPIO as GPIO
    import pygame
    IS_PI = True
except (ImportError, RuntimeError):
    IS_PI = False
    print("C·∫¢NH B√ÅO: Kh√¥ng t√¨m th·∫•y th∆∞ vi·ªán RPi.GPIO ho·∫∑c pygame. Ch∆∞∆°ng tr√¨nh s·∫Ω ch·∫°y ·ªü ch·∫ø ƒë·ªô kh√¥ng c√≥ ph·∫ßn c·ª©ng (no-hardware mode).")

# --- C·∫•u h√¨nh logging n√¢ng cao v·ªõi xoay v√≤ng v√† th∆∞ m·ª•c ri√™ng ---
LOG_DIRECTORY = "sensor_monitor"
os.makedirs(LOG_DIRECTORY, exist_ok=True)

logger = logging.getLogger()
logger.setLevel(logging.INFO)
if not logger.handlers:
    file_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    console_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')

    log_file_path = os.path.join(LOG_DIRECTORY, 'sensor_monitor.log')
    file_handler = TimedRotatingFileHandler(log_file_path, when='midnight', interval=1, backupCount=30, encoding='utf-8')
    file_handler.setLevel(logging.INFO)
    file_handler.setFormatter(file_formatter)
    logger.addHandler(file_handler)

    error_log_file_path = os.path.join(LOG_DIRECTORY, 'sensor_monitor_error.log')
    error_file_handler = TimedRotatingFileHandler(error_log_file_path, when='midnight', interval=1, backupCount=30, encoding='utf-8')
    error_file_handler.setLevel(logging.ERROR)
    error_file_handler.setFormatter(file_formatter)
    logger.addHandler(error_file_handler)

    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)

# ==============================================================================
# QU·∫¢N L√ù H·∫∞NG S·ªê
# ==============================================================================
class Constants:
    CONFIG_FILE = 'config.ini'
    SESSION_FILE = "session.json"
    DEFAULT_SOUNDS_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "sounds")
    SIREN_RELAY_PIN = 5
    MAX_PLOT_POINTS = 10000
    MAX_SENSOR_RECORDS = 10000
    CHART_POINTS_PER_VIEW = 40
    DEFAULT_BROKER = "aitogy.xyz"
    DEFAULT_PORT = 1883
    DEFAULT_USER = "abc"
    DEFAULT_PASS = "xyz"
    DEFAULT_WARN_THRESHOLD = 1.0
    DEFAULT_CRIT_THRESHOLD = 1.2
    DATA_CLEAR_SIGNAL = "CLEAR_ALL_DATA"
    WARNING_REPEAT_INTERVAL = 6
    DECREASING_REPEAT_INTERVAL = 10
    SAFE_READINGS_REQUIRED_INITIAL = 10
    SAFE_READINGS_REQUIRED_RETURN_1 = 10
    SAFE_READINGS_REQUIRED_RETURN_2 = 15

# ==============================================================================
# QU·∫¢N L√ù C·∫¢NH B√ÅO
# ==============================================================================
class AlertManager:
    def __init__(self, backend_ref):
        self.backend = backend_ref
        self.current_level = 0
        self.safe_readings_count = 0
        self.warning_readings_count = 0
        self.decreasing_warning_count = 0
        self.was_in_high_level_state = False
        self.initial_safe_played = False
        self.safe_return_phase = 0
        self.alert_thread = None
    def _play_sequence_in_thread(self, sound_list, loop=False, activate_relay=False):
        self.stop_all_alerts()
        if self.alert_thread and self.alert_thread.is_alive(): return
        def target():
            if not self.backend.mixer_initialized: return
            if activate_relay: self.backend.activate_siren_relay()
            while not self.backend.exiting:
                for sound in sound_list:
                    if sound and not self.backend.exiting:
                        sound.play()
                        while IS_PI and pygame.mixer.get_busy() and not self.backend.exiting: time.sleep(0.1)
                if not loop: break
        self.alert_thread = threading.Thread(target=target, daemon=True)
        self.alert_thread.start()
    def stop_all_alerts(self):
        if self.backend.mixer_initialized: pygame.mixer.stop()
        self.backend.deactivate_siren_relay()
        self.alert_thread = None
    def trigger_critical_event_alarm(self):
        if self.current_level != 3:
            logger.critical("!!! S·ª∞ KI·ªÜN KH·∫®N C·∫§P GNSS ƒê∆Ø·ª¢C K√çCH HO·∫†T !!!")
            self.current_level = 3
            self.was_in_high_level_state = True
            self._play_sequence_in_thread([self.backend.siren_sound, self.backend.critical_sound], loop=True, activate_relay=True)
    def process_new_water_value(self, value):
        if self.current_level == 3: return 2
        previous_level = self.current_level
        new_level = self._calculate_alert_level(value)
        if new_level == 0: self._handle_safe_state()
        elif new_level == 1: self._handle_warning_state(previous_level)
        elif new_level == 2: self._handle_critical_state()
        if new_level != previous_level:
            if new_level == 0 and previous_level > 0:
                self.safe_readings_count = 1
                logger.info("Tr·∫°ng th√°i nguy hi·ªÉm ƒë√£ k·∫øt th√∫c. T·∫Øt c√≤i b√°o ƒë·ªông.")
                self.stop_all_alerts()
            logger.info(f"C·∫£nh b√°o n∆∞·ªõc: Chuy·ªÉn tr·∫°ng th√°i {previous_level} -> {new_level}")
        self.current_level = new_level
        return new_level
    def _calculate_alert_level(self, value):
        if value >= self.backend.critical_threshold: return 2
        elif value >= self.backend.warning_threshold: return 1
        return 0
    def _handle_safe_state(self):
        self.warning_readings_count = 0
        self.decreasing_warning_count = 0
        self.safe_readings_count += 1
        if not self.was_in_high_level_state:
            if not self.initial_safe_played and self.safe_readings_count == Constants.SAFE_READINGS_REQUIRED_INITIAL:
                self._play_sequence_in_thread([self.backend.safe_sound_1], activate_relay=False)
                self.initial_safe_played = True
        else:
            if self.safe_return_phase == 0: self.safe_return_phase = 1
            if self.safe_return_phase == 1 and self.safe_readings_count == Constants.SAFE_READINGS_REQUIRED_RETURN_1:
                self._play_sequence_in_thread([self.backend.safe_sound_2], activate_relay=False)
                self.safe_return_phase = 2
            elif self.safe_return_phase == 2 and self.safe_readings_count == Constants.SAFE_READINGS_REQUIRED_RETURN_2:
                self._play_sequence_in_thread([self.backend.safe_sound_2], activate_relay=False)
                self.safe_return_phase = 3
                self.was_in_high_level_state = False
                self.initial_safe_played = True
    def _handle_warning_state(self, previous_level):
        self.safe_readings_count = 0
        self.safe_return_phase = 0
        if not self.was_in_high_level_state: self.was_in_high_level_state = True
        if previous_level == 0:
            self._play_sequence_in_thread([self.backend.siren_sound, self.backend.warning_sound], activate_relay=True)
            self.warning_readings_count = 1
            self.decreasing_warning_count = 0
        elif previous_level == 2:
            self._play_sequence_in_thread([self.backend.decreasing_sound], activate_relay=True)
            self.decreasing_warning_count = 1
            self.warning_readings_count = 0
        elif previous_level == 1:
            if self.warning_readings_count > 0:
                self.warning_readings_count += 1
                if self.warning_readings_count % Constants.WARNING_REPEAT_INTERVAL == 0: self._play_sequence_in_thread([self.backend.siren_sound, self.backend.warning_sound], activate_relay=True)
            elif self.decreasing_warning_count > 0:
                self.decreasing_warning_count += 1
                if self.decreasing_warning_count % Constants.DECREASING_REPEAT_INTERVAL == 0: self._play_sequence_in_thread([self.backend.decreasing_sound], activate_relay=True)
    def _handle_critical_state(self):
        self.safe_readings_count = 0
        self.warning_readings_count = 0
        self.decreasing_warning_count = 0
        self.safe_return_phase = 0
        if not self.was_in_high_level_state: self.was_in_high_level_state = True
        self._play_sequence_in_thread([self.backend.siren_sound, self.backend.critical_sound, self.backend.siren_sound], activate_relay=True)


# ==============================================================================
# L·ªöP LOGIC N·ªÄN (BACKEND)
# ==============================================================================
class Backend:
    def __init__(self):
        self.listening = False
        self.exiting = False
        self.status_text = "Tr·∫°ng th√°i: TH·ª¶ C√îNG"
        self.status_color = "red"
        self.temp_status_text = None
        self.config = configparser.ConfigParser()
        self.broker = Constants.DEFAULT_BROKER
        self.port = Constants.DEFAULT_PORT
        self.username = Constants.DEFAULT_USER
        self.password = Constants.DEFAULT_PASS
        self.publish_topic = ""
        self.water_topics = []
        self.gnss_topics = []
        self.subscribe_topics = []
        self.warning_threshold = Constants.DEFAULT_WARN_THRESHOLD
        self.critical_threshold = Constants.DEFAULT_CRIT_THRESHOLD
        self.sounds_dir = Constants.DEFAULT_SOUNDS_DIR
        self.mixer_initialized = False
        self.warning_sound, self.critical_sound, self.siren_sound = None, None, None
        self.decreasing_sound, self.safe_sound_1, self.safe_sound_2 = None, None, None
        
        self.overview_log_data = deque(maxlen=Constants.MAX_SENSOR_RECORDS)
        self.water_data = deque(maxlen=Constants.MAX_SENSOR_RECORDS)
        self.gnss_analysis_data = deque(maxlen=Constants.MAX_SENSOR_RECORDS)

        self.plot_data_points = deque(maxlen=Constants.MAX_PLOT_POINTS)
        self.gui_update_queue = queue.Queue()
        self.client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2, protocol=mqtt.MQTTv311)
        self.client.on_connect = self.on_connect
        self.client.on_disconnect = self.on_disconnect
        self.client.on_message = self.on_message
        self.shifting_process = None
        self.alert_manager = AlertManager(self)
        self.gnss_speed_classification = []
        self.last_shifting_heartbeat = 0
        self.is_shifting_responsive = True

        self.load_config()
        self.setup_audio_mixer()
        self.setup_gpio()
        atexit.register(self.cleanup_on_exit)

    def on_message(self, client, userdata, msg):
        if not self.listening or self.exiting: return
        if msg.topic in self.gnss_topics: return
        try:
            data = json.loads(msg.payload.decode('utf-8'))
            if "value" in data:
                value = float(data.get("value"))
                new_level = self.alert_manager.process_new_water_value(value)
                name = data.get("sensorname", msg.topic)
                ts = float(data.get("timestamp", time.time()))
                dt_object = datetime.fromtimestamp(ts)
                status = "NGUY HIEM" if new_level == 2 else ("CANH BAO" if new_level == 1 else "AN TOAN")
                
                water_record = (name, f"{value:.4f}", status, dt_object.strftime("%H:%M:%S %d-%m"))
                overview_record = (dt_object.strftime("%H:%M:%S"), "C·∫£m bi·∫øn N∆∞·ªõc", f"{name}: {value:.4f}", status)

                self.water_data.append(water_record)
                self.overview_log_data.append(overview_record)
                self.plot_data_points.append((dt_object, value))
                
                self.gui_update_queue.put(("water_sensor", water_record))
                self.gui_update_queue.put(("overview_log", overview_record))

                if self.publish_topic: self.client.publish(self.publish_topic, f"{name},{value},{status},{ts}")
        except (json.JSONDecodeError, ValueError, KeyError) as e:
            logger.error(f"L·ªói x·ª≠ l√Ω message: {e} | Payload: {msg.payload.decode('utf-8', errors='ignore')}")

    def _read_shifting_output(self, pipe):
        for line in iter(pipe.readline, ''):
            try:
                line_str = line.strip()
                if not line_str: continue
                data = json.loads(line_str)
                self.gui_update_queue.put(("gnss_report", data))
            except json.JSONDecodeError: logger.warning(f"Nh·∫≠n ƒë∆∞·ª£c d√≤ng kh√¥ng ph·∫£i JSON t·ª´ shifting.py: {line_str}")
            except Exception as e:
                logger.error(f"L·ªói trong lu·ªìng ƒë·ªçc shifting.py: {e}")
                break
        pipe.close()
        logger.info("Lu·ªìng ƒë·ªçc k·∫øt qu·∫£ t·ª´ shifting.py ƒë√£ d·ª´ng.")

    def clear_all_data(self):
        self.overview_log_data.clear()
        self.water_data.clear()
        self.gnss_analysis_data.clear()
        self.plot_data_points.clear()
        self.gui_update_queue.put(("clear_all", None))
        logger.info("ƒê√£ x√≥a d·ªØ li·ªáu n·ªÅn.")

    def save_session_data(self, silent=False):
        if not silent: logger.info("ƒêang l∆∞u tr·∫°ng th√°i hi·ªán t·∫°i v√†o file...")
        try:
            plot_data_serializable = [(dt.isoformat(), val) for dt, val in self.plot_data_points]
            session = {
                "overview_log_data": list(self.overview_log_data),
                "water_data": list(self.water_data),
                "gnss_analysis_data": list(self.gnss_analysis_data),
                "plot_data_points": plot_data_serializable
            }
            with open(Constants.SESSION_FILE, "w", encoding='utf-8') as f: json.dump(session, f)
            if not silent: logger.info(f"ƒê√£ l∆∞u tr·∫°ng th√°i v√†o {Constants.SESSION_FILE}")
        except Exception as e: logger.error(f"L·ªói khi l∆∞u tr·∫°ng th√°i: {e}")

    def load_session_data(self):
        if not os.path.exists(Constants.SESSION_FILE): return
        logger.info(f"T√¨m th·∫•y file tr·∫°ng th√°i {Constants.SESSION_FILE}, ƒëang t·∫£i l·∫°i d·ªØ li·ªáu...")
        try:
            with open(Constants.SESSION_FILE, "r", encoding='utf-8') as f: session = json.load(f)
            
            for record in session.get("overview_log_data", []):
                self.overview_log_data.append(tuple(record))
                self.gui_update_queue.put(("overview_log", tuple(record)))
            
            for record in session.get("water_data", []):
                self.water_data.append(tuple(record))
                self.gui_update_queue.put(("water_sensor", tuple(record)))

            for record in session.get("gnss_analysis_data", []):
                self.gnss_analysis_data.append(tuple(record))
                self.gui_update_queue.put(("gnss_analysis_record", tuple(record)))

            plot_data_serializable = session.get("plot_data_points", [])
            self.plot_data_points.clear()
            for dt_str, val in plot_data_serializable: self.plot_data_points.append((datetime.fromisoformat(dt_str), val))
            
            logger.info("ƒê√£ t·∫£i l·∫°i d·ªØ li·ªáu th√†nh c√¥ng.")
        except Exception as e: logger.error(f"L·ªói khi t·∫£i tr·∫°ng th√°i: {e}")
        finally:
            if os.path.exists(Constants.SESSION_FILE): os.remove(Constants.SESSION_FILE)

    def update_and_reconnect(self, settings: dict):
        old_shifting_signature = (
            f"{self.broker}-{self.port}-{self.username}-{self.password}-"
            f"{'-'.join(sorted(self.gnss_topics))}-"
            f"{json.dumps(self.gnss_speed_classification, sort_keys=True)}"
        )
        old_water_topics = self.water_topics

        self.broker = settings['broker']
        self.port = int(settings['port'])
        self.username = settings['username']
        self.password = settings['password']
        self.publish_topic = settings['publish']
        self.water_topics = [t.strip() for t in settings.get('water_topics', '').splitlines() if t.strip()]
        self.gnss_topics = [t.strip() for t in settings.get('gnss_topics', '').splitlines() if t.strip()]
        self.subscribe_topics = self.water_topics
        self.warning_threshold = float(settings['warning_threshold'])
        self.critical_threshold = float(settings['critical_threshold'])
        new_sounds_dir = settings['sounds_dir']
        if new_sounds_dir != self.sounds_dir:
            self.sounds_dir = new_sounds_dir
            logger.info(f"ƒê∆∞·ªùng d·∫´n √¢m thanh ƒë·ªïi, t·∫£i l·∫°i t·ª´: {self.sounds_dir}")
            self.setup_audio_mixer()
        
        self.save_config()

        new_shifting_signature = (
            f"{self.broker}-{self.port}-{self.username}-{self.password}-"
            f"{'-'.join(sorted(self.gnss_topics))}-"
            f"{json.dumps(self.gnss_speed_classification, sort_keys=True)}"
        )
        needs_shifting_restart = (old_shifting_signature != new_shifting_signature)
        needs_led_mqtt_reconnect = (set(old_water_topics) != set(self.water_topics))

        if not self.listening:
            logger.info("C√†i ƒë·∫∑t ƒë√£ ƒë∆∞·ª£c l∆∞u. H·ªá th·ªëng ƒëang ·ªü ch·∫ø ƒë·ªô Th·ªß c√¥ng.")
            return

        if needs_shifting_restart:
            logger.info("Ph√°t hi·ªán thay ƒë·ªïi trong c√†i ƒë·∫∑t GNSS ho·∫∑c Broker. ƒêang kh·ªüi ƒë·ªông l·∫°i to√†n b·ªô h·ªá th·ªëng...")
            self.toggle_off()
            time.sleep(1)
            self.toggle_on()
        elif needs_led_mqtt_reconnect:
            logger.info("Ph√°t hi·ªán thay ƒë·ªïi trong Topic N∆∞·ªõc. Ch·ªâ k·∫øt n·ªëi l·∫°i MQTT cho c·∫£m bi·∫øn n∆∞·ªõc...")
            try:
                self.client.loop_stop()
                self.client.disconnect()
            except Exception: pass
            try:
                self.client.connect_async(self.broker, self.port, 60)
                self.client.loop_start()
            except Exception as e:
                logger.error(f"L·ªói khi k·∫øt n·ªëi l·∫°i MQTT cho led.py: {e}")
                self.status_text, self.status_color = "Tr·∫°ng th√°i: L·ªñI K·∫æT N·ªêI", "red"
        else:
            logger.info("C√°c c√†i ƒë·∫∑t kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn k·∫øt n·ªëi ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.")
    
    def _reset_gnss_to_default(self):
        logger.info("ƒêang kh√¥i ph·ª•c b·∫£ng ph√¢n lo·∫°i GNSS v·ªÅ ti√™u chu·∫©n Cruden & Varnes (1996) / IUGS.")
        self.gnss_speed_classification = [
            {"name": "C·ª±c k·ª≥ nhanh", "mm_giay": 5000}, {"name": "R·∫•t nhanh", "mm_giay": 50},
            {"name": "Nhanh", "mm_giay": 0.5}, {"name": "Trung b√¨nh", "mm_giay": 0.017},
            {"name": "Ch·∫≠m", "mm_giay": 4.7e-5}, {"name": "R·∫•t ch·∫≠m", "mm_giay": 5.0e-7},
            {"name": "C·ª±c k·ª≥ ch·∫≠m", "mm_giay": 0}
        ]
    def start_background_tasks(self):
        self.load_session_data()
        threading.Thread(target=self.auto_clear_scheduler, daemon=True).start()
        threading.Thread(target=self.check_shifting_health, daemon=True).start()
        logger.info("ƒê√£ kh·ªüi ch·∫°y c√°c t√°c v·ª• n·ªÅn.")
    def check_shifting_health(self):
        while not self.exiting:
            if self.listening and self.shifting_process and self.shifting_process.poll() is None:
                if time.time() - self.last_shifting_heartbeat > 60 and self.last_shifting_heartbeat != 0:
                    if self.is_shifting_responsive:
                        logger.critical("TI·∫æN TR√åNH SHIFTING KH√îNG PH·∫¢N H·ªíI! ƒêang th·ª≠ kh·ªüi ƒë·ªông l·∫°i...")
                        self.is_shifting_responsive = False
                        self.temp_status_text = "L·ªñI: Ti·∫øn tr√¨nh ph√¢n t√≠ch kh√¥ng ph·∫£n h·ªìi!"
                        self.stop_shifting_process()
                        time.sleep(2)
                        self.start_shifting_process()
            time.sleep(15)
    def start_shifting_process(self):
        if self.shifting_process and self.shifting_process.poll() is None:
            logger.info("Ti·∫øn tr√¨nh shifting.py ƒë√£ ƒëang ch·∫°y.")
            return
        if not self.gnss_topics:
            logger.warning("Kh√¥ng c√≥ topic GNSS n√†o ƒë·ªÉ kh·ªüi ƒë·ªông shifting.py.")
            return
        try:
            classification_table_json = json.dumps(self.gnss_speed_classification)
            command = [sys.executable, '-u', 'shifting.py', '--broker', self.broker, '--port', str(self.port), '--classification-table', classification_table_json]
            if self.username: command.extend(['--username', self.username])
            if self.password: command.extend(['--password', self.password])
            for topic in self.gnss_topics: command.extend(['--topic', topic])
            logger.info(f"ƒêang kh·ªüi ch·∫°y shifting.py...")
            self.shifting_process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8', errors='ignore')
            threading.Thread(target=self._read_shifting_output, args=(self.shifting_process.stdout,), daemon=True).start()
            threading.Thread(target=self._log_process_errors, args=(self.shifting_process.stderr, "SHIFTING"), daemon=True).start()
            logger.info("ƒê√£ kh·ªüi ƒë·ªông ti·∫øn tr√¨nh shifting.py v√† lu·ªìng ƒë·ªçc k·∫øt qu·∫£.")
        except Exception as e:
            logger.error(f"L·ªói kh·ªüi ƒë·ªông shifting.py: {e}")
            if self.shifting_process: self.shifting_process.kill()
            self.shifting_process = None
    def _log_process_errors(self, pipe, process_name):
        for line in iter(pipe.readline, ''):
            error_message = line.strip()
            if error_message: logger.error(f"[{process_name}_ERROR]: {error_message}")
        pipe.close()
    def stop_shifting_process(self):
        if self.shifting_process and self.shifting_process.poll() is None:
            try:
                logger.info("ƒêang d·ª´ng ti·∫øn tr√¨nh shifting.py...")
                self.shifting_process.terminate()
                self.shifting_process.wait(timeout=5)
                logger.info(f"ƒê√£ d·ª´ng th√†nh c√¥ng ti·∫øn tr√¨nh shifting.py.")
            except subprocess.TimeoutExpired:
                logger.warning("Ti·∫øn tr√¨nh shifting.py kh√¥ng ph·∫£n h·ªìi, bu·ªôc d·ª´ng (kill).")
                self.shifting_process.kill()
            except Exception as e: logger.error(f"L·ªói khi d·ª´ng shifting.py: {e}")
        self.shifting_process = None
    def setup_audio_mixer(self):
        if not IS_PI:
            self.mixer_initialized = False
            return
        try:
            logger.info("ƒêang kh·ªüi t·∫°o audio mixer...")
            pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=4096)
            self.mixer_initialized = True
            self.siren_sound = self._load_sound("coi1.mp3")
            self.warning_sound = self._load_sound("warning.mp3")
            self.critical_sound = self._load_sound("danger.mp3")
            self.decreasing_sound = self._load_sound("decrease.mp3")
            self.safe_sound_1 = self._load_sound("safe.mp3")
            self.safe_sound_2 = self._load_sound("safe2.mp3")
            logger.info("Audio mixer ƒë√£ s·∫µn s√†ng.")
        except Exception as e:
            logger.error(f"Kh√¥ng th·ªÉ kh·ªüi t·∫°o pygame mixer: {e}")
            self.mixer_initialized = False
    def _load_sound(self, filename):
        if not IS_PI: return None
        path = os.path.join(self.sounds_dir, filename)
        if os.path.exists(path):
            try: return pygame.mixer.Sound(path)
            except Exception as e:
                logger.error(f"L·ªói khi t·∫£i file √¢m thanh '{path}': {e}")
                return None
        logger.warning(f"Kh√¥ng t√¨m th·∫•y file √¢m thanh: {path}")
        return None
    def load_config(self):
        if not os.path.exists(Constants.CONFIG_FILE):
            logger.warning(f"File c·∫•u h√¨nh '{Constants.CONFIG_FILE}' kh√¥ng t·ªìn t·∫°i. T·∫°o m·∫∑c ƒë·ªãnh.")
            self._reset_gnss_to_default()
            self.save_config()
            return
        try:
            self.config.read(Constants.CONFIG_FILE, encoding='utf-8')
            if "MQTT" in self.config:
                mqtt_cfg = self.config["MQTT"]
                self.broker = mqtt_cfg.get("broker", self.broker)
                self.port = mqtt_cfg.getint("port", self.port)
                self.username = mqtt_cfg.get("username", self.username)
                self.password = mqtt_cfg.get("password", self.password)
                self.water_topics = [t.strip() for t in mqtt_cfg.get("water_sub_topic", "").splitlines() if t.strip()]
                self.gnss_topics = [t.strip() for t in mqtt_cfg.get("gnss_sub_topic", "").splitlines() if t.strip()]
                self.subscribe_topics = self.water_topics
                self.publish_topic = mqtt_cfg.get("publish", self.publish_topic)
            if "Settings" in self.config:
                settings_cfg = self.config["Settings"]
                self.warning_threshold = settings_cfg.getfloat("warning_threshold", self.warning_threshold)
                self.critical_threshold = settings_cfg.getfloat("critical_threshold", self.critical_threshold)
                self.sounds_dir = settings_cfg.get("sounds_dir", self.sounds_dir)
            if "GNSS_Classification" in self.config and self.config['GNSS_Classification']: self._load_gnss_from_config(self.config["GNSS_Classification"])
            else: self._reset_gnss_to_default()
            self.setup_audio_mixer()
        except Exception as e:
            logger.error(f"L·ªói t·∫£i c·∫•u h√¨nh: {e}")
            self._reset_gnss_to_default()
    def _load_gnss_from_config(self, gnss_cfg):
        items_dict = {}
        for key, value in gnss_cfg.items():
            if key.startswith('item_'):
                parts = key.split('_', 2)
                if len(parts) == 3:
                    item_index, attr_name = int(parts[1]), parts[2]
                    if item_index not in items_dict: items_dict[item_index] = {}
                    items_dict[item_index][attr_name] = value
        if items_dict: self.gnss_speed_classification = [items_dict[i] for i in sorted(items_dict.keys())]
    def save_config(self):
        try:
            self.config['MQTT'] = {'broker': self.broker, 'port': self.port, 'username': self.username, 'password': self.password,
                'water_sub_topic': "\n".join(self.water_topics), 'gnss_sub_topic': "\n".join(self.gnss_topics), 'publish': self.publish_topic}
            self.config['Settings'] = {'warning_threshold': self.warning_threshold, 'critical_threshold': self.critical_threshold, 'sounds_dir': self.sounds_dir}
            gnss_section = {}
            for i, item in enumerate(self.gnss_speed_classification):
                for key, value in item.items(): gnss_section[f'item_{i}_{key}'] = str(value)
            self.config['GNSS_Classification'] = gnss_section
            with open(Constants.CONFIG_FILE, 'w', encoding='utf-8') as f: self.config.write(f)
            logger.info("ƒê√£ l∆∞u c·∫•u h√¨nh.")
        except Exception as e: logger.error(f"L·ªói l∆∞u c·∫•u h√¨nh: {e}")
    def cleanup_on_exit(self):
        if self.exiting: return
        logger.info("B·∫Øt ƒë·∫ßu qu√° tr√¨nh d·ªçn d·∫πp ƒë·ªÉ tho√°t...")
        self.exiting = True
        self.stop_shifting_process()
        try:
            if self.client and self.client.is_connected():
                self.client.loop_stop()
                self.client.disconnect()
        except Exception as e: logger.error(f"L·ªói khi ng·∫Øt k·∫øt n·ªëi MQTT: {e}")
        self.save_session_data(silent=True)
        if IS_PI: GPIO.cleanup()
        logger.info("Backend ƒë√£ d·ª´ng.")
    def setup_gpio(self):
        if not IS_PI: return
        try:
            GPIO.setmode(GPIO.BCM)
            GPIO.setwarnings(False)
            GPIO.setup(Constants.SIREN_RELAY_PIN, GPIO.OUT, initial=GPIO.LOW)
            logger.info(f"GPIO setup successful for Siren Relay on pin {Constants.SIREN_RELAY_PIN}.")
        except Exception as e: logger.error(f"L·ªói khi c√†i ƒë·∫∑t GPIO: {e}. Vui l√≤ng ch·∫°y v·ªõi quy·ªÅn sudo.")
    def activate_siren_relay(self):
        if not IS_PI: return
        try:
            GPIO.output(Constants.SIREN_RELAY_PIN, GPIO.HIGH)
            logger.info("R∆°-le c√≤i b√°o ƒë·ªông ƒë√£ ƒë∆∞·ª£c K√çCH HO·∫†T (ON).")
        except Exception as e: logger.error(f"L·ªói k√≠ch ho·∫°t r∆°-le: {e}")
    def deactivate_siren_relay(self):
        if not IS_PI: return
        try:
            GPIO.output(Constants.SIREN_RELAY_PIN, GPIO.LOW)
            logger.info("R∆°-le c√≤i b√°o ƒë·ªông ƒë√£ ƒë∆∞·ª£c NG·∫ÆT (OFF).")
        except Exception as e: logger.error(f"L·ªói ng·∫Øt r∆°-le: {e}")
    def on_connect(self, client, userdata, flags, rc, properties):
        if self.exiting: return
        rc = rc if isinstance(rc, int) else rc.rc
        if rc == 0:
            logger.info("MQTT Connected successfully.")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: T·ª∞ ƒê·ªòNG", "green"
            if self.subscribe_topics:
                for t in self.subscribe_topics:
                    client.subscribe(t)
                    logger.info(f"Subscribed: {t}")
            else:
                logger.warning("Kh√¥ng c√≥ topic n∆∞·ªõc n√†o ƒë·ªÉ subscribe.")
        else:
            logger.error(f"Failed to connect to MQTT, return code {rc}")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: L·ªñI K·∫æT N·ªêI", "red"
            self.listening = False
    def on_disconnect(self, client, userdata, rc, properties):
        if not self.exiting and self.listening:
            logger.warning("M·∫•t k·∫øt n·ªëi MQTT...")
            self.status_text, self.status_color = "Tr·∫°ng th√°i: M·∫§T K·∫æT N·ªêI", "orange"
    def get_gui_updates(self):
        updates = []
        while not self.gui_update_queue.empty():
            try: updates.append(self.gui_update_queue.get_nowait())
            except queue.Empty: break
        return updates
    def toggle_off(self):
        if not self.listening: return
        self.listening = False
        self.stop_shifting_process()
        try:
            self.client.loop_stop()
            self.client.disconnect()
            logger.info("ƒê√£ ng·∫Øt k·∫øt n·ªëi MQTT.")
        except Exception: pass
        self.status_text, self.status_color = "Tr·∫°ng th√°i: TH·ª¶ C√îNG", "red"
        self.temp_status_text = None
    def toggle_on(self):
        if self.listening: return
        self.listening = True
        self.status_text, self.status_color = "Tr·∫°ng th√°i: ƒêANG K·∫æT N·ªêI...", "orange"
        if not self.broker:
            self.listening = False
            self.status_text, self.status_color = "Tr·∫°ng th√°i: TH·ª¶ C√îNG (L·ªói Broker)", "red"
            logger.error("Kh√¥ng th·ªÉ b·∫≠t, ch∆∞a c·∫•u h√¨nh MQTT Broker.")
            return
        try:
            self.client.username_pw_set(self.username, self.password)
            logger.info(f"ƒêang k·∫øt n·ªëi t·ªõi MQTT broker: {self.broker}:{self.port}...")
            self.client.connect_async(self.broker, self.port, 60)
            self.client.loop_start()
            if self.gnss_topics:
                self.last_shifting_heartbeat = time.time()
                self.is_shifting_responsive = True
                self.start_shifting_process()
        except Exception as e:
            self.listening = False
            self.status_text, self.status_color = "Tr·∫°ng th√°i: L·ªñI K·∫æT N·ªêI", "red"
            logger.error(f"L·ªói khi k·∫øt n·ªëi MQTT: {e}")
    def test_siren_relay(self):
        if self.listening:
            messagebox.showwarning("C·∫£nh b√°o", "Ch·ªâ c√≥ th·ªÉ ki·ªÉm tra c√≤i ·ªü ch·∫ø ƒë·ªô TH·ª¶ C√îNG (OFF).")
            return False
        if not IS_PI:
            messagebox.showwarning("C·∫£nh b√°o", "Kh√¥ng th·ªÉ ki·ªÉm tra c√≤i, kh√¥ng ph·∫£i m√¥i tr∆∞·ªùng Raspberry Pi.")
            return False
        threading.Thread(target=self._test_siren_thread, daemon=True).start()
        return True
    def _test_siren_thread(self):
        logger.info("ƒêang ki·ªÉm tra c√≤i b√°o ƒë·ªông...")
        self.activate_siren_relay()
        time.sleep(2)
        self.deactivate_siren_relay()
        logger.info("Ki·ªÉm tra c√≤i ho√†n t·∫•t.")
    def test_specific_sound(self, filepath):
        if not IS_PI or not self.mixer_initialized:
            logger.warning("Kh√¥ng th·ªÉ ki·ªÉm tra √¢m thanh, pygame mixer ch∆∞a s·∫µn s√†ng.")
            return "Mixer not ready"
        if not os.path.exists(filepath):
            logger.error(f"File √¢m thanh ki·ªÉm tra kh√¥ng t·ªìn t·∫°i: {filepath}")
            return "File not found"
        threading.Thread(target=self._test_sound_thread, args=(filepath,), daemon=True).start()
        return "OK"
    def _test_sound_thread(self, filepath):
        try:
            logger.info(f"ƒêang ph√°t file ki·ªÉm tra: {os.path.basename(filepath)}")
            pygame.mixer.stop()
            test_sound = pygame.mixer.Sound(filepath)
            test_sound.play()
        except Exception as e: logger.error(f"L·ªói khi ph√°t file ki·ªÉm tra '{filepath}': {e}")
    def auto_clear_scheduler(self):
        while not self.exiting:
            now = datetime.now()
            if now.hour == 0 and now.minute == 0:
                logger.info("ƒê√£ ƒë·∫øn 00:00, t·ª± ƒë·ªông x√≥a d·ªØ li·ªáu...")
                self.clear_all_data()
                time.sleep(61)
            else: time.sleep(30)
# ...
class AppGUI:
    def __init__(self, root: tk.Toplevel, backend: Backend, on_close_callback):
        self.root = root
        self.backend = backend
        self.on_close_callback = on_close_callback
        self.root.title("Giao di·ªán Gi√°m s√°t S·∫°t l·ªü & C·∫£nh b√°o S·ªõm")
        self.root.geometry(f"{self.root.winfo_screenwidth()}x{self.root.winfo_screenheight()-70}+0+0")
        self.chart_window, self.settings_window, self.classification_win = None, None, None
        self.warning_threshold_var = tk.StringVar()
        self.critical_threshold_var = tk.StringVar()
        self.sounds_dir_var = tk.StringVar()
        self.test_sound_path_var = tk.StringVar()
        self.CONVERSION_FACTORS = {"m": 1.0, "cm": 100.0, "mm": 1000.0, "ft": 3.28084}
        self.create_widgets()
        self.load_initial_data()
        self.root.after(250, self.periodic_update)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close_window)
    
    def create_widgets(self):
        main = ttk.Frame(self.root, padding=10)
        main.pack(fill="both", expand=True)
        main.grid_columnconfigure(1, weight=1)
        main.grid_columnconfigure(0, weight=0, minsize=350)
        main.grid_rowconfigure(0, weight=1)
        self.create_left_panel(main)
        self.create_right_panel(main)

    def create_left_panel(self, parent):
        left = ttk.Frame(parent)
        left.grid(row=0, column=0, sticky="ns", padx=(0, 15))
        
        mqtt_frame = ttk.LabelFrame(left, text="C√†i ƒë·∫∑t MQTT", padding=10)
        mqtt_frame.pack(fill=tk.X, expand=False)
        def add_labeled_entry(frame, label, row, show=None):
            ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w", pady=3)
            entry = ttk.Entry(frame, show=show)
            entry.grid(row=row, column=1, sticky="ew", pady=3, columnspan=2)
            return entry
        self.broker_entry = add_labeled_entry(mqtt_frame, "MQTT Broker:", 0)
        self.port_entry = add_labeled_entry(mqtt_frame, "Port:", 1)
        self.user_entry = add_labeled_entry(mqtt_frame, "Username:", 2)
        self.pass_entry = add_labeled_entry(mqtt_frame, "Password:", 3, show="*")
        ttk.Button(mqtt_frame, text="üëÅ", command=self.toggle_pass, width=2, bootstyle="light").grid(row=3, column=2, sticky="e")
        self.pub_entry = add_labeled_entry(mqtt_frame, "Publish Topic:", 4)
        ttk.Label(mqtt_frame, text="Water Sub Topic:").grid(row=5, column=0, columnspan=3, sticky="w", pady=(10, 2))
        self.water_topic_entry = tk.Text(mqtt_frame, height=3, width=35, relief="solid", borderwidth=1)
        self.water_topic_entry.grid(row=6, column=0, columnspan=3, pady=(0, 5), sticky="ew")
        ttk.Label(mqtt_frame, text="GNSS Sub Topic:").grid(row=7, column=0, columnspan=3, sticky="w", pady=(10, 2))
        self.gnss_topic_entry = tk.Text(mqtt_frame, height=3, width=35, relief="solid", borderwidth=1)
        self.gnss_topic_entry.grid(row=8, column=0, columnspan=3, pady=(0, 5), sticky="ew")
        mqtt_frame.grid_columnconfigure(1, weight=1)

        control_frame = ttk.LabelFrame(left, text="ƒêi·ªÅu khi·ªÉn Ch√≠nh", padding=(10, 5))
        control_frame.pack(fill=tk.X, expand=False, pady=(10,0))
        control_frame.grid_columnconfigure((0, 1), weight=1)
        ttk.Button(control_frame, text="L∆∞u & √Åp d·ª•ng", command=lambda: self.apply_and_save_config(), bootstyle="primary").grid(row=0, column=0, columnspan=2, sticky='ew', padx=2, pady=2)
        ttk.Button(control_frame, text="T·ª± ƒë·ªông (ON)", command=self.backend.toggle_on, bootstyle="success").grid(row=1, column=0, sticky='ew', padx=2, pady=2)
        ttk.Button(control_frame, text="Th·ªß c√¥ng (OFF)", command=self.backend.toggle_off, bootstyle="danger").grid(row=1, column=1, sticky='ew', padx=2, pady=2)
        ttk.Button(control_frame, text="C√†i ƒë·∫∑t N√¢ng cao", command=self.open_settings_window, bootstyle="secondary").grid(row=2, column=0, columnspan=2, sticky='ew', padx=2, pady=2)
        
        device_panel = ttk.LabelFrame(left, text="Ch·ª©c nƒÉng", padding=10)
        device_panel.pack(fill=tk.X, expand=False, pady=(10, 0))
        device_panel.grid_columnconfigure(0, weight=1)
        ttk.Button(device_panel, text="Ki·ªÉm tra C√≤i", command=self.on_test_siren_click).pack(fill=tk.X, pady=2)
        ttk.Button(device_panel, text="X√≥a To√†n b·ªô D·ªØ li·ªáu", command=self.clear_all_gui_data, bootstyle="warning").pack(fill=tk.X, pady=2)

        ttk.Button(left, text="Tho√°t Ch∆∞∆°ng tr√¨nh", command=self.exit_program_graceful, bootstyle="secondary-outline").pack(side=tk.BOTTOM, fill=tk.X, pady=(15,0))

    def create_right_panel(self, parent):
        right = ttk.Frame(parent)
        right.grid(row=0, column=1, sticky="nsew")
        right.grid_rowconfigure(1, weight=1)
        right.grid_columnconfigure(0, weight=1)
        self.status_label = ttk.Label(right, text="", font=("Arial", 11, "bold"))
        self.status_label.grid(row=0, column=0, sticky="ew", pady=(0, 5))
        self.notebook = ttk.Notebook(right)
        self.notebook.grid(row=1, column=0, sticky="nsew")
        gnss_tab = ttk.Frame(self.notebook, padding=5)
        water_tab = ttk.Frame(self.notebook, padding=5)
        overview_tab = ttk.Frame(self.notebook, padding=5)
        long_term_tab = ttk.Frame(self.notebook, padding=5)
        self.notebook.add(gnss_tab, text=' Ph√¢n t√≠ch D·ªãch chuy·ªÉn GNSS ')
        self.notebook.add(water_tab, text=' C·∫£nh b√°o N∆∞·ªõc ')
        self.notebook.add(overview_tab, text=' Nh·∫≠t k√Ω T·ªïng quan ')
        self.notebook.add(long_term_tab, text=' Ph√¢n t√≠ch D√†i h·∫°n ')
        self.create_gnss_tab(gnss_tab)
        self.create_water_tab(water_tab)
        self.create_overview_tab(overview_tab)
        self.create_long_term_tab(long_term_tab)
    
    def create_gnss_tab(self, parent_tab):
        parent_tab.grid_rowconfigure(1, weight=1); parent_tab.grid_columnconfigure(0, weight=1)
        dashboard_frame = ttk.LabelFrame(parent_tab, text="B·∫£ng ƒëi·ªÅu khi·ªÉn Gi√°m s√°t D·ªãch chuy·ªÉn", padding=10)
        dashboard_frame.grid(row=0, column=0, sticky="ew", pady=5)
        self.create_gnss_dashboard(dashboard_frame)
        sheet_frame = ttk.Frame(parent_tab)
        sheet_frame.grid(row=1, column=0, sticky="nsew", pady=(10,0))
        gnss_headers = ["Th·ªùi gian", "T·ªëc ƒë·ªô ngang\n(mm/s)", "T·ªëc ƒë·ªô ƒë·ª©ng\n(mm/s)", "H∆∞·ªõng\n(¬∞)", "Gia t·ªëc ngang\n(mm/s¬≤)", "T·ªïng d·ªãch chuy·ªÉn\n(m)", "Ph√¢n lo·∫°i"]
        self.sheet_gnss = Sheet(sheet_frame, headers=gnss_headers, show_row_index=True)
        self.sheet_gnss.pack(fill=tk.BOTH, expand=True)
        self.sheet_gnss.set_options(font=("Arial", 10, "normal"), header_font=("Arial", 9, "bold"), align="center")
        self.sheet_gnss.column_width(column=0, width=80); self.sheet_gnss.column_width(column=6, width=120)
        ttk.Button(parent_tab, text="L∆∞u B·∫£ng Ph√¢n t√≠ch GNSS (CSV)", command=self.save_gnss_to_csv, bootstyle="info-outline").grid(row=2, column=0, sticky='e', pady=5)

    def create_water_tab(self, parent_tab):
        parent_tab.grid_rowconfigure(0, weight=1); parent_tab.grid_columnconfigure(0, weight=1)
        sheet_frame = ttk.Frame(parent_tab)
        sheet_frame.grid(row=0, column=0, sticky="nsew")
        water_headers = ["T√™n C·∫£m bi·∫øn", "Gi√° tr·ªã (m)", "Tr·∫°ng th√°i", "Th·ªùi gian"]
        self.sheet_water = Sheet(sheet_frame, headers=water_headers, show_row_index=True)
        self.sheet_water.pack(fill=tk.BOTH, expand=True)
        self.sheet_water.set_options(font=("Arial", 10, "normal"), header_font=("Arial", 10, "bold"), align="center")
        button_frame = ttk.Frame(parent_tab)
        button_frame.grid(row=1, column=0, sticky='e', pady=5)
        ttk.Button(button_frame, text="Xem Bi·ªÉu ƒê·ªì", command=self.show_chart_window, bootstyle="info-outline").pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="L∆∞u B·∫£ng N∆∞·ªõc (CSV)", command=self.save_water_to_csv, bootstyle="info-outline").pack(side=tk.LEFT)

    def create_overview_tab(self, parent_tab):
        parent_tab.grid_rowconfigure(0, weight=1); parent_tab.grid_columnconfigure(0, weight=1)
        sheet_frame = ttk.Frame(parent_tab)
        sheet_frame.grid(row=0, column=0, sticky="nsew")
        overview_headers = ["Th·ªùi gian", "Ngu·ªìn", "Th√¥ng ƒëi·ªáp", "Tr·∫°ng th√°i"]
        self.sheet_overview = Sheet(sheet_frame, headers=overview_headers, show_row_index=True)
        self.sheet_overview.pack(fill=tk.BOTH, expand=True)
        self.sheet_overview.set_options(font=("Arial", 10, "normal"), header_font=("Arial", 10, "bold"), align="center")
        ttk.Button(parent_tab, text="L∆∞u Nh·∫≠t k√Ω T·ªïng quan (CSV)", command=self.save_overview_to_csv, bootstyle="info-outline").grid(row=1, column=0, sticky='e', pady=5)

    def create_long_term_tab(self, parent_tab):
        parent_tab.grid_columnconfigure(0, weight=1); parent_tab.grid_rowconfigure(1, weight=1)
        info_frame = ttk.LabelFrame(parent_tab, text="T√≥m t·∫Øt D·ªãch chuy·ªÉn T√≠ch l≈©y", padding=10)
        info_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=5)
        info_frame.grid_columnconfigure(1, weight=1)
        self.lt_total_days_var = tk.StringVar(value="S·ªë ng√†y gi√°m s√°t: ---")
        self.lt_total_disp_var = tk.StringVar(value="T·ªïng d·ªãch chuy·ªÉn: --- mm")
        self.lt_avg_speed_var = tk.StringVar(value="T·ªëc ƒë·ªô trung b√¨nh: --- mm/nƒÉm")
        ttk.Label(info_frame, textvariable=self.lt_total_days_var, font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky="w", padx=5)
        ttk.Label(info_frame, textvariable=self.lt_total_disp_var, font=('Arial', 10, 'bold')).grid(row=1, column=0, sticky="w", padx=5)
        ttk.Label(info_frame, textvariable=self.lt_avg_speed_var, font=('Arial', 10, 'bold')).grid(row=2, column=0, sticky="w", padx=5)
        chart_frame = ttk.Frame(parent_tab)
        chart_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", pady=(10,0))
        self.lt_fig = Figure(figsize=(8, 4), dpi=100)
        self.lt_ax = self.lt_fig.add_subplot(111)
        self.lt_canvas = FigureCanvasTkAgg(self.lt_fig, master=chart_frame)
        self.lt_canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        ttk.Button(parent_tab, text="T·∫£i v√† Ph√¢n t√≠ch D·ªØ li·ªáu D√†i h·∫°n", command=self.run_long_term_analysis, bootstyle="primary").grid(row=2, column=0, sticky="e", pady=10)

    def create_gnss_dashboard(self, parent):
        parent.grid_columnconfigure(1, weight=1)
        self.compass_canvas = tk.Canvas(parent, width=150, height=150, bg='white', highlightthickness=0)
        self.compass_canvas.grid(row=0, column=0, rowspan=5, padx=(10, 20), pady=5)
        self.draw_compass_base()
        def add_metric_label(text, row):
            ttk.Label(parent, text=text, font=('Arial', 10, 'bold')).grid(row=row, column=1, sticky='w', padx=5)
            var = tk.StringVar(value="---")
            ttk.Label(parent, textvariable=var, font=('Arial', 10, 'normal')).grid(row=row, column=2, sticky='w', padx=5)
            return var
        self.h_speed_var = add_metric_label("T·ªëc ƒë·ªô ngang:", 0)
        self.v_speed_var = add_metric_label("T·ªëc ƒë·ªô ƒë·ª©ng:", 1)
        self.direction_var = add_metric_label("H∆∞·ªõng d·ªãch chuy·ªÉn:", 2)
        self.acceleration_var = add_metric_label("Gia t·ªëc ngang:", 3)
        self.displacement_var = add_metric_label("T·ªïng d·ªãch chuy·ªÉn:", 4)

    def draw_compass_base(self):
        w, h = 150, 150
        self.compass_canvas.create_oval(5, 5, w-5, h-5, outline='gray', width=1)
        for i in range(0, 360, 30):
            rad = math.radians(i)
            self.compass_canvas.create_line(w/2 + 65*math.sin(rad), h/2 - 65*math.cos(rad), w/2 + 70*math.sin(rad), h/2 - 70*math.cos(rad), fill='gray')
        self.compass_canvas.create_text(w/2, 15, text="N", font=('Arial', 10, 'bold'))
        self.compass_canvas.create_text(w/2, h-15, text="S", font=('Arial', 10, 'bold'))
        self.compass_canvas.create_text(15, h/2, text="W", font=('Arial', 10, 'bold'))
        self.compass_canvas.create_text(w-15, h/2, text="E", font=('Arial', 10, 'bold'))
        self.compass_needle = self.compass_canvas.create_line(w/2, h/2, w/2, 25, arrow=tk.LAST, width=3, fill='red')

    def update_compass_needle(self, angle_deg):
        w, h = 150, 150
        angle_rad = math.radians(angle_deg)
        end_x = w/2 + 60 * math.sin(angle_rad)
        end_y = h/2 - 60 * math.cos(angle_rad)
        self.compass_canvas.coords(self.compass_needle, w/2, h/2, end_x, end_y)

    def periodic_update(self):
        if not self.root.winfo_exists(): return
        for data_type, item in self.backend.get_gui_updates():
            if data_type == "clear_all":
                self.sheet_overview.set_sheet_data(data=[]); self.sheet_gnss.set_sheet_data(data=[]); self.sheet_water.set_sheet_data(data=[])
                if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.clear_chart_data()
                logger.info("GUI ƒë√£ nh·∫≠n t√≠n hi·ªáu v√† x√≥a t·∫•t c·∫£ c√°c b·∫£ng.")
            elif data_type == "water_sensor": self.update_water_tab(item)
            elif data_type == "overview_log": self.update_overview_tab(item)
            elif data_type == "gnss_report":
                report_type = item.get("type")
                if report_type == "HEARTBEAT":
                    self.backend.last_shifting_heartbeat = time.time()
                    if not self.backend.is_shifting_responsive:
                         logger.info("Ti·∫øn tr√¨nh Shifting ƒë√£ ph·∫£n h·ªìi tr·ªü l·∫°i."); self.backend.is_shifting_responsive = True
                elif report_type == "collection_status":
                    self.backend.temp_status_text = f"SHIFTING: ƒêang thu th·∫≠p d·ªØ li·ªáu... [{item.get('collected',0)}/{item.get('total','N/A')}]"
                elif report_type == "ultimate_analysis_report":
                    self.backend.temp_status_text = None
                    self.update_gnss_tab(item)
                    self.update_overview_with_gnss_report(item)
                    if item.get("event_confirmed"): self.backend.alert_manager.trigger_critical_event_alarm()
            elif data_type == "gnss_analysis_record": self.sheet_gnss.insert_row(item)
        self.update_status_label()
        if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.update_plot()
        self.root.after(250, self.periodic_update)

    def update_gnss_tab(self, item_data):
        if 'analysis_data' in item_data and item_data['analysis_data']:
            data = item_data['analysis_data']
            h_speed, v_speed, direction, accel, displace = (data.get('horizontal_velocity_mmps', 0), data.get('vertical_velocity_mps', 0), 
                                                           data.get('direction_degrees', 0), data.get('horizontal_acceleration_mmps2', 0), 
                                                           data.get('total_displacement_m', 0))
            self.h_speed_var.set(f"{h_speed:.4f} mm/s")
            v_speed_text = f"{abs(v_speed):.4f} mm/s {'(L√∫n xu·ªëng)' if v_speed < 0 else '(Tr·ªìi l√™n)'}"
            self.v_speed_var.set(v_speed_text); self.direction_var.set(f"{direction:.2f}¬∞")
            self.acceleration_var.set(f"{accel:.4f} mm/s¬≤"); self.displacement_var.set(f"{displace:.3f} m")
            self.update_compass_needle(direction)
        ts = datetime.fromtimestamp(item_data.get('timestamp', time.time())).strftime("%H:%M:%S")
        analysis = item_data.get('analysis_data', {}); classification = item_data.get('classification_name', 'N/A')
        gnss_record = [ts, f"{analysis.get('horizontal_velocity_mmps', 0):.4f}", f"{analysis.get('vertical_velocity_mps', 0):.4f}",
                       f"{analysis.get('direction_degrees', 0):.2f}", f"{analysis.get('horizontal_acceleration_mmps2', 0):.4f}",
                       f"{analysis.get('total_displacement_m', 0):.3f}", classification]
        self.backend.gnss_analysis_data.append(gnss_record)
        self.sheet_gnss.insert_row(gnss_record)
        last_row_index = self.sheet_gnss.get_total_rows() - 1
        if last_row_index >= 0:
            self.sheet_gnss.see(row=last_row_index)
            if "nhanh" in classification.lower(): self.sheet_gnss.highlight_rows([last_row_index], bg="#F8D7DA")
            elif "trung b√¨nh" in classification.lower() or "ch·∫≠m" in classification.lower() and "r·∫•t" not in classification.lower(): self.sheet_gnss.highlight_rows([last_row_index], bg="#FFF3CD")
            else: self.sheet_gnss.highlight_rows([last_row_index], bg="#E9ECEF")

    def update_water_tab(self, record):
        self.sheet_water.insert_row(record)
        last_row_index = self.sheet_water.get_total_rows() - 1
        if last_row_index >= 0:
            self.sheet_water.see(row=last_row_index)
            status = record[2]
            if status == "NGUY HIEM": self.sheet_water.highlight_rows([last_row_index], bg="#F8D7DA")
            elif status == "CANH BAO": self.sheet_water.highlight_rows([last_row_index], bg="#FFF3CD")
            else: self.sheet_water.highlight_rows([last_row_index], bg="#D4EDDA")
            
    def update_overview_tab(self, record):
        self.sheet_overview.insert_row(record)
        last_row_index = self.sheet_overview.get_total_rows() - 1
        if last_row_index >= 0:
            self.sheet_overview.see(row=last_row_index)
            status = record[3]
            if status == "NGUY HIEM" or "nhanh" in status.lower(): self.sheet_overview.highlight_rows([last_row_index], bg="#F8D7DA")
            elif status == "CANH BAO" or "trung b√¨nh" in status.lower(): self.sheet_overview.highlight_rows([last_row_index], bg="#FFF3CD")
            else: self.sheet_overview.highlight_rows([last_row_index], bg="#D4EDDA")

    def update_overview_with_gnss_report(self, item_data):
        ts = datetime.fromtimestamp(item_data.get('timestamp', time.time())).strftime("%H:%M:%S")
        classification = item_data.get('classification_name', 'N/A')
        vel = item_data.get('classification_velocity_mm_s', 0)
        message = f"V·∫≠n t·ªëc 3D: {vel:.4f} mm/s"
        record = (ts, "Ph√¢n t√≠ch GNSS", message, classification)
        self.backend.overview_log_data.append(record)
        self.update_overview_tab(record)

    def save_overview_to_csv(self): self._save_data_to_csv(list(self.backend.overview_log_data), ["Th·ªùi gian", "Ngu·ªìn", "Th√¥ng ƒëi·ªáp", "Tr·∫°ng th√°i"])
    def save_gnss_to_csv(self): self._save_data_to_csv(list(self.backend.gnss_analysis_data), ["Th·ªùi gian", "T·ªëc ƒë·ªô ngang (mm/s)", "T·ªëc ƒë·ªô ƒë·ª©ng (mm/s)", "H∆∞·ªõng (¬∞)", "Gia t·ªëc ngang (mm/s¬≤)", "T·ªïng d·ªãch chuy·ªÉn (m)", "Ph√¢n lo·∫°i"])
    def save_water_to_csv(self): self._save_data_to_csv(list(self.backend.water_data), ["T√™n C·∫£m bi·∫øn", "Gi√° tr·ªã (m)", "Tr·∫°ng th√°i", "Th·ªùi gian"])

    def run_long_term_analysis(self):
        log_path = os.path.join("shifting", "long_term_displacement.jsonl")
        if not os.path.exists(log_path):
            messagebox.showwarning("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu", "Kh√¥ng t√¨m th·∫•y file log d√†i h·∫°n. H·ªá th·ªëng c·∫ßn ch·∫°y qua √≠t nh·∫•t m·ªôt ng√†y ƒë·ªÉ t·∫°o d·ªØ li·ªáu.", parent=self.root)
            return
        checkpoints = []
        try:
            with open(log_path, "r", encoding='utf-8') as f:
                for line in f:
                    if line.strip(): checkpoints.append(json.loads(line))
        except Exception as e:
            messagebox.showerror("L·ªói ƒë·ªçc file", f"Kh√¥ng th·ªÉ ƒë·ªçc ho·∫∑c ph√¢n t√≠ch file log d√†i h·∫°n:\n{e}", parent=self.root)
            return
        if len(checkpoints) < 2:
            messagebox.showinfo("Ch∆∞a ƒë·ªß d·ªØ li·ªáu", "C·∫ßn √≠t nh·∫•t 2 ƒëi·ªÉm ch·ªët (2 ng√†y) ƒë·ªÉ th·ª±c hi·ªán ph√¢n t√≠ch d√†i h·∫°n.", parent=self.root)
            return
        checkpoints.sort(key=lambda p: p["timestamp"])
        start_point = checkpoints[0]; start_time = datetime.fromtimestamp(start_point["timestamp"])
        timestamps = []; displacements_mm = []
        for cp in checkpoints:
            current_time = datetime.fromtimestamp(cp["timestamp"])
            days_since_start = (current_time - start_time).total_seconds() / (24 * 3600)
            p1 = {"lat": start_point["lat"], "lon": start_point["lon"], "h": start_point["h"]}
            p2 = {"lat": cp["lat"], "lon": cp["lon"], "h": cp["h"]}
            disp_m = haversine_3d(p1, p2)
            timestamps.append(days_since_start); displacements_mm.append(disp_m * 1000)
        total_days = timestamps[-1]; total_disp_mm = displacements_mm[-1]
        self.lt_total_days_var.set(f"S·ªë ng√†y gi√°m s√°t: {total_days:.1f} ng√†y")
        self.lt_total_disp_var.set(f"T·ªïng d·ªãch chuy·ªÉn: {total_disp_mm:.2f} mm")
        if total_days > 0:
            speed_mm_per_year = (total_disp_mm / total_days) * 365.25
            self.lt_avg_speed_var.set(f"T·ªëc ƒë·ªô trung b√¨nh: {speed_mm_per_year:.2f} mm/nƒÉm")
        else: self.lt_avg_speed_var.set("T·ªëc ƒë·ªô trung b√¨nh: ---")
        self.lt_ax.clear()
        self.lt_ax.plot(timestamps, displacements_mm, marker='o', linestyle='-', color='b')
        self.lt_ax.set_title("D·ªãch chuy·ªÉn T√≠ch l≈©y Theo Th·ªùi gian", fontsize=14)
        self.lt_ax.set_xlabel("S·ªë ng√†y k·ªÉ t·ª´ khi b·∫Øt ƒë·∫ßu gi√°m s√°t", fontsize=12)
        self.lt_ax.set_ylabel("T·ªïng d·ªãch chuy·ªÉn (mm)", fontsize=12)
        self.lt_ax.grid(True); self.lt_fig.tight_layout(); self.lt_canvas.draw()
    
    # ... (C√°c h√†m c√≤n l·∫°i nh∆∞ on_close_window, open_settings_window, ... gi·ªØ nguy√™n)
    def _save_data_to_csv(self, data_to_save, headers):
        if not data_to_save:
            messagebox.showinfo("Th√¥ng b√°o", "Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ l∆∞u.", parent=self.root)
            return
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")], title="L∆∞u file CSV", parent=self.root)
        if not path: return
        threading.Thread(target=self._write_csv_in_background, args=(path, data_to_save, headers), daemon=True).start()
    def _write_csv_in_background(self, path, data_to_save, headers):
        try:
            import csv
            with open(path, "w", newline="", encoding='utf-8-sig') as f:
                writer = csv.writer(f)
                writer.writerow(headers)
                writer.writerows(data_to_save)
            if self.root.winfo_exists(): self.root.after(0, lambda: messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ l∆∞u d·ªØ li·ªáu v√†o {os.path.basename(path)}", parent=self.root))
        except Exception as e:
            if self.root.winfo_exists(): self.root.after(0, lambda: messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ l∆∞u file:\n\n{e}", parent=self.root))
    def clear_all_gui_data(self):
        if messagebox.askokcancel("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô d·ªØ li·ªáu tr√™n giao di·ªán v√† trong b·ªô nh·ªõ?", parent=self.root):
            self.backend.clear_all_data()
    def on_close_window(self):
        logger.info("ƒê√£ ƒë√≥ng c·ª≠a s·ªï giao di·ªán. G√µ 'show' trong terminal ƒë·ªÉ m·ªü l·∫°i.")
        self.on_close_callback()
        self.destroy_all_windows()
    def exit_program_graceful(self):
        if messagebox.askokcancel("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën tho√°t ho√†n to√†n ch∆∞∆°ng tr√¨nh?", parent=self.root):
            logger.info("T·ª± ƒë·ªông l∆∞u c·∫•u h√¨nh hi·ªán t·∫°i tr∆∞·ªõc khi tho√°t...")
            self.apply_and_save_config(show_message=False)
            self.on_close_callback(shutdown=True)
    def destroy_all_windows(self):
        if self.settings_window and self.settings_window.winfo_exists(): self.settings_window.destroy()
        if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.destroy()
        if self.classification_win and self.classification_win.winfo_exists(): self.classification_win.destroy()
        if self.root and self.root.winfo_exists(): self.root.destroy()
    def load_initial_data(self):
        self.broker_entry.insert(0, self.backend.broker)
        self.port_entry.insert(0, str(self.backend.port))
        self.user_entry.insert(0, self.backend.username)
        self.pass_entry.insert(0, self.backend.password)
        self.pub_entry.insert(0, self.backend.publish_topic)
        self.water_topic_entry.insert("1.0", "\n".join(self.backend.water_topics))
        self.gnss_topic_entry.insert("1.0", "\n".join(self.backend.gnss_topics))
        self.warning_threshold_var.set(str(self.backend.warning_threshold))
        self.critical_threshold_var.set(str(self.backend.critical_threshold))
        self.sounds_dir_var.set(self.backend.sounds_dir)
    def _validate_config(self, settings):
        errors = []
        if not settings.get('broker'): errors.append("MQTT Broker kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng")
        try:
            port = int(settings.get('port', 0))
            if not (1 <= port <= 65535): errors.append("Port ph·∫£i l√† m·ªôt s·ªë t·ª´ 1-65535")
        except (ValueError, TypeError): errors.append("Port ph·∫£i l√† m·ªôt s·ªë nguy√™n")
        try:
            warning = float(settings.get('warning_threshold', 0))
            critical = float(settings.get('critical_threshold', 0))
            if critical <= warning: errors.append("Ng∆∞·ª°ng nguy hi·ªÉm ph·∫£i l·ªõn h∆°n ng∆∞·ª°ng c·∫£nh b√°o")
        except (ValueError, TypeError): errors.append("C√°c gi√° tr·ªã ng∆∞·ª°ng ph·∫£i l√† s·ªë")
        sounds_dir = settings.get('sounds_dir')
        if not sounds_dir or not os.path.isdir(sounds_dir): errors.append(f"ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c √¢m thanh kh√¥ng h·ª£p l·ªá:\n{sounds_dir}")
        return errors
    def apply_and_save_config(self, show_message=True, parent_window=None):
        if parent_window is None: parent_window = self.root
        settings = {'broker': self.broker_entry.get(), 'port': self.port_entry.get(), 'username': self.user_entry.get(), 'password': self.pass_entry.get(),
            'water_topics': self.water_topic_entry.get("1.0", "end-1c").strip(), 'gnss_topics': self.gnss_topic_entry.get("1.0", "end-1c").strip(),
            'publish': self.pub_entry.get(), 'warning_threshold': self.warning_threshold_var.get(), 'critical_threshold': self.critical_threshold_var.get(),
            'sounds_dir': self.sounds_dir_var.get()}
        errors = self._validate_config(settings)
        if errors:
            messagebox.showerror("L·ªói C·∫•u h√¨nh", "\n".join(errors), parent=parent_window)
            return False
        try:
            self.backend.update_and_reconnect(settings)
            if show_message: messagebox.showinfo("Th√†nh c√¥ng", "ƒê√£ l∆∞u v√† √°p d·ª•ng c·∫•u h√¨nh.", parent=parent_window)
            return True
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ √°p d·ª•ng c·∫•u h√¨nh: {e}", parent=parent_window)
            return False
    def update_status_label(self):
        if self.backend.temp_status_text:
            text_to_show = self.backend.temp_status_text
            color_to_show = "blue" if "ƒêang thu th·∫≠p" in self.backend.temp_status_text else "red"
        else:
            text_to_show = self.backend.status_text
            color_to_show = self.backend.status_color
        if self.status_label.cget("text") != text_to_show or self.status_label.cget("foreground") != color_to_show:
            self.status_label.config(text=text_to_show, foreground=color_to_show)
    def toggle_pass(self): self.pass_entry.config(show="" if self.pass_entry.cget("show") else "*")
    def on_test_siren_click(self):
        self.backend.test_siren_relay()
    def select_sounds_directory(self):
        initial_dir = os.path.dirname(self.sounds_dir_var.get())
        if not os.path.isdir(initial_dir): initial_dir = os.path.dirname(os.path.abspath(__file__))
        directory = filedialog.askdirectory(title="Ch·ªçn Th∆∞ m·ª•c ch·ª©a File √Çm thanh", initialdir=initial_dir, parent=self.settings_window)
        if directory: self.sounds_dir_var.set(directory)
    def select_test_sound_file(self):
        filepath = filedialog.askopenfilename(parent=self.settings_window,title="Ch·ªçn file √¢m thanh ƒë·ªÉ ki·ªÉm tra",initialdir=self.backend.sounds_dir,filetypes=[("Sound Files", "*.mp3 *.wav"), ("All files", "*.*")])
        if filepath: self.test_sound_path_var.set(filepath)
    def play_test_sound(self):
        filepath = self.test_sound_path_var.get()
        if not filepath:
            messagebox.showwarning("Ch∆∞a ch·ªçn file", "Vui l√≤ng ch·ªçn m·ªôt file √¢m thanh ƒë·ªÉ ph√°t.", parent=self.settings_window)
            return
        result = self.backend.test_specific_sound(filepath)
        if result == "OK": messagebox.showinfo("ƒêang ph√°t", f"ƒêang g·ª≠i l·ªánh ph√°t file:\n{os.path.basename(filepath)}", parent=self.settings_window)
        elif result == "File not found": messagebox.showerror("L·ªói", "Kh√¥ng t√¨m th·∫•y file √¢m thanh. Vui l√≤ng ch·ªçn l·∫°i.", parent=self.settings_window)
        else: messagebox.showerror("L·ªói", "H·ªá th·ªëng √¢m thanh (mixer) ch∆∞a s·∫µn s√†ng ho·∫∑c kh√¥ng ph·∫£i m√¥i tr∆∞·ªùng Pi.", parent=self.settings_window)
    def open_settings_window(self):
        if self.settings_window and self.settings_window.winfo_exists():
            self.settings_window.lift()
            return
        self.settings_window = Toplevel(self.root)
        self.settings_window.title("C√†i ƒë·∫∑t N√¢ng cao")
        self.settings_window.geometry("800x600")
        self.settings_window.transient(self.root)
        notebook = ttk.Notebook(self.settings_window)
        notebook.pack(pady=10, padx=10, fill="both", expand=True)
        general_frame = ttk.Frame(notebook, padding="10")
        notebook.add(general_frame, text='Chung')
        sounds_path_frame = ttk.LabelFrame(general_frame, text="ƒê∆∞·ªùng d·∫´n", padding=10)
        sounds_path_frame.pack(fill="x", expand=True)
        ttk.Label(sounds_path_frame, text="Th∆∞ m·ª•c √Çm thanh C·∫£nh b√°o:").grid(row=0, column=0, sticky="w", pady=5, padx=5)
        sounds_entry = ttk.Entry(sounds_path_frame, textvariable=self.sounds_dir_var, state="readonly")
        sounds_entry.grid(row=1, column=0, sticky="ew", pady=5, padx=5)
        ttk.Button(sounds_path_frame, text="Ch·ªçn Th∆∞ m·ª•c...", command=self.select_sounds_directory).grid(row=1, column=1, sticky="w", pady=5, padx=(5,0))
        sounds_path_frame.grid_columnconfigure(0, weight=1)
        test_sound_frame = ttk.LabelFrame(general_frame, text="Ki·ªÉm tra Loa/C√≤i th·ªß c√¥ng", padding=10)
        test_sound_frame.pack(fill="x", expand=True, pady=(10, 0))
        ttk.Label(test_sound_frame, text="File √¢m thanh ki·ªÉm tra:").grid(row=0, column=0, columnspan=3, sticky="w", padx=5)
        test_sound_entry = ttk.Entry(test_sound_frame, textvariable=self.test_sound_path_var, state="readonly")
        test_sound_entry.grid(row=1, column=0, sticky="ew", pady=5, padx=5)
        ttk.Button(test_sound_frame, text="Ch·ªçn File...", command=self.select_test_sound_file).grid(row=1, column=1, sticky="w", pady=5, padx=(0,5))
        ttk.Button(test_sound_frame, text="Ph√°t √Çm thanh", command=self.play_test_sound, bootstyle="success").grid(row=1, column=2, sticky="w", pady=5, padx=5)
        test_sound_frame.grid_columnconfigure(0, weight=1)
        gnss_frame = ttk.Frame(notebook, padding="10")
        notebook.add(gnss_frame, text='GNSS')
        ttk.Button(gnss_frame, text="Ph√¢n lo·∫°i T·ªëc ƒë·ªô D·ªãch chuy·ªÉn...", command=self.open_classification_window, bootstyle="info").pack(pady=(5, 10))
        water_level_frame = ttk.Frame(notebook, padding="10")
        notebook.add(water_level_frame, text='M·ª±c n∆∞·ªõc')
        add_labeled_entry_settings = lambda frame, label, row, textvariable: (ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w", pady=5, padx=5), ttk.Entry(frame, textvariable=textvariable).grid(row=row, column=1, sticky="ew", pady=5, padx=5), frame.grid_columnconfigure(1, weight=1))
        add_labeled_entry_settings(water_level_frame, "Ng∆∞·ª°ng C·∫£nh B√°o (m):", 0, self.warning_threshold_var)
        add_labeled_entry_settings(water_level_frame, "Ng∆∞·ª°ng Nguy Hi·ªÉm (m):", 1, self.critical_threshold_var)
        ttk.Button(self.settings_window, text="L∆∞u & ƒê√≥ng", command=self.save_and_close_settings, bootstyle="success").pack(pady=10)
    def open_classification_window(self):
        if self.classification_win and self.classification_win.winfo_exists():
            self.classification_win.lift(); return
        self.classification_win = Toplevel(self.settings_window)
        self.classification_win.title("B·∫£ng Ph√¢n Lo·∫°i T·ªëc ƒê·ªô D·ªãch Chuy·ªÉn")
        self.classification_win.geometry("850x420")
        self.classification_win.transient(self.settings_window); self.classification_win.grab_set()
        main_frame = ttk.Frame(self.classification_win, padding=10)
        main_frame.pack(fill="both", expand=True)
        classification_frame = ttk.LabelFrame(main_frame, text="B·∫£ng ph√¢n lo·∫°i (Cruden & Varnes, 1996)", padding="10")
        classification_frame.pack(fill="both", expand=True, pady=(0, 10))
        columns = ("Ph√¢n lo·∫°i", "mm/gi√¢y (Ng∆∞·ª°ng t·ªëi thi·ªÉu)")
        self.gnss_tree = ttk.Treeview(classification_frame, columns=columns, show="headings", height=10)
        self.gnss_tree.heading(columns[0], text=columns[0]); self.gnss_tree.column(columns[0], width=200, anchor="w")
        self.gnss_tree.heading(columns[1], text=columns[1]); self.gnss_tree.column(columns[1], width=200, anchor="center")
        tree_scrollbar = ttk.Scrollbar(classification_frame, orient="vertical", command=self.gnss_tree.yview)
        self.gnss_tree.configure(yscrollcommand=tree_scrollbar.set)
        self.gnss_tree.pack(side="left", fill="both", expand=True); tree_scrollbar.pack(side="right", fill="y")
        self.load_gnss_classification_data()
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill="x", pady=(10, 0))
        ttk.Button(control_frame, text="Ch·ªânh s·ª≠a", command=self.edit_gnss_classification).pack(side="left", padx=(0, 5))
        ttk.Button(control_frame, text="Th√™m m·ªõi", command=self.add_gnss_classification).pack(side="left", padx=5)
        ttk.Button(control_frame, text="X√≥a", command=self.delete_gnss_classification).pack(side="left", padx=5)
        ttk.Button(control_frame, text="Kh√¥i ph·ª•c m·∫∑c ƒë·ªãnh", command=self.reset_gnss_classification, bootstyle="danger").pack(side="left", padx=5)
    def save_and_close_settings(self):
        if self.apply_and_save_config(show_message=False, parent_window=self.settings_window):
            messagebox.showinfo("Th√†nh c√¥ng", "ƒê√£ l∆∞u t·∫•t c·∫£ c√†i ƒë·∫∑t.", parent=self.settings_window)
            self.settings_window.destroy()
    def load_gnss_classification_data(self):
        for item in self.gnss_tree.get_children(): self.gnss_tree.delete(item)
        sorted_data = sorted(self.backend.gnss_speed_classification, key=lambda x: float(x.get('mm_giay', 0)), reverse=True)
        self.backend.gnss_speed_classification = sorted_data
        for i, classification in enumerate(sorted_data):
            values = (classification.get("name", ""), classification.get("mm_giay", ""))
            self.gnss_tree.insert("", "end", values=values, tags=(str(i),))
    def edit_gnss_classification(self):
        selected = self.gnss_tree.selection()
        if not selected:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn m·ªôt m·ª•c ƒë·ªÉ ch·ªânh s·ª≠a.", parent=self.classification_win); return
        self.open_classification_editor(int(self.gnss_tree.item(selected[0])["tags"][0]))
    def add_gnss_classification(self):
        self.backend.gnss_speed_classification.append({"name": "Ph√¢n lo·∫°i M·ªõi", "mm_giay": "0.0"})
        self.load_gnss_classification_data(); self.backend.save_config()
    def delete_gnss_classification(self):
        selected = self.gnss_tree.selection()
        if not selected:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn m·ªôt m·ª•c ƒë·ªÉ x√≥a.", parent=self.classification_win); return
        if messagebox.askyesno("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a m·ª•c n√†y?", parent=self.classification_win):
            del self.backend.gnss_speed_classification[int(self.gnss_tree.item(selected[0])["tags"][0])]
            self.load_gnss_classification_data(); self.backend.save_config()
    def reset_gnss_classification(self):
        if messagebox.askyesno("X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc mu·ªën kh√¥i ph·ª•c b·∫£ng v·ªÅ gi√° tr·ªã m·∫∑c ƒë·ªãnh?", parent=self.classification_win):
            self.backend._reset_gnss_to_default()
            self.load_gnss_classification_data(); self.backend.save_config()
    def open_classification_editor(self, index):
        editor_window = Toplevel(self.classification_win)
        editor_window.title("Ch·ªânh s·ª≠a ph√¢n lo·∫°i t·ªëc ƒë·ªô")
        editor_window.geometry("400x150"); editor_window.transient(self.classification_win); editor_window.grab_set()
        classification = self.backend.gnss_speed_classification[index]
        vars_dict = {}
        fields = [("T√™n ph√¢n lo·∫°i:", "name"), ("Ng∆∞·ª°ng t·ªëi thi·ªÉu (mm/gi√¢y):", "mm_giay")]
        main_frame = ttk.Frame(editor_window, padding="10"); main_frame.pack(fill="both", expand=True)
        for i, (label, key) in enumerate(fields):
            vars_dict[key] = tk.StringVar(value=str(classification.get(key, '')))
            ttk.Label(main_frame, text=label).grid(row=i, column=0, sticky="w", pady=5, padx=5)
            entry = ttk.Entry(main_frame, textvariable=vars_dict[key])
            entry.grid(row=i, column=1, sticky="ew", pady=5, padx=5)
        main_frame.grid_columnconfigure(1, weight=1)
        button_frame = ttk.Frame(editor_window); button_frame.pack(fill="x", pady=10)
        def save_changes():
            try:
                float_val = float(vars_dict['mm_giay'].get())
                if float_val < 0: raise ValueError
            except ValueError:
                messagebox.showerror("L·ªói", "Ng∆∞·ª°ng ph·∫£i l√† m·ªôt s·ªë kh√¥ng √¢m.", parent=editor_window); return
            for key, var in vars_dict.items(): classification[key] = var.get().strip()
            self.load_gnss_classification_data(); self.backend.save_config(); editor_window.destroy()
        ttk.Button(button_frame, text="L∆∞u", command=save_changes).pack(side="left", padx=10, expand=True, fill='x')
        ttk.Button(button_frame, text="H·ªßy", command=editor_window.destroy).pack(side="right", padx=10, expand=True, fill='x')
    def show_chart_window(self):
        if self.chart_window and self.chart_window.winfo_exists():
            self.chart_window.lift(); return
        self.chart_window = Toplevel(self.root)
        self.chart_window.title("Bi·ªÉu ƒë·ªì D·ªØ li·ªáu C·∫£m bi·∫øn N∆∞·ªõc"); self.chart_window.geometry("900x650")
        self.chart_window.protocol("WM_DELETE_WINDOW", self.on_chart_close)
        self.current_start_index, self._is_updating_slider, self._slider_after_id = 0, False, None
        self.points_per_view = Constants.CHART_POINTS_PER_VIEW
        top_frame = ttk.Frame(self.chart_window, padding=(10, 5)); top_frame.pack(side=tk.TOP, fill=tk.X)
        ttk.Label(top_frame, text="Ch·ªçn ƒë∆°n v·ªã:").pack(side=tk.LEFT, padx=(0, 5))
        self.unit_selector = ttk.Combobox(top_frame, state="readonly", values=list(self.CONVERSION_FACTORS.keys()))
        self.unit_selector.set("m"); self.unit_selector.pack(side=tk.LEFT, padx=5)
        self.unit_selector.bind("<<ComboboxSelected>>", lambda e: self.update_plot())
        self.auto_follow_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(top_frame, text="T·ª± ƒë·ªông theo d√µi", variable=self.auto_follow_var, command=self.on_auto_follow_toggle).pack(side=tk.LEFT, padx=20)
        chart_frame = ttk.Frame(self.chart_window, padding=(10, 5)); chart_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.fig = Figure(figsize=(9, 4.5), dpi=100)
        self.ax = self.fig.add_subplot(111); self.canvas = FigureCanvasTkAgg(self.fig, master=chart_frame)
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        slider_frame = ttk.Frame(self.chart_window, padding=10); slider_frame.pack(side=tk.BOTTOM, fill=tk.X)
        self.position_var = tk.DoubleVar()
        self.position_scale = ttk.Scale(slider_frame, from_=0, to=100, orient=tk.HORIZONTAL, variable=self.position_var, command=self.on_slider_change)
        self.position_scale.pack(side=tk.TOP, fill=tk.X, expand=True)
        self.info_label = ttk.Label(slider_frame, text="T·ªïng ƒëi·ªÉm: 0 | Hi·ªÉn th·ªã: 0-0", font=("Arial", 9))
        self.info_label.pack(side=tk.TOP, pady=(5, 0)); self.update_plot()
    def clear_chart_data(self): self.current_start_index = 0; self.auto_follow_var.set(True); self.update_plot()
    def update_plot(self):
        if not (self.chart_window and self.chart_window.winfo_exists()): return
        all_data = list(self.backend.plot_data_points); total_points = len(all_data)
        start, end = self._update_slider_and_indices(total_points); self.ax.clear()
        if not all_data[start:end]:
            self._setup_plot_style()
            self.ax.text(0.5, 0.5, 'Ch∆∞a c√≥ d·ªØ li·ªáu', ha='center', va='center', transform=self.ax.transAxes, fontsize=16, color='gray')
            self.info_label.config(text="T·ªïng ƒëi·ªÉm: 0 | Hi·ªÉn th·ªã: 0-0")
        else:
            indices, values, times, unit, warn_thresh, crit_thresh = self._prepare_plot_data(all_data[start:end], start)
            self._setup_plot_style(unit); self._draw_plot_elements(indices, values, warn_thresh, crit_thresh)
            self._configure_plot_axes(start, end, total_points, indices, times)
        self.canvas.draw()
    def _update_slider_and_indices(self, total_points):
        max_start_idx = max(0, total_points - self.points_per_view)
        if total_points <= self.points_per_view: self.position_scale.config(state="disabled"); self.current_start_index = 0
        else:
            self.position_scale.config(state="normal")
            if self.auto_follow_var.get(): self.current_start_index = max_start_idx
            else: self.current_start_index = min(self.current_start_index, max_start_idx)
        self._is_updating_slider = True
        self.position_var.set((self.current_start_index / max_start_idx) * 100 if max_start_idx > 0 else 100)
        self._is_updating_slider = False
        return self.current_start_index, min(total_points, self.current_start_index + self.points_per_view)
    def _prepare_plot_data(self, data_slice, start_index):
        unit = self.unit_selector.get(); conversion_factor = self.CONVERSION_FACTORS.get(unit, 1.0)
        return (range(start_index, start_index + len(data_slice)), [i[1] * conversion_factor for i in data_slice], [i[0] for i in data_slice], unit,
                self.backend.warning_threshold * conversion_factor, self.backend.critical_threshold * conversion_factor)
    def _setup_plot_style(self, unit='Gi√° tr·ªã'):
        self.ax.set_title('D·ªØ li·ªáu C·∫£m bi·∫øn Theo Th·ªùi Gian', fontsize=14, fontweight='bold')
        self.ax.set_xlabel('Th·ªùi gian', fontsize=12); self.ax.set_ylabel(f'Gi√° tr·ªã ({unit})', fontsize=12)
        self.ax.grid(True, which='major', linestyle='--', alpha=0.6)
    def _draw_plot_elements(self, indices, values, warning_thresh, critical_thresh):
        self.ax.plot(indices, values, color='gray', linestyle='-', linewidth=1, alpha=0.5, zorder=3)
        colors = ['green' if v < warning_thresh else 'orange' if v < critical_thresh else 'red' for v in values]
        self.ax.scatter(indices, values, c=colors, s=30, zorder=5)
        self.ax.axhline(y=warning_thresh, color='gold', linestyle='--', linewidth=2, label=f'Ng∆∞·ª°ng C·∫£nh b√°o ({warning_thresh:.2f} {self.unit_selector.get()})')
        self.ax.axhline(y=critical_thresh, color='darkorange', linestyle='--', linewidth=2, label=f'Ng∆∞·ª°ng Nguy hi·ªÉm ({critical_thresh:.2f} {self.unit_selector.get()})')
    def _configure_plot_axes(self, start, end, total_points, indices, times):
        self.ax.set_xlim(left=start - 0.5, right=start + self.points_per_view - 0.5)
        num_ticks = min(len(indices), 8)
        if num_ticks > 1:
            tick_indices = np.linspace(0, len(indices) - 1, num_ticks, dtype=int)
            self.ax.set_xticks([indices[i] for i in tick_indices])
            self.ax.set_xticklabels([times[i].strftime('%H:%M:%S') for i in tick_indices], rotation=25, ha='right')
        elif indices:
            self.ax.set_xticks(indices); self.ax.set_xticklabels([t.strftime('%H:%M:%S') for t in times])
        self.ax.legend(); self.info_label.config(text=f"T·ªïng ƒëi·ªÉm: {total_points} | Hi·ªÉn th·ªã: {start+1}-{end}")
        self.fig.tight_layout()
    def on_auto_follow_toggle(self):
        if self.auto_follow_var.get(): self.update_plot()
    def on_slider_change(self, value_str):
        if self._is_updating_slider: return
        if self._slider_after_id: self.root.after_cancel(self._slider_after_id)
        self._slider_after_id = self.root.after(100, lambda: self._perform_slider_update(float(value_str)))
    def _perform_slider_update(self, value):
        self._slider_after_id = None; self.auto_follow_var.set(False)
        total_points = len(self.backend.plot_data_points)
        if total_points > self.points_per_view:
            self.current_start_index = int((value / 100) * (total_points - self.points_per_view))
            self.update_plot()
    def on_chart_close(self):
        if self._slider_after_id: self.root.after_cancel(self._slider_after_id)
        plt.close(self.fig); self.chart_window.destroy(); self.chart_window = None

# ===========================
# KH·ªêI ƒêI·ªÄU KHI·ªÇN CH√çNH
# ===========================
class MainController:
    def __init__(self, backend, command_queue):
        self.backend = backend
        self.command_queue = command_queue
        self.app_instance = None
        self.root = ttk.Window()
        self.root.withdraw()
    def run(self):
        self.check_for_commands()
        self.root.mainloop()
    def check_for_commands(self):
        try:
            command = self.command_queue.get_nowait()
            if command == 'show': self.create_gui_window()
            elif command == 'exit': self.handle_shutdown()
        except queue.Empty: pass
        finally:
            if not self.backend.exiting and self.root.winfo_exists():
                self.root.after(100, self.check_for_commands)
    def create_gui_window(self):
        if self.app_instance and self.app_instance.root.winfo_exists():
            logger.info("Giao di·ªán ƒë√£ ƒëang ch·∫°y.")
            self.app_instance.root.lift()
            return
        logger.info("ƒêang kh·ªüi ƒë·ªông giao di·ªán ng∆∞·ªùi d√πng...")
        toplevel_window = Toplevel(self.root)
        self.app_instance = AppGUI(toplevel_window, self.backend, self.on_gui_close)
    def on_gui_close(self, shutdown=False): 
        self.app_instance = None
        if shutdown: self.command_queue.put('exit')
    def handle_shutdown(self):
        logger.info("Nh·∫≠n l·ªánh tho√°t...")
        if self.app_instance: self.app_instance.destroy_all_windows()
        self.backend.cleanup_on_exit()
        if self.root.winfo_exists(): self.root.destroy()

command_queue = queue.Queue()
def console_input_listener(cmd_queue: queue.Queue):
    while True:
        try:
            command = input().strip().lower()
            if command: cmd_queue.put(command)
            if command in ['exit', 'restart']: break
        except (EOFError, KeyboardInterrupt):
            cmd_queue.put('exit')
            break
def signal_handler(signum, frame):
    logger.info("\nNh·∫≠n t√≠n hi·ªáu ng·∫Øt (Ctrl+C), ƒëang tho√°t...")
    command_queue.put('exit')

def haversine_3d(p1, p2): # Th√™m h√†m n√†y v√†o led.py ƒë·ªÉ Tab d√†i h·∫°n c√≥ th·ªÉ d√πng
    R = 6371000; lat1, lon1, h1, lat2, lon2, h2 = p1["lat"], p1["lon"], p1["h"], p2["lat"], p2["lon"], p2["h"]
    lat1_rad, lon1_rad, lat2_rad, lon2_rad = map(math.radians, [lat1, lon1, lat2, lon2])
    dlat, dlon = lat2_rad - lat1_rad, lon2_rad - lon1_rad
    a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2
    dist_2d = R * 2 * math.atan2(math.sqrt(a), math.sqrt(1-a)); return math.sqrt(dist_2d**2 + (h2 - h1)**2)

if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal_handler)
    backend_instance = Backend()
    backend_instance.start_background_tasks()
    console_thread = threading.Thread(target=console_input_listener, args=(command_queue,), daemon=True)
    console_thread.start()
    logger.info("="*50)
    logger.info("Ch∆∞∆°ng tr√¨nh Gi√°m s√°t S·∫°t l·ªü ƒë√£ s·∫µn s√†ng.")
    logger.info("G√µ 'show' ƒë·ªÉ m·ªü giao di·ªán, 'exit' ƒë·ªÉ tho√°t.")
    logger.info("="*50)
    main_controller = MainController(backend_instance, command_queue)
    if len(sys.argv) == 1 or 'show' in sys.argv:
        command_queue.put('show')
    main_controller.run()
    logger.info("Ch∆∞∆°ng tr√¨nh ƒë√£ k·∫øt th√∫c.")
