# led.py (Phiên bản Cuối cùng - Giao diện Tabbed)
import tkinter as tk
from tkinter import messagebox, filedialog, Toplevel
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tksheet import Sheet
import paho.mqtt.client as mqtt
import json
from datetime import datetime
import threading
import time
import warnings
import configparser
import signal
import os
import sys
import queue
from collections import deque
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt
import numpy as np
import logging
from logging.handlers import TimedRotatingFileHandler
import atexit
import subprocess
import math
import traceback

# --- THIẾT LẬP MÔI TRƯỜNG VÀ CẢNH BÁO ---
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1"
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", message="Unable to import Axes3D")

# --- CÁC THƯ VIỆN ĐẶC THÙ PI ---
try:
    import RPi.GPIO as GPIO
    import pygame
    IS_PI = True
except (ImportError, RuntimeError):
    IS_PI = False
    print("CẢNH BÁO: Không tìm thấy thư viện RPi.GPIO hoặc pygame. Chương trình sẽ chạy ở chế độ không có phần cứng (no-hardware mode).")

# --- Cấu hình logging nâng cao với xoay vòng và thư mục riêng ---
LOG_DIRECTORY = "sensor_monitor"
os.makedirs(LOG_DIRECTORY, exist_ok=True)

logger = logging.getLogger()
logger.setLevel(logging.INFO)
if not logger.handlers:
    file_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    console_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')

    log_file_path = os.path.join(LOG_DIRECTORY, 'sensor_monitor.log')
    file_handler = TimedRotatingFileHandler(log_file_path, when='midnight', interval=1, backupCount=30, encoding='utf-8')
    file_handler.setLevel(logging.INFO)
    file_handler.setFormatter(file_formatter)
    logger.addHandler(file_handler)

    error_log_file_path = os.path.join(LOG_DIRECTORY, 'sensor_monitor_error.log')
    error_file_handler = TimedRotatingFileHandler(error_log_file_path, when='midnight', interval=1, backupCount=30, encoding='utf-8')
    error_file_handler.setLevel(logging.ERROR)
    error_file_handler.setFormatter(file_formatter)
    logger.addHandler(error_file_handler)

    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)

# ==============================================================================
# QUẢN LÝ HẰNG SỐ
# ==============================================================================
class Constants:
    CONFIG_FILE = 'config.ini'
    SESSION_FILE = "session.json"
    DEFAULT_SOUNDS_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "sounds")
    SIREN_RELAY_PIN = 5
    MAX_PLOT_POINTS = 10000
    MAX_SENSOR_RECORDS = 10000
    CHART_POINTS_PER_VIEW = 40
    DEFAULT_BROKER = "aitogy.xyz"
    DEFAULT_PORT = 1883
    DEFAULT_USER = "abc"
    DEFAULT_PASS = "xyz"
    DEFAULT_WARN_THRESHOLD = 1.0
    DEFAULT_CRIT_THRESHOLD = 1.2
    DATA_CLEAR_SIGNAL = "CLEAR_ALL_DATA"
    WARNING_REPEAT_INTERVAL = 6
    DECREASING_REPEAT_INTERVAL = 10
    SAFE_READINGS_REQUIRED_INITIAL = 10
    SAFE_READINGS_REQUIRED_RETURN_1 = 10
    SAFE_READINGS_REQUIRED_RETURN_2 = 15

# ==============================================================================
# QUẢN LÝ CẢNH BÁO
# ==============================================================================
class AlertManager:
    # ... (Không có thay đổi trong lớp này, giữ nguyên như cũ)
    def __init__(self, backend_ref):
        self.backend = backend_ref
        self.current_level = 0
        self.safe_readings_count = 0
        self.warning_readings_count = 0
        self.decreasing_warning_count = 0
        self.was_in_high_level_state = False
        self.initial_safe_played = False
        self.safe_return_phase = 0
        self.alert_thread = None
    def _play_sequence_in_thread(self, sound_list, loop=False, activate_relay=False):
        self.stop_all_alerts()
        if self.alert_thread and self.alert_thread.is_alive(): return
        def target():
            if not self.backend.mixer_initialized: return
            if activate_relay: self.backend.activate_siren_relay()
            while not self.backend.exiting:
                for sound in sound_list:
                    if sound and not self.backend.exiting:
                        sound.play()
                        while IS_PI and pygame.mixer.get_busy() and not self.backend.exiting: time.sleep(0.1)
                if not loop: break
        self.alert_thread = threading.Thread(target=target, daemon=True)
        self.alert_thread.start()
    def stop_all_alerts(self):
        if self.backend.mixer_initialized: pygame.mixer.stop()
        self.backend.deactivate_siren_relay()
        self.alert_thread = None
    def trigger_critical_event_alarm(self):
        if self.current_level != 3:
            logger.critical("!!! SỰ KIỆN KHẨN CẤP GNSS ĐƯỢC KÍCH HOẠT !!!")
            self.current_level = 3
            self.was_in_high_level_state = True
            self._play_sequence_in_thread([self.backend.siren_sound, self.backend.critical_sound], loop=True, activate_relay=True)
    def process_new_water_value(self, value):
        if self.current_level == 3: return 2
        previous_level = self.current_level
        new_level = self._calculate_alert_level(value)
        if new_level == 0: self._handle_safe_state()
        elif new_level == 1: self._handle_warning_state(previous_level)
        elif new_level == 2: self._handle_critical_state()
        if new_level != previous_level:
            if new_level == 0 and previous_level > 0:
                self.safe_readings_count = 1
                logger.info("Trạng thái nguy hiểm đã kết thúc. Tắt còi báo động.")
                self.stop_all_alerts()
            logger.info(f"Cảnh báo nước: Chuyển trạng thái {previous_level} -> {new_level}")
        self.current_level = new_level
        return new_level
    def _calculate_alert_level(self, value):
        if value >= self.backend.critical_threshold: return 2
        elif value >= self.backend.warning_threshold: return 1
        return 0
    def _handle_safe_state(self):
        self.warning_readings_count = 0
        self.decreasing_warning_count = 0
        self.safe_readings_count += 1
        if not self.was_in_high_level_state:
            if not self.initial_safe_played and self.safe_readings_count == Constants.SAFE_READINGS_REQUIRED_INITIAL:
                self._play_sequence_in_thread([self.backend.safe_sound_1], activate_relay=False)
                self.initial_safe_played = True
        else:
            if self.safe_return_phase == 0: self.safe_return_phase = 1
            if self.safe_return_phase == 1 and self.safe_readings_count == Constants.SAFE_READINGS_REQUIRED_RETURN_1:
                self._play_sequence_in_thread([self.backend.safe_sound_2], activate_relay=False)
                self.safe_return_phase = 2
            elif self.safe_return_phase == 2 and self.safe_readings_count == Constants.SAFE_READINGS_REQUIRED_RETURN_2:
                self._play_sequence_in_thread([self.backend.safe_sound_2], activate_relay=False)
                self.safe_return_phase = 3
                self.was_in_high_level_state = False
                self.initial_safe_played = True
    def _handle_warning_state(self, previous_level):
        self.safe_readings_count = 0
        self.safe_return_phase = 0
        if not self.was_in_high_level_state: self.was_in_high_level_state = True
        if previous_level == 0:
            self._play_sequence_in_thread([self.backend.siren_sound, self.backend.warning_sound], activate_relay=True)
            self.warning_readings_count = 1
            self.decreasing_warning_count = 0
        elif previous_level == 2:
            self._play_sequence_in_thread([self.backend.decreasing_sound], activate_relay=True)
            self.decreasing_warning_count = 1
            self.warning_readings_count = 0
        elif previous_level == 1:
            if self.warning_readings_count > 0:
                self.warning_readings_count += 1
                if self.warning_readings_count % Constants.WARNING_REPEAT_INTERVAL == 0: self._play_sequence_in_thread([self.backend.siren_sound, self.backend.warning_sound], activate_relay=True)
            elif self.decreasing_warning_count > 0:
                self.decreasing_warning_count += 1
                if self.decreasing_warning_count % Constants.DECREASING_REPEAT_INTERVAL == 0: self._play_sequence_in_thread([self.backend.decreasing_sound], activate_relay=True)
    def _handle_critical_state(self):
        self.safe_readings_count = 0
        self.warning_readings_count = 0
        self.decreasing_warning_count = 0
        self.safe_return_phase = 0
        if not self.was_in_high_level_state: self.was_in_high_level_state = True
        self._play_sequence_in_thread([self.backend.siren_sound, self.backend.critical_sound, self.backend.siren_sound], activate_relay=True)


# ==============================================================================
# LỚP LOGIC NỀN (BACKEND)
# ==============================================================================
class Backend:
    # ... (Hàm __init__ và các hàm khác không thay đổi nhiều)
    def __init__(self):
        self.listening = False
        self.exiting = False
        self.status_text = "Trạng thái: THỦ CÔNG"
        self.status_color = "red"
        self.temp_status_text = None
        self.config = configparser.ConfigParser()
        self.broker = Constants.DEFAULT_BROKER
        self.port = Constants.DEFAULT_PORT
        self.username = Constants.DEFAULT_USER
        self.password = Constants.DEFAULT_PASS
        self.publish_topic = ""
        self.water_topics = []
        self.gnss_topics = []
        self.subscribe_topics = []
        self.warning_threshold = Constants.DEFAULT_WARN_THRESHOLD
        self.critical_threshold = Constants.DEFAULT_CRIT_THRESHOLD
        self.gnss_time_settings = {}
        self.sounds_dir = Constants.DEFAULT_SOUNDS_DIR
        self.mixer_initialized = False
        self.warning_sound = None
        self.critical_sound = None
        self.siren_sound = None
        self.decreasing_sound = None
        self.safe_sound_1 = None
        self.safe_sound_2 = None
        
        # <<< THAY ĐỔI: Tách dữ liệu cho 2 bảng >>
        self.overview_data = deque(maxlen=Constants.MAX_SENSOR_RECORDS)
        self.gnss_analysis_data = deque(maxlen=Constants.MAX_SENSOR_RECORDS)

        self.plot_data_points = deque(maxlen=Constants.MAX_PLOT_POINTS)
        self.gui_update_queue = queue.Queue()
        self.client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2, protocol=mqtt.MQTTv311)
        self.client.on_connect = self.on_connect
        self.client.on_disconnect = self.on_disconnect
        self.client.on_message = self.on_message
        self.shifting_process = None
        self.alert_manager = AlertManager(self)
        self.gnss_speed_classification = []

        # <<< CẢI TIẾN: Giám sát Heartbeat >>>
        self.last_shifting_heartbeat = 0
        self.is_shifting_responsive = True

        self.load_config()
        self.setup_audio_mixer()
        self.setup_gpio()
        atexit.register(self.cleanup_on_exit)

    def start_background_tasks(self):
        self.load_session_data()
        threading.Thread(target=self.auto_clear_scheduler, daemon=True).start()
        threading.Thread(target=self.check_shifting_health, daemon=True).start() # <<< CẢI TIẾN
        logger.info("Đã khởi chạy các tác vụ nền.")

    def check_shifting_health(self):
        while not self.exiting:
            if self.listening and self.shifting_process and self.shifting_process.poll() is None:
                # Chỉ kiểm tra nếu đang ở chế độ Tự động và tiến trình đang chạy
                if time.time() - self.last_shifting_heartbeat > 60 and self.last_shifting_heartbeat != 0:
                    if self.is_shifting_responsive:
                        logger.critical("TIẾN TRÌNH SHIFTING KHÔNG PHẢN HỒI! Đang thử khởi động lại...")
                        self.is_shifting_responsive = False
                        self.temp_status_text = "LỖI: Tiến trình phân tích không phản hồi!"
                        # Cố gắng khởi động lại
                        self.stop_shifting_process()
                        time.sleep(2)
                        self.start_shifting_process()
            time.sleep(15)

    def on_message(self, client, userdata, msg):
        if not self.listening or self.exiting: return
        if msg.topic in self.gnss_topics: return
        try:
            data = json.loads(msg.payload.decode('utf-8'))
            if "value" in data:
                value = float(data.get("value"))
                new_level = self.alert_manager.process_new_water_value(value)
                name = data.get("sensorname", msg.topic)
                ts = float(data.get("timestamp", time.time()))
                dt_object = datetime.fromtimestamp(ts)
                status = "NGUY HIEM" if new_level == 2 else ("CANH BAO" if new_level == 1 else "AN TOAN")
                
                # <<< THAY ĐỔI: Đưa dữ liệu vào đúng hàng đợi >>>
                record = (name, f"{value:.4f}", status, dt_object.strftime("%H:%M:%S %d-%m"))
                self.overview_data.append(record)
                self.plot_data_points.append((dt_object, value))
                self.gui_update_queue.put(("overview", record)) # Gửi kèm loại dữ liệu

                if self.publish_topic: self.client.publish(self.publish_topic, f"{name},{value},{status},{ts}")
        except (json.JSONDecodeError, ValueError, KeyError) as e:
            logger.error(f"Lỗi xử lý message: {e} | Payload: {msg.payload.decode('utf-8', errors='ignore')}")
    
    def _read_shifting_output(self, pipe):
        for line in iter(pipe.readline, ''):
            try:
                line_str = line.strip()
                if not line_str: continue
                data = json.loads(line_str)
                # <<< THAY ĐỔI: Gửi dữ liệu GNSS kèm loại >>>
                self.gui_update_queue.put(("gnss", data)) 
            except json.JSONDecodeError: logger.warning(f"Nhận được dòng không phải JSON từ shifting.py: {line_str}")
            except Exception as e:
                logger.error(f"Lỗi trong luồng đọc shifting.py: {e}")
                break
        pipe.close()
        logger.info("Luồng đọc kết quả từ shifting.py đã dừng.")

    def toggle_on(self):
        if self.listening: return
        self.listening = True
        self.status_text, self.status_color = "Trạng thái: ĐANG KẾT NỐI...", "orange"
        if not self.broker:
            self.listening = False
            self.status_text, self.status_color = "Trạng thái: THỦ CÔNG (Lỗi Broker)", "red"
            logger.error("Không thể bật, chưa cấu hình MQTT Broker.")
            return
        try:
            self.client.username_pw_set(self.username, self.password)
            logger.info(f"Đang kết nối tới MQTT broker: {self.broker}:{self.port}...")
            self.client.connect_async(self.broker, self.port, 60)
            self.client.loop_start()
            if self.gnss_topics:
                self.last_shifting_heartbeat = time.time() # Reset heartbeat timer
                self.is_shifting_responsive = True
                self.start_shifting_process()
        except Exception as e:
            self.listening = False
            self.status_text, self.status_color = "Trạng thái: LỖI KẾT NỐI", "red"
            logger.error(f"Lỗi khi kết nối MQTT: {e}")

    def clear_all_data(self):
        self.overview_data.clear()
        self.gnss_analysis_data.clear()
        self.plot_data_points.clear()
        self.gui_update_queue.put(("clear", None))
        logger.info("Đã xóa dữ liệu nền.")

    def save_session_data(self, silent=False):
        if not silent: logger.info("Đang lưu trạng thái hiện tại vào file...")
        try:
            plot_data_serializable = [(dt.isoformat(), val) for dt, val in self.plot_data_points]
            session = {
                "overview_data": list(self.overview_data),
                "gnss_analysis_data": list(self.gnss_analysis_data),
                "plot_data_points": plot_data_serializable
            }
            with open(Constants.SESSION_FILE, "w") as f: json.dump(session, f)
            if not silent: logger.info(f"Đã lưu trạng thái vào {Constants.SESSION_FILE}")
        except Exception as e: logger.error(f"Lỗi khi lưu trạng thái: {e}")

    def load_session_data(self):
        if not os.path.exists(Constants.SESSION_FILE): return
        logger.info(f"Tìm thấy file trạng thái {Constants.SESSION_FILE}, đang tải lại dữ liệu...")
        try:
            with open(Constants.SESSION_FILE, "r") as f: session = json.load(f)
            
            overview_records = session.get("overview_data", [])
            self.overview_data.extend(overview_records)
            for record in overview_records: self.gui_update_queue.put(("overview", record))
            
            gnss_records = session.get("gnss_analysis_data", [])
            self.gnss_analysis_data.extend(gnss_records)
            for record in gnss_records: self.gui_update_queue.put(("gnss_record", record))

            plot_data_serializable = session.get("plot_data_points", [])
            self.plot_data_points.clear()
            for dt_str, val in plot_data_serializable: self.plot_data_points.append((datetime.fromisoformat(dt_str), val))
            
            logger.info("Đã tải lại dữ liệu thành công.")
        except Exception as e: logger.error(f"Lỗi khi tải trạng thái: {e}")
        finally:
            if os.path.exists(Constants.SESSION_FILE): os.remove(Constants.SESSION_FILE)
    
    # ... (Các hàm khác như _reset_gnss_to_default, save_config, ... giữ nguyên)
    def _reset_gnss_to_default(self):
        logger.info("Đang khôi phục bảng phân loại GNSS về tiêu chuẩn Cruden & Varnes (1996) / IUGS.")
        self.gnss_speed_classification = [
            {"name": "Cực kỳ nhanh", "m_nam": ">157.680.000", "m_thang": "", "m_ngay": ">432.000", "m_gio": ">18.000", "m_phut": ">300", "m_giay": ">5", "mm_giay": 5000},
            {"name": "Rất nhanh", "m_nam": "1.576.800", "m_thang": "", "m_ngay": "4.320", "m_gio": "180", "m_phut": "3", "m_giay": "0.05", "mm_giay": 50},
            {"name": "Nhanh", "m_nam": "15.768", "m_thang": "1.300", "m_ngay": "43.2", "m_gio": "1.8", "m_phut": "0.03", "m_giay": "0.0005", "mm_giay": 0.5},
            {"name": "Trung bình", "m_nam": "550", "m_thang": "45", "m_ngay": "1.5", "m_gio": "0.06", "m_phut": "0.001", "m_giay": "1.7e-5", "mm_giay": 0.017},
            {"name": "Chậm", "m_nam": "1.5", "m_thang": "0.125", "m_ngay": "0.004", "m_gio": "1.7e-4", "m_phut": "", "m_giay": "", "mm_giay": 4.7e-5},
            {"name": "Rất chậm", "m_nam": "0.016", "m_thang": "0.0013", "m_ngay": "", "m_gio": "", "m_phut": "", "m_giay": "", "mm_giay": 5.0e-7},
            {"name": "Cực kỳ chậm", "m_nam": "<0.016", "m_thang": "", "m_ngay": "", "m_gio": "", "m_phut": "", "m_giay": "", "mm_giay": 0}
        ]
    def start_shifting_process(self):
        if self.shifting_process and self.shifting_process.poll() is None:
            logger.info("Tiến trình shifting.py đã đang chạy.")
            return
        if not self.gnss_topics:
            logger.warning("Không có topic GNSS nào để khởi động shifting.py.")
            return
        try:
            classification_table_json = json.dumps(self.gnss_speed_classification)
            command = [sys.executable, '-u', 'shifting.py', '--broker', self.broker, '--port', str(self.port), '--classification-table', classification_table_json]
            if self.username: command.extend(['--username', self.username])
            if self.password: command.extend(['--password', self.password])
            for topic in self.gnss_topics: command.extend(['--topic', topic])
            logger.info(f"Đang khởi chạy shifting.py...")
            self.shifting_process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8', errors='ignore')
            threading.Thread(target=self._read_shifting_output, args=(self.shifting_process.stdout,), daemon=True).start()
            threading.Thread(target=self._log_process_errors, args=(self.shifting_process.stderr, "SHIFTING"), daemon=True).start()
            logger.info("Đã khởi động tiến trình shifting.py và luồng đọc kết quả.")
        except Exception as e:
            logger.error(f"Lỗi khởi động shifting.py: {e}")
            if self.shifting_process: self.shifting_process.kill()
            self.shifting_process = None
    def _log_process_errors(self, pipe, process_name):
        for line in iter(pipe.readline, ''):
            error_message = line.strip()
            if error_message: logger.error(f"[{process_name}_ERROR]: {error_message}")
        pipe.close()
    def stop_shifting_process(self):
        if self.shifting_process and self.shifting_process.poll() is None:
            try:
                logger.info("Đang dừng tiến trình shifting.py...")
                self.shifting_process.terminate()
                self.shifting_process.wait(timeout=5)
                logger.info(f"Đã dừng thành công tiến trình shifting.py.")
            except subprocess.TimeoutExpired:
                logger.warning("Tiến trình shifting.py không phản hồi, buộc dừng (kill).")
                self.shifting_process.kill()
            except Exception as e: logger.error(f"Lỗi khi dừng shifting.py: {e}")
        self.shifting_process = None
    def setup_audio_mixer(self):
        if not IS_PI:
            self.mixer_initialized = False
            return
        try:
            logger.info("Đang khởi tạo audio mixer...")
            pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=4096)
            self.mixer_initialized = True
            self.siren_sound = self._load_sound("coi1.mp3")
            self.warning_sound = self._load_sound("warning.mp3")
            self.critical_sound = self._load_sound("danger.mp3")
            self.decreasing_sound = self._load_sound("decrease.mp3")
            self.safe_sound_1 = self._load_sound("safe.mp3")
            self.safe_sound_2 = self._load_sound("safe2.mp3")
            logger.info("Audio mixer đã sẵn sàng.")
        except Exception as e:
            logger.error(f"Không thể khởi tạo pygame mixer: {e}")
            self.mixer_initialized = False
    def _load_sound(self, filename):
        if not IS_PI: return None
        path = os.path.join(self.sounds_dir, filename)
        if os.path.exists(path):
            try: return pygame.mixer.Sound(path)
            except Exception as e:
                logger.error(f"Lỗi khi tải file âm thanh '{path}': {e}")
                return None
        logger.warning(f"Không tìm thấy file âm thanh: {path}")
        return None
    # <<< THAY THẾ TOÀN BỘ HÀM CŨ BẰNG HÀM MỚI NÀY >>>
    def update_and_reconnect(self, settings: dict):
    # --- 1. Xác định những gì đã thay đổi ---
    
    # Tạo một "dấu vân tay" cho các cài đặt ảnh hưởng đến shifting.py
    # Dùng json.dumps để so sánh bảng phân loại một cách dễ dàng.
        old_shifting_signature = (
            f"{self.broker}-{self.port}-{self.username}-{self.password}-"
            f"{'-'.join(sorted(self.gnss_topics))}-"
            f"{json.dumps(self.gnss_speed_classification, sort_keys=True)}"
        )

    # Lấy danh sách topic nước cũ để so sánh
        old_water_topics = self.water_topics

    # --- 2. Cập nhật tất cả các cài đặt mới vào backend ---
    
        self.broker = settings['broker']
        self.port = int(settings['port'])
        self.username = settings['username']
        self.password = settings['password']
        self.publish_topic = settings['publish']
        self.water_topics = [t.strip() for t in settings.get('water_topics', '').splitlines() if t.strip()]
        self.gnss_topics = [t.strip() for t in settings.get('gnss_topics', '').splitlines() if t.strip()]
        self.subscribe_topics = self.water_topics # led.py chỉ sub topic nước
        self.warning_threshold = float(settings['warning_threshold'])
        self.critical_threshold = float(settings['critical_threshold'])
    
        new_sounds_dir = settings['sounds_dir']
        if new_sounds_dir != self.sounds_dir:
            self.sounds_dir = new_sounds_dir
            logger.info(f"Đường dẫn âm thanh đổi, tải lại từ: {self.sounds_dir}")
            self.setup_audio_mixer()

    # --- 3. Tạo "dấu vân tay" mới và so sánh ---

        new_shifting_signature = (
            f"{self.broker}-{self.port}-{self.username}-{self.password}-"
            f"{'-'.join(sorted(self.gnss_topics))}-"
            f"{json.dumps(self.gnss_speed_classification, sort_keys=True)}"
        )

        needs_shifting_restart = (old_shifting_signature != new_shifting_signature)
        needs_led_mqtt_reconnect = (set(old_water_topics) != set(self.water_topics))

    # --- 4. Thực hiện các hành động cần thiết ---

        self.save_config() # Luôn lưu cấu hình

    # Nếu không ở chế độ Tự động, không cần làm gì thêm
        if not self.listening:
            logger.info("Cài đặt đã được lưu. Hệ thống đang ở chế độ Thủ công.")
            return

    # Chỉ khởi động lại khi thực sự cần thiết
        if needs_shifting_restart:
            logger.info("Phát hiện thay đổi trong cài đặt GNSS hoặc Broker. Đang khởi động lại toàn bộ hệ thống...")
        # Cách đơn giản và an toàn nhất là khởi động lại toàn bộ
            self.toggle_off()
            time.sleep(1)
            self.toggle_on()
        elif needs_led_mqtt_reconnect:
            logger.info("Phát hiện thay đổi trong Topic Nước. Chỉ kết nối lại MQTT cho cảm biến nước...")
        # Ngắt kết nối và kết nối lại chỉ client của led.py
            try:
                self.client.loop_stop()
                self.client.disconnect()
            except Exception: pass
        
        # Kết nối lại
            try:
                self.client.connect_async(self.broker, self.port, 60)
                self.client.loop_start()
            except Exception as e:
                logger.error(f"Lỗi khi kết nối lại MQTT cho led.py: {e}")
                self.status_text, self.status_color = "Trạng thái: LỖI KẾT NỐI", "red"
        else:
            logger.info("Các cài đặt không ảnh hưởng đến kết nối đã được cập nhật (ví dụ: ngưỡng, âm thanh). Không cần khởi động lại.")
    def load_config(self):
        if not os.path.exists(Constants.CONFIG_FILE):
            logger.warning(f"File cấu hình '{Constants.CONFIG_FILE}' không tồn tại. Tạo mặc định.")
            self._reset_gnss_to_default()
            self.save_config()
            return
        try:
            self.config.read(Constants.CONFIG_FILE, encoding='utf-8')
            if "MQTT" in self.config:
                mqtt_cfg = self.config["MQTT"]
                self.broker = mqtt_cfg.get("broker", self.broker)
                self.port = mqtt_cfg.getint("port", self.port)
                self.username = mqtt_cfg.get("username", self.username)
                self.password = mqtt_cfg.get("password", self.password)
                self.water_topics = [t.strip() for t in mqtt_cfg.get("water_sub_topic", "").splitlines() if t.strip()]
                self.gnss_topics = [t.strip() for t in mqtt_cfg.get("gnss_sub_topic", "").splitlines() if t.strip()]
                self.subscribe_topics = self.water_topics
                self.publish_topic = mqtt_cfg.get("publish", self.publish_topic)
            if "Settings" in self.config:
                settings_cfg = self.config["Settings"]
                self.warning_threshold = settings_cfg.getfloat("warning_threshold", self.warning_threshold)
                self.critical_threshold = settings_cfg.getfloat("critical_threshold", self.critical_threshold)
                self.sounds_dir = settings_cfg.get("sounds_dir", self.sounds_dir)
            if "GNSS_Classification" in self.config and self.config['GNSS_Classification']: self._load_gnss_from_config(self.config["GNSS_Classification"])
            else: self._reset_gnss_to_default()
            self.setup_audio_mixer()
        except Exception as e:
            logger.error(f"Lỗi tải cấu hình: {e}")
            self._reset_gnss_to_default()
    def _load_gnss_from_config(self, gnss_cfg):
        items_dict = {}
        for key, value in gnss_cfg.items():
            if key.startswith('item_'):
                parts = key.split('_', 2)
                if len(parts) == 3:
                    item_index, attr_name = int(parts[1]), parts[2]
                    if item_index not in items_dict: items_dict[item_index] = {}
                    items_dict[item_index][attr_name] = value
        if items_dict: self.gnss_speed_classification = [items_dict[i] for i in sorted(items_dict.keys())]
    def save_config(self):
        try:
            self.config['MQTT'] = {'broker': self.broker, 'port': self.port, 'username': self.username, 'password': self.password,
                'water_sub_topic': "\n".join(self.water_topics), 'gnss_sub_topic': "\n".join(self.gnss_topics), 'publish': self.publish_topic}
            self.config['Settings'] = {'warning_threshold': self.warning_threshold, 'critical_threshold': self.critical_threshold, 'sounds_dir': self.sounds_dir}
            gnss_section = {}
            for i, item in enumerate(self.gnss_speed_classification):
                for key, value in item.items(): gnss_section[f'item_{i}_{key}'] = str(value)
            self.config['GNSS_Classification'] = gnss_section
            with open(Constants.CONFIG_FILE, 'w', encoding='utf-8') as f: self.config.write(f)
            logger.info("Đã lưu cấu hình.")
        except Exception as e: logger.error(f"Lỗi lưu cấu hình: {e}")
    def cleanup_on_exit(self):
        if self.exiting: return
        logger.info("Bắt đầu quá trình dọn dẹp để thoát...")
        self.exiting = True
        self.stop_shifting_process()
        try:
            if self.client and self.client.is_connected():
                self.client.loop_stop()
                self.client.disconnect()
        except Exception as e: logger.error(f"Lỗi khi ngắt kết nối MQTT: {e}")
        self.save_session_data(silent=True)
        if IS_PI: GPIO.cleanup()
        logger.info("Backend đã dừng.")
    def setup_gpio(self):
        if not IS_PI: return
        try:
            GPIO.setmode(GPIO.BCM)
            GPIO.setwarnings(False)
            GPIO.setup(Constants.SIREN_RELAY_PIN, GPIO.OUT, initial=GPIO.LOW)
            logger.info(f"GPIO setup successful for Siren Relay on pin {Constants.SIREN_RELAY_PIN}.")
        except Exception as e: logger.error(f"Lỗi khi cài đặt GPIO: {e}. Vui lòng chạy với quyền sudo.")
    def activate_siren_relay(self):
        if not IS_PI: return
        try:
            GPIO.output(Constants.SIREN_RELAY_PIN, GPIO.HIGH)
            logger.info("Rơ-le còi báo động đã được KÍCH HOẠT (ON).")
        except Exception as e: logger.error(f"Lỗi kích hoạt rơ-le: {e}")
    def deactivate_siren_relay(self):
        if not IS_PI: return
        try:
            GPIO.output(Constants.SIREN_RELAY_PIN, GPIO.LOW)
            logger.info("Rơ-le còi báo động đã được NGẮT (OFF).")
        except Exception as e: logger.error(f"Lỗi ngắt rơ-le: {e}")
    def on_connect(self, client, userdata, flags, rc, properties):
        if self.exiting: return
        if rc.value == 0:
            logger.info("MQTT Connected successfully.")
            self.status_text, self.status_color = "Trạng thái: TỰ ĐỘNG", "green"
            if self.subscribe_topics:
                for t in self.subscribe_topics:
                    client.subscribe(t)
                    logger.info(f"Subscribed: {t}")
            else:
                logger.warning("Không có topic nào để subscribe.")
                self.status_text = "Trạng thái: TỰ ĐỘNG (Không có topic)"
        else:
            logger.error(f"Failed to connect to MQTT, return code {rc.rc}")
            self.status_text, self.status_color = "Trạng thái: LỖI KẾT NỐI", "red"
            self.listening = False
    def on_disconnect(self, client, userdata, disconnect_flags, reason_code, properties):
        if not self.exiting and self.listening:
            logger.warning("Mất kết nối MQTT...")
            self.status_text, self.status_color = "Trạng thái: MẤT KẾT NỐI", "orange"
    def get_gui_updates(self):
        updates = []
        while not self.gui_update_queue.empty():
            try: updates.append(self.gui_update_queue.get_nowait())
            except queue.Empty: break
        return updates
    def toggle_off(self):
        if not self.listening: return
        self.listening = False
        self.stop_shifting_process()
        try:
            self.client.loop_stop()
            self.client.disconnect()
            logger.info("Đã ngắt kết nối MQTT.")
        except Exception: pass
        self.status_text, self.status_color = "Trạng thái: THỦ CÔNG", "red"
        self.temp_status_text = None
    def test_siren_relay(self):
        if self.listening:
            logger.warning("Không thể kiểm tra còi ở chế độ TỰ ĐỘNG.")
            return False
        if not IS_PI:
            logger.warning("Không thể kiểm tra còi, không phải môi trường Raspberry Pi.")
            return False
        def target():
            logger.info("Đang kiểm tra còi báo động...")
            self.activate_siren_relay()
            time.sleep(2)
            self.deactivate_siren_relay()
            logger.info("Kiểm tra còi hoàn tất.")
        threading.Thread(target=target, daemon=True).start()
        return True
    def test_specific_sound(self, filepath):
        if not IS_PI or not self.mixer_initialized:
            logger.warning("Không thể kiểm tra âm thanh, pygame mixer chưa sẵn sàng.")
            return "Mixer not ready"
        if not os.path.exists(filepath):
            logger.error(f"File âm thanh kiểm tra không tồn tại: {filepath}")
            return "File not found"
        def target():
            try:
                logger.info(f"Đang phát file kiểm tra: {os.path.basename(filepath)}")
                pygame.mixer.stop()
                test_sound = pygame.mixer.Sound(filepath)
                test_sound.play()
            except Exception as e: logger.error(f"Lỗi khi phát file kiểm tra '{filepath}': {e}")
        threading.Thread(target=target, daemon=True).start()
        return "OK"
    def auto_clear_scheduler(self):
        while not self.exiting:
            now = datetime.now()
            if now.hour == 0 and now.minute == 0:
                logger.info("Đã đến 00:00, tự động xóa dữ liệu...")
                self.clear_all_data()
                time.sleep(61)
            else: time.sleep(30)


# ==============================================================================
# LỚP GIAO DIỆN NGƯỜI DÙNG (GUI)
# ==============================================================================
class AppGUI:
    def __init__(self, root: tk.Toplevel, backend: Backend, on_close_callback):
        self.root = root
        self.backend = backend
        self.on_close_callback = on_close_callback
        self.root.title("Giao diện Cảm biến & Điều khiển Còi báo động")
        self.root.geometry(f"{self.root.winfo_screenwidth()}x{self.root.winfo_screenheight()-70}+0+0")
        self.chart_window = None
        self.settings_window = None
        self.classification_win = None
        self.warning_threshold_var = tk.StringVar()
        self.critical_threshold_var = tk.StringVar()
        self.sounds_dir_var = tk.StringVar()
        self.test_sound_path_var = tk.StringVar()
        self.CONVERSION_FACTORS = {"m": 1.0, "cm": 100.0, "mm": 1000.0, "ft": 3.28084}
        self.create_widgets()
        self.load_initial_data()
        self.root.after(250, self.periodic_update)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close_window)
    
    def create_widgets(self):
        main = ttk.Frame(self.root, padding=10)
        main.pack(fill="both", expand=True)
        main.grid_columnconfigure(1, weight=1)
        main.grid_columnconfigure(0, weight=0, minsize=350)
        main.grid_rowconfigure(0, weight=1)
        self.create_left_panel(main)
        self.create_right_panel(main)

    def create_left_panel(self, parent):
        # ... (Không có thay đổi trong hàm này) ...
        left = ttk.LabelFrame(parent, text="Cài đặt & Điều khiển", padding=10)
        left.grid(row=0, column=0, sticky="nsw", padx=(0, 15))
        
        # MQTT Settings
        mqtt_frame = ttk.LabelFrame(left, text="Cài đặt MQTT", padding=10)
        mqtt_frame.pack(fill=tk.X, expand=True)
        
        def add_labeled_entry(frame, label, row, show=None):
            ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w", pady=3)
            entry = ttk.Entry(frame, show=show)
            entry.grid(row=row, column=1, sticky="ew", pady=3, columnspan=2)
            return entry
            
        self.broker_entry = add_labeled_entry(mqtt_frame, "MQTT Broker:", 0)
        self.port_entry = add_labeled_entry(mqtt_frame, "Port:", 1)
        self.user_entry = add_labeled_entry(mqtt_frame, "Username:", 2)
        self.pass_entry = add_labeled_entry(mqtt_frame, "Password:", 3, show="*")
        ttk.Button(mqtt_frame, text="👁", command=self.toggle_pass, width=2, bootstyle="light").grid(row=3, column=2, sticky="e")
        self.pub_entry = add_labeled_entry(mqtt_frame, "Publish Topic:", 4)
        ttk.Label(mqtt_frame, text="Water Sub Topic:").grid(row=5, column=0, columnspan=3, sticky="w", pady=(10, 2))
        self.water_topic_entry = tk.Text(mqtt_frame, height=4, width=35, relief="solid", borderwidth=1)
        self.water_topic_entry.grid(row=6, column=0, columnspan=3, pady=(0, 5), sticky="nsew")
        ttk.Label(mqtt_frame, text="GNSS Sub Topic:").grid(row=7, column=0, columnspan=3, sticky="w", pady=(10, 2))
        self.gnss_topic_entry = tk.Text(mqtt_frame, height=4, width=35, relief="solid", borderwidth=1)
        self.gnss_topic_entry.grid(row=8, column=0, columnspan=3, pady=(0, 5), sticky="nsew")
        mqtt_frame.grid_columnconfigure(1, weight=1)

        # Control Panel
        control_frame = ttk.LabelFrame(left, text="Bảng điều khiển", padding=10)
        control_frame.pack(fill=tk.X, expand=True, pady=(10,0))
        ttk.Button(control_frame, text="Lưu & Áp dụng", command=lambda: self.apply_and_save_config(), bootstyle="primary").pack(fill=tk.X, pady=2)
        ttk.Button(control_frame, text="Tự động (ON)", command=self.backend.toggle_on, bootstyle="success").pack(fill=tk.X, pady=2)
        ttk.Button(control_frame, text="Thủ công (OFF)", command=self.backend.toggle_off, bootstyle="danger").pack(fill=tk.X, pady=2)
        ttk.Button(control_frame, text="Xóa Toàn bộ Dữ liệu", command=self.clear_all_gui_data, bootstyle="warning").pack(fill=tk.X, pady=2)
        ttk.Button(control_frame, text="Xem Biểu Đồ Nước", command=self.show_chart_window, bootstyle="info").pack(fill=tk.X, pady=2)
        ttk.Button(control_frame, text="Cài đặt Nâng cao", command=self.open_settings_window, bootstyle="secondary").pack(fill=tk.X, pady=(10, 2))
        
        # Device Test Panel
        device_panel = ttk.LabelFrame(left, text="Kiểm tra Thiết bị", padding=10)
        device_panel.pack(fill=tk.X, expand=True, pady=(10, 0))
        ttk.Button(device_panel, text="Kiểm tra Còi", command=self.on_test_siren_click).pack(fill=tk.X)
        
        # Exit Button
        ttk.Button(left, text="Thoát Chương trình", command=self.exit_program_graceful, bootstyle="secondary-outline").pack(side=tk.BOTTOM, fill=tk.X, pady=(15,0))


    # <<< ĐẠI NÂNG CẤP: Tái cấu trúc thành giao diện Tabbed >>>
    def create_right_panel(self, parent):
        right = ttk.Frame(parent)
        right.grid(row=0, column=1, sticky="nsew")
        right.grid_rowconfigure(1, weight=1)
        right.grid_columnconfigure(0, weight=1)
        
        self.status_label = ttk.Label(right, text="", font=("Arial", 11, "bold"))
        self.status_label.grid(row=0, column=0, sticky="ew", pady=(0, 5))

        # Tạo Notebook (widget quản lý các tab)
        self.notebook = ttk.Notebook(right)
        self.notebook.grid(row=1, column=0, sticky="nsew")

        # Tạo các tab
        tab1_frame = ttk.Frame(self.notebook, padding=5)
        tab2_frame = ttk.Frame(self.notebook, padding=5)
        
        self.notebook.add(tab2_frame, text='  Phân tích Dịch chuyển GNSS  ')
        self.notebook.add(tab1_frame, text='  Tổng quan & Cảnh báo Nước  ')
        
        # Đổ nội dung vào từng tab
        self.create_gnss_analysis_tab(tab2_frame)
        self.create_overview_tab(tab1_frame)
    
    def create_gnss_analysis_tab(self, parent_tab):
        parent_tab.grid_rowconfigure(1, weight=1)
        parent_tab.grid_columnconfigure(0, weight=1)

        # 1. Bảng điều khiển
        dashboard_frame = ttk.LabelFrame(parent_tab, text="Bảng điều khiển Giám sát Dịch chuyển", padding=10)
        dashboard_frame.grid(row=0, column=0, sticky="ew", pady=5)
        self.create_gnss_dashboard(dashboard_frame)

        # 2. Bảng dữ liệu chi tiết
        sheet_frame = ttk.Frame(parent_tab)
        sheet_frame.grid(row=1, column=0, sticky="nsew", pady=(10,0))
        
        gnss_headers = ["Thời gian", "Tốc độ ngang\n(mm/s)", "Tốc độ đứng\n(mm/s)", "Hướng\n(°)", "Gia tốc ngang\n(mm/s²)", "Tổng dịch chuyển\n(m)", "Phân loại"]
        self.sheet_gnss = Sheet(sheet_frame, headers=gnss_headers, show_row_index=True)
        self.sheet_gnss.pack(fill=tk.BOTH, expand=True)
        self.sheet_gnss.set_options(font=("Arial", 10, "normal"), header_font=("Arial", 9, "bold"), align="center")
        self.sheet_gnss.column_width(column=0, width=80)
        self.sheet_gnss.column_width(column=6, width=120)

        # 3. Nút lưu CSV cho tab này
        ttk.Button(parent_tab, text="Lưu Bảng Phân tích GNSS (CSV)", command=self.save_gnss_to_csv, bootstyle="info-outline").grid(row=2, column=0, sticky='e', pady=5)
        
    def create_overview_tab(self, parent_tab):
        parent_tab.grid_rowconfigure(0, weight=1)
        parent_tab.grid_columnconfigure(0, weight=1)
        
        sheet_frame = ttk.Frame(parent_tab)
        sheet_frame.grid(row=0, column=0, sticky="nsew")
        
        overview_headers = ["Tên Cảm biến/Sự kiện", "Giá trị", "Trạng thái", "Thời gian"]
        self.sheet_overview = Sheet(sheet_frame, headers=overview_headers, show_row_index=True)
        self.sheet_overview.pack(fill=tk.BOTH, expand=True)
        self.sheet_overview.set_options(font=("Arial", 10, "normal"), header_font=("Arial", 10, "bold"), align="center")

        ttk.Button(parent_tab, text="Lưu Bảng Tổng quan (CSV)", command=self.save_overview_to_csv, bootstyle="info-outline").grid(row=1, column=0, sticky='e', pady=5)

    def create_gnss_dashboard(self, parent):
        parent.grid_columnconfigure(1, weight=1)
        # La bàn
        self.compass_canvas = tk.Canvas(parent, width=150, height=150, bg='white', highlightthickness=0)
        self.compass_canvas.grid(row=0, column=0, rowspan=5, padx=(10, 20), pady=5)
        self.draw_compass_base()
        # Các thông số
        def add_metric_label(text, row):
            ttk.Label(parent, text=text, font=('Arial', 10, 'bold')).grid(row=row, column=1, sticky='w', padx=5)
            var = tk.StringVar(value="---")
            ttk.Label(parent, textvariable=var, font=('Arial', 10, 'normal')).grid(row=row, column=2, sticky='w', padx=5)
            return var
        self.h_speed_var = add_metric_label("Tốc độ ngang:", 0)
        self.v_speed_var = add_metric_label("Tốc độ đứng:", 1)
        self.direction_var = add_metric_label("Hướng dịch chuyển:", 2)
        self.acceleration_var = add_metric_label("Gia tốc ngang:", 3)
        self.displacement_var = add_metric_label("Tổng dịch chuyển:", 4)

    def draw_compass_base(self):
        w, h = 150, 150
        self.compass_canvas.create_oval(5, 5, w-5, h-5, outline='gray', width=1)
        for i in range(0, 360, 30):
            rad = math.radians(i)
            self.compass_canvas.create_line(w/2 + 65*math.sin(rad), h/2 - 65*math.cos(rad), w/2 + 70*math.sin(rad), h/2 - 70*math.cos(rad), fill='gray')
        self.compass_canvas.create_text(w/2, 15, text="N", font=('Arial', 10, 'bold'))
        self.compass_canvas.create_text(w/2, h-15, text="S", font=('Arial', 10, 'bold'))
        self.compass_canvas.create_text(15, h/2, text="W", font=('Arial', 10, 'bold'))
        self.compass_canvas.create_text(w-15, h/2, text="E", font=('Arial', 10, 'bold'))
        self.compass_needle = self.compass_canvas.create_line(w/2, h/2, w/2, 25, arrow=tk.LAST, width=3, fill='red')

    def update_compass_needle(self, angle_deg):
        w, h = 150, 150
        angle_rad = math.radians(angle_deg)
        end_x = w/2 + 60 * math.sin(angle_rad)
        end_y = h/2 - 60 * math.cos(angle_rad)
        self.compass_canvas.coords(self.compass_needle, w/2, h/2, end_x, end_y)

    # <<< ĐẠI NÂNG CẤP: Logic cập nhật giao diện thông minh >>>
    def periodic_update(self):
        if not self.root.winfo_exists(): return

        for data_type, item in self.backend.get_gui_updates():
            if data_type == "clear":
                self.sheet_overview.set_sheet_data(data=[])
                self.sheet_gnss.set_sheet_data(data=[])
                if self.chart_window and self.chart_window.winfo_exists():
                    self.chart_window.clear_chart_data()
                logger.info("GUI đã nhận tín hiệu và xóa tất cả các bảng.")
                continue

            if data_type == "gnss":
                if item.get("type") == "HEARTBEAT":
                    self.backend.last_shifting_heartbeat = time.time()
                    if not self.backend.is_shifting_responsive:
                         logger.info("Tiến trình Shifting đã phản hồi trở lại.")
                         self.backend.is_shifting_responsive = True
                    continue

                if item.get("type") == "collection_status":
                    collected = item.get("collected", 0)
                    total = item.get("total", "N/A")
                    self.backend.temp_status_text = f"SHIFTING: Đang thu thập dữ liệu... [{collected}/{total}]"
                    continue 

                if item.get("type") == "ultimate_analysis_report":
                    self.backend.temp_status_text = None # Xóa trạng thái thu thập
                    self.update_gnss_tab(item)
                    # Nếu là sự kiện khẩn cấp, kích hoạt cảnh báo
                    if item.get("event_confirmed"):
                        self.backend.alert_manager.trigger_critical_event_alarm()
            
            elif data_type == "overview":
                self.update_overview_tab(item)
            
            elif data_type == "gnss_record": # Dành cho việc tải lại session
                self.sheet_gnss.insert_row(item)

        self.update_status_label()
        if self.chart_window and self.chart_window.winfo_exists():
            self.chart_window.update_plot()

        self.root.after(250, self.periodic_update)

    def update_gnss_tab(self, item_data):
        # Cập nhật Bảng điều khiển
        if 'analysis_data' in item_data and item_data['analysis_data']:
            data = item_data['analysis_data']
            h_speed = data.get('horizontal_velocity_mmps', 0)
            v_speed = data.get('vertical_velocity_mps', 0) 
            direction = data.get('direction_degrees', 0)
            accel = data.get('horizontal_acceleration_mmps2', 0)
            displace = data.get('total_displacement_m', 0)

            self.h_speed_var.set(f"{h_speed:.4f} mm/s")
            v_speed_text = f"{abs(v_speed):.4f} mm/s {'(Lún xuống)' if v_speed < 0 else '(Trồi lên)'}"
            self.v_speed_var.set(v_speed_text)
            self.direction_var.set(f"{direction:.2f}°")
            self.acceleration_var.set(f"{accel:.4f} mm/s²")
            self.displacement_var.set(f"{displace:.3f} m")
            self.update_compass_needle(direction)
        
        # Thêm dòng mới vào bảng chi tiết
        ts = datetime.fromtimestamp(item_data.get('timestamp', time.time())).strftime("%H:%M:%S")
        analysis = item_data.get('analysis_data', {})
        classification = item_data.get('classification_name', 'N/A')
        
        gnss_record = [
            ts,
            f"{analysis.get('horizontal_velocity_mmps', 0):.4f}",
            f"{analysis.get('vertical_velocity_mps', 0):.4f}",
            f"{analysis.get('direction_degrees', 0):.2f}",
            f"{analysis.get('horizontal_acceleration_mmps2', 0):.4f}",
            f"{analysis.get('total_displacement_m', 0):.3f}",
            classification
        ]
        self.backend.gnss_analysis_data.append(gnss_record)
        self.sheet_gnss.insert_row(gnss_record)
        
        last_row_index = self.sheet_gnss.get_total_rows() - 1
        if last_row_index >= 0:
            self.sheet_gnss.see(row=last_row_index)
            # Highlight dựa trên phân loại
            if "nhanh" in classification.lower():
                 self.sheet_gnss.highlight_rows([last_row_index], bg="#F8D7DA", fg="black")
            elif "trung bình" in classification.lower() or "chậm" in classification.lower() and "rất" not in classification.lower() :
                 self.sheet_gnss.highlight_rows([last_row_index], bg="#FFF3CD", fg="black")
            else:
                 self.sheet_gnss.highlight_rows([last_row_index], bg="#E9ECEF", fg="black")

    def update_overview_tab(self, record):
        self.sheet_overview.insert_row(record)
        last_row_index = self.sheet_overview.get_total_rows() - 1
        if last_row_index >= 0:
            self.sheet_overview.see(row=last_row_index)
            status = record[2]
            if status == "NGUY HIEM":
                self.sheet_overview.highlight_rows([last_row_index], bg="#F8D7DA", fg="black")
            elif status == "CANH BAO":
                self.sheet_overview.highlight_rows([last_row_index], bg="#FFF3CD", fg="black")
            else:
                self.sheet_overview.highlight_rows([last_row_index], bg="#D4EDDA", fg="black")

    def save_overview_to_csv(self):
        self._save_data_to_csv(list(self.backend.overview_data), ["Tên", "Giá trị", "Trạng thái", "Thời gian"])

    def save_gnss_to_csv(self):
        headers = ["Thời gian", "Tốc độ ngang (mm/s)", "Tốc độ đứng (mm/s)", "Hướng (°)", "Gia tốc ngang (mm/s²)", "Tổng dịch chuyển (m)", "Phân loại"]
        self._save_data_to_csv(list(self.backend.gnss_analysis_data), headers)

    def _save_data_to_csv(self, data_to_save, headers):
        if not data_to_save:
            messagebox.showinfo("Thông báo", "Không có dữ liệu để lưu.", parent=self.root)
            return
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")], title="Lưu file CSV", parent=self.root)
        if not path: return
        
        threading.Thread(target=self._write_csv_in_background, args=(path, data_to_save, headers), daemon=True).start()

    def _write_csv_in_background(self, path, data_to_save, headers):
        try:
            import csv
            with open(path, "w", newline="", encoding='utf-8-sig') as f:
                writer = csv.writer(f)
                writer.writerow(headers)
                writer.writerows(data_to_save)
            if self.root.winfo_exists(): self.root.after(0, lambda: messagebox.showinfo("Thành công", f"Đã lưu dữ liệu vào {os.path.basename(path)}", parent=self.root))
        except Exception as e:
            if self.root.winfo_exists(): self.root.after(0, lambda: messagebox.showerror("Lỗi", f"Không thể lưu file:\n\n{e}", parent=self.root))

    def clear_all_gui_data(self):
        if messagebox.askokcancel("Xác nhận", "Bạn có chắc muốn xóa toàn bộ dữ liệu trên giao diện và trong bộ nhớ?", parent=self.root):
            self.backend.clear_all_data()

    # ... (Các hàm còn lại như on_close_window, exit_program_graceful, ... giữ nguyên)
    def on_close_window(self):
        logger.info("Đã đóng cửa sổ giao diện. Gõ 'show' trong terminal để mở lại.")
        self.on_close_callback()
        self.destroy_all_windows()
    def exit_program_graceful(self):
        if messagebox.askokcancel("Xác nhận", "Bạn có chắc muốn thoát hoàn toàn chương trình?", parent=self.root):
            logger.info("Tự động lưu cấu hình hiện tại trước khi thoát...")
            self.apply_and_save_config(show_message=False)
            self.on_close_callback(shutdown=True)
    def destroy_all_windows(self):
        if self.settings_window and self.settings_window.winfo_exists(): self.settings_window.destroy()
        if self.chart_window and self.chart_window.winfo_exists(): self.chart_window.destroy()
        if self.classification_win and self.classification_win.winfo_exists(): self.classification_win.destroy()
        if self.root and self.root.winfo_exists(): self.root.destroy()
    def load_initial_data(self):
        self.broker_entry.insert(0, self.backend.broker)
        self.port_entry.insert(0, str(self.backend.port))
        self.user_entry.insert(0, self.backend.username)
        self.pass_entry.insert(0, self.backend.password)
        self.pub_entry.insert(0, self.backend.publish_topic)
        self.water_topic_entry.insert("1.0", "\n".join(self.backend.water_topics))
        self.gnss_topic_entry.insert("1.0", "\n".join(self.backend.gnss_topics))
        self.warning_threshold_var.set(str(self.backend.warning_threshold))
        self.critical_threshold_var.set(str(self.backend.critical_threshold))
        self.sounds_dir_var.set(self.backend.sounds_dir)
    def _validate_config(self, settings):
        errors = []
        if not settings.get('broker'): errors.append("MQTT Broker không được để trống")
        try:
            port = int(settings.get('port', 0))
            if not (1 <= port <= 65535): errors.append("Port phải là một số từ 1-65535")
        except (ValueError, TypeError): errors.append("Port phải là một số nguyên")
        try:
            warning = float(settings.get('warning_threshold', 0))
            critical = float(settings.get('critical_threshold', 0))
            if critical <= warning: errors.append("Ngưỡng nguy hiểm phải lớn hơn ngưỡng cảnh báo")
        except (ValueError, TypeError): errors.append("Các giá trị ngưỡng phải là số")
        sounds_dir = settings.get('sounds_dir')
        if not sounds_dir or not os.path.isdir(sounds_dir): errors.append(f"Đường dẫn thư mục âm thanh không hợp lệ:\n{sounds_dir}")
        return errors
    def apply_and_save_config(self, show_message=True, parent_window=None):
        if parent_window is None: parent_window = self.root
        settings = {'broker': self.broker_entry.get(), 'port': self.port_entry.get(), 'username': self.user_entry.get(), 'password': self.pass_entry.get(),
            'water_topics': self.water_topic_entry.get("1.0", "end-1c").strip(), 'gnss_topics': self.gnss_topic_entry.get("1.0", "end-1c").strip(),
            'publish': self.pub_entry.get(), 'warning_threshold': self.warning_threshold_var.get(), 'critical_threshold': self.critical_threshold_var.get(),
            'sounds_dir': self.sounds_dir_var.get()}
        errors = self._validate_config(settings)
        if errors:
            messagebox.showerror("Lỗi Cấu hình", "\n".join(errors), parent=parent_window)
            return False
        try:
            self.backend.update_and_reconnect(settings)
            if show_message: messagebox.showinfo("Thành công", "Đã lưu và áp dụng cấu hình.", parent=parent_window)
            return True
        except Exception as e:
            messagebox.showerror("Lỗi", f"Không thể áp dụng cấu hình: {e}", parent=parent_window)
            return False
    def update_status_label(self):
        if self.backend.temp_status_text:
            text_to_show = self.backend.temp_status_text
            color_to_show = "blue" if "Đang thu thập" in self.backend.temp_status_text else "red"
        else:
            text_to_show = self.backend.status_text
            color_to_show = self.backend.status_color
        if self.status_label.cget("text") != text_to_show or self.status_label.cget("foreground") != color_to_show:
            self.status_label.config(text=text_to_show, foreground=color_to_show)
    def toggle_pass(self): self.pass_entry.config(show="" if self.pass_entry.cget("show") else "*")
    def on_test_siren_click(self):
        if not self.backend.test_siren_relay(): messagebox.showwarning("Cảnh báo", "Chỉ có thể kiểm tra còi ở chế độ THỦ CÔNG (OFF).", parent=self.root)
    def select_sounds_directory(self):
        initial_dir = os.path.dirname(self.sounds_dir_var.get())
        if not os.path.isdir(initial_dir): initial_dir = os.path.dirname(os.path.abspath(__file__))
        directory = filedialog.askdirectory(title="Chọn Thư mục chứa File Âm thanh", initialdir=initial_dir, parent=self.settings_window)
        if directory: self.sounds_dir_var.set(directory)
    def select_test_sound_file(self):
        filepath = filedialog.askopenfilename(
            parent=self.settings_window,
            title="Chọn file âm thanh để kiểm tra",
            initialdir=self.backend.sounds_dir,
            filetypes=[("Sound Files", "*.mp3 *.wav"), ("All files", "*.*")]
        )
        if filepath:
            self.test_sound_path_var.set(filepath)
    def play_test_sound(self):
        filepath = self.test_sound_path_var.get()
        if not filepath:
            messagebox.showwarning("Chưa chọn file", "Vui lòng chọn một file âm thanh để phát.", parent=self.settings_window)
            return
        result = self.backend.test_specific_sound(filepath)
        if result == "OK":
            messagebox.showinfo("Đang phát", f"Đang gửi lệnh phát file:\n{os.path.basename(filepath)}", parent=self.settings_window)
        elif result == "File not found":
             messagebox.showerror("Lỗi", "Không tìm thấy file âm thanh. Vui lòng chọn lại.", parent=self.settings_window)
        else:
             messagebox.showerror("Lỗi", "Hệ thống âm thanh (mixer) chưa sẵn sàng hoặc không phải môi trường Pi.", parent=self.settings_window)
    def open_settings_window(self):
        if self.settings_window and self.settings_window.winfo_exists():
            self.settings_window.lift()
            return
        self.settings_window = Toplevel(self.root)
        self.settings_window.title("Cài đặt Nâng cao")
        self.settings_window.geometry("800x600")
        self.settings_window.transient(self.root)
        notebook = ttk.Notebook(self.settings_window)
        notebook.pack(pady=10, padx=10, fill="both", expand=True)
        general_frame = ttk.Frame(notebook, padding="10")
        notebook.add(general_frame, text='Chung')
        sounds_path_frame = ttk.LabelFrame(general_frame, text="Đường dẫn", padding=10)
        sounds_path_frame.pack(fill="x", expand=True)
        ttk.Label(sounds_path_frame, text="Thư mục Âm thanh Cảnh báo:").grid(row=0, column=0, sticky="w", pady=5, padx=5)
        sounds_entry = ttk.Entry(sounds_path_frame, textvariable=self.sounds_dir_var, state="readonly")
        sounds_entry.grid(row=1, column=0, sticky="ew", pady=5, padx=5)
        ttk.Button(sounds_path_frame, text="Chọn Thư mục...", command=self.select_sounds_directory).grid(row=1, column=1, sticky="w", pady=5, padx=(5,0))
        sounds_path_frame.grid_columnconfigure(0, weight=1)
        test_sound_frame = ttk.LabelFrame(general_frame, text="Kiểm tra Loa/Còi thủ công", padding=10)
        test_sound_frame.pack(fill="x", expand=True, pady=(10, 0))
        ttk.Label(test_sound_frame, text="File âm thanh kiểm tra:").grid(row=0, column=0, columnspan=3, sticky="w", padx=5)
        test_sound_entry = ttk.Entry(test_sound_frame, textvariable=self.test_sound_path_var, state="readonly")
        test_sound_entry.grid(row=1, column=0, sticky="ew", pady=5, padx=5)
        ttk.Button(test_sound_frame, text="Chọn File...", command=self.select_test_sound_file).grid(row=1, column=1, sticky="w", pady=5, padx=(0,5))
        ttk.Button(test_sound_frame, text="Phát Âm thanh", command=self.play_test_sound, bootstyle="success").grid(row=1, column=2, sticky="w", pady=5, padx=5)
        test_sound_frame.grid_columnconfigure(0, weight=1)
        gnss_frame = ttk.Frame(notebook, padding="10")
        notebook.add(gnss_frame, text='GNSS')
        ttk.Button(gnss_frame, text="Phân loại Tốc độ Dịch chuyển...", command=self.open_classification_window, bootstyle="info").pack(pady=(5, 10))
        water_level_frame = ttk.Frame(notebook, padding="10")
        notebook.add(water_level_frame, text='Mực nước')
        add_labeled_entry_settings = lambda frame, label, row, textvariable: (ttk.Label(frame, text=label).grid(row=row, column=0, sticky="w", pady=5, padx=5), ttk.Entry(frame, textvariable=textvariable).grid(row=row, column=1, sticky="ew", pady=5, padx=5), frame.grid_columnconfigure(1, weight=1))
        add_labeled_entry_settings(water_level_frame, "Ngưỡng Cảnh Báo (m):", 0, self.warning_threshold_var)
        add_labeled_entry_settings(water_level_frame, "Ngưỡng Nguy Hiểm (m):", 1, self.critical_threshold_var)
        ttk.Button(self.settings_window, text="Lưu & Đóng", command=self.save_and_close_settings, bootstyle="success").pack(pady=10)
    def open_classification_window(self):
        if self.classification_win and self.classification_win.winfo_exists():
            self.classification_win.lift()
            return
        self.classification_win = Toplevel(self.settings_window)
        self.classification_win.title("Bảng Phân Loại Tốc Độ Dịch Chuyển")
        self.classification_win.geometry("850x420")
        self.classification_win.transient(self.settings_window)
        self.classification_win.grab_set()
        main_frame = ttk.Frame(self.classification_win, padding=10)
        main_frame.pack(fill="both", expand=True)
        classification_frame = ttk.LabelFrame(main_frame, text="Bảng phân loại (Cruden & Varnes, 1996)", padding="10")
        classification_frame.pack(fill="both", expand=True, pady=(0, 10))
        columns = ("Phân loại", "m/năm", "m/tháng", "m/ngày", "m/giờ", "m/phút", "m/giây", "mm/giây")
        self.gnss_tree = ttk.Treeview(classification_frame, columns=columns, show="headings", height=10)
        for col in columns:
            self.gnss_tree.heading(col, text=col)
            self.gnss_tree.column(col, width=90, anchor="center")
        tree_scrollbar = ttk.Scrollbar(classification_frame, orient="vertical", command=self.gnss_tree.yview)
        self.gnss_tree.configure(yscrollcommand=tree_scrollbar.set)
        self.gnss_tree.pack(side="left", fill="both", expand=True)
        tree_scrollbar.pack(side="right", fill="y")
        self.load_gnss_classification_data()
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill="x", pady=(10, 0))
        ttk.Button(control_frame, text="Chỉnh sửa", command=self.edit_gnss_classification).pack(side="left", padx=(0, 5))
        ttk.Button(control_frame, text="Thêm mới", command=self.add_gnss_classification).pack(side="left", padx=5)
        ttk.Button(control_frame, text="Xóa", command=self.delete_gnss_classification).pack(side="left", padx=5)
        ttk.Button(control_frame, text="Khôi phục mặc định", command=self.reset_gnss_classification, bootstyle="danger").pack(side="left", padx=5)
    def save_and_close_settings(self):
        if self.apply_and_save_config(show_message=False, parent_window=self.settings_window):
            messagebox.showinfo("Thành công", "Đã lưu tất cả cài đặt.", parent=self.settings_window)
            self.settings_window.destroy()
    def load_gnss_classification_data(self):
        for item in self.gnss_tree.get_children(): self.gnss_tree.delete(item)
        for i, classification in enumerate(self.backend.gnss_speed_classification):
            values = (classification.get("name", ""), classification.get("m_nam", ""), classification.get("m_thang", ""), classification.get("m_ngay", ""),
                classification.get("m_gio", ""), classification.get("m_phut", ""), classification.get("m_giay", ""), classification.get("mm_giay", ""))
            self.gnss_tree.insert("", "end", values=values, tags=(str(i),))
    def edit_gnss_classification(self):
        selected = self.gnss_tree.selection()
        if not selected:
            messagebox.showwarning("Cảnh báo", "Vui lòng chọn một mục để chỉnh sửa.", parent=self.classification_win)
            return
        self.open_classification_editor(int(self.gnss_tree.item(selected[0])["tags"][0]))
    def add_gnss_classification(self):
        self.backend.gnss_speed_classification.append({"name": "Mới", "mm_giay": "0"})
        self.load_gnss_classification_data()
        self.backend.save_config()
    def delete_gnss_classification(self):
        selected = self.gnss_tree.selection()
        if not selected:
            messagebox.showwarning("Cảnh báo", "Vui lòng chọn một mục để xóa.", parent=self.classification_win)
            return
        if messagebox.askyesno("Xác nhận", "Bạn có chắc muốn xóa mục này?", parent=self.classification_win):
            del self.backend.gnss_speed_classification[int(self.gnss_tree.item(selected[0])["tags"][0])]
            self.load_gnss_classification_data()
            self.backend.save_config()
    def reset_gnss_classification(self):
        if messagebox.askyesno("Xác nhận", "Bạn có chắc muốn khôi phục bảng về giá trị mặc định theo tiêu chuẩn Cruden & Varnes (1996)?", parent=self.classification_win):
            self.backend._reset_gnss_to_default()
            self.load_gnss_classification_data()
            self.backend.save_config()
    def open_classification_editor(self, index):
        editor_window = Toplevel(self.classification_win)
        editor_window.title("Chỉnh sửa phân loại tốc độ")
        editor_window.geometry("400x380")
        editor_window.transient(self.classification_win)
        editor_window.grab_set()
        classification = self.backend.gnss_speed_classification[index]
        vars_dict = {}
        fields = [("Tên phân loại:", "name"), ("m/năm:", "m_nam"), ("m/tháng:", "m_thang"), ("m/ngày:", "m_ngay"), ("m/giờ:", "m_gio"), ("m/phút:", "m_phut"), ("m/giây:", "m_giay"), ("mm/giây:", "mm_giay")]
        main_frame = ttk.Frame(editor_window, padding="10")
        main_frame.pack(fill="both", expand=True)
        for i, (label, key) in enumerate(fields):
            vars_dict[key] = tk.StringVar(value=str(classification.get(key, '')))
            ttk.Label(main_frame, text=label).grid(row=i, column=0, sticky="w", pady=5, padx=5)
            entry = ttk.Entry(main_frame, textvariable=vars_dict[key])
            entry.grid(row=i, column=1, sticky="ew", pady=5, padx=5)
            main_frame.grid_columnconfigure(1, weight=1)
        button_frame = ttk.Frame(editor_window)
        button_frame.pack(fill="x", pady=10)
        def save_changes():
            for key, var in vars_dict.items(): classification[key] = var.get().strip()
            self.load_gnss_classification_data()
            self.backend.save_config()
            editor_window.destroy()
        ttk.Button(button_frame, text="Lưu", command=save_changes).pack(side="left", padx=10, expand=True, fill='x')
        ttk.Button(button_frame, text="Hủy", command=editor_window.destroy).pack(side="right", padx=10, expand=True, fill='x')
    def show_chart_window(self):
        if self.chart_window and self.chart_window.winfo_exists():
            self.chart_window.lift()
            return
        self.chart_window = Toplevel(self.root)
        self.chart_window.title("Biểu đồ Dữ liệu Cảm biến")
        self.chart_window.geometry("900x650")
        self.chart_window.protocol("WM_DELETE_WINDOW", self.on_chart_close)
        self.current_start_index, self._is_updating_slider, self._slider_after_id = 0, False, None
        self.points_per_view = Constants.CHART_POINTS_PER_VIEW
        top_frame = ttk.Frame(self.chart_window, padding=(10, 5))
        top_frame.pack(side=tk.TOP, fill=tk.X)
        ttk.Label(top_frame, text="Chọn đơn vị:").pack(side=tk.LEFT, padx=(0, 5))
        self.unit_selector = ttk.Combobox(top_frame, state="readonly", values=list(self.CONVERSION_FACTORS.keys()))
        self.unit_selector.set("m")
        self.unit_selector.pack(side=tk.LEFT, padx=5)
        self.unit_selector.bind("<<ComboboxSelected>>", lambda e: self.update_plot())
        self.auto_follow_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(top_frame, text="Tự động theo dõi", variable=self.auto_follow_var, command=self.on_auto_follow_toggle).pack(side=tk.LEFT, padx=20)
        chart_frame = ttk.Frame(self.chart_window, padding=(10, 5))
        chart_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.fig = Figure(figsize=(9, 4.5), dpi=100)
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=chart_frame)
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        slider_frame = ttk.Frame(self.chart_window, padding=10)
        slider_frame.pack(side=tk.BOTTOM, fill=tk.X)
        self.position_var = tk.DoubleVar()
        self.position_scale = ttk.Scale(slider_frame, from_=0, to=100, orient=tk.HORIZONTAL, variable=self.position_var, command=self.on_slider_change)
        self.position_scale.pack(side=tk.TOP, fill=tk.X, expand=True)
        self.info_label = ttk.Label(slider_frame, text="Tổng điểm: 0 | Hiển thị: 0-0", font=("Arial", 9))
        self.info_label.pack(side=tk.TOP, pady=(5, 0))
        self.update_plot()
    def clear_chart_data(self):
        self.current_start_index = 0
        self.auto_follow_var.set(True)
        self.update_plot()
    def update_plot(self):
        if not (self.chart_window and self.chart_window.winfo_exists()): return
        all_data = list(self.backend.plot_data_points)
        total_points = len(all_data)
        start, end = self._update_slider_and_indices(total_points)
        self.ax.clear()
        if not all_data[start:end]:
            self._setup_plot_style()
            self.ax.text(0.5, 0.5, 'Chưa có dữ liệu', ha='center', va='center', transform=self.ax.transAxes, fontsize=16, color='gray')
            self.info_label.config(text="Tổng điểm: 0 | Hiển thị: 0-0")
        else:
            indices, values, times, unit, warn_thresh, crit_thresh = self._prepare_plot_data(all_data[start:end], start)
            self._setup_plot_style(unit)
            self._draw_plot_elements(indices, values, warn_thresh, crit_thresh)
            self._configure_plot_axes(start, end, total_points, indices, times)
        self.canvas.draw()
    def _update_slider_and_indices(self, total_points):
        max_start_idx = max(0, total_points - self.points_per_view)
        if total_points <= self.points_per_view:
            self.position_scale.config(state="disabled")
            self.current_start_index = 0
        else:
            self.position_scale.config(state="normal")
            if self.auto_follow_var.get():
                self.current_start_index = max_start_idx
            else:
                self.current_start_index = min(self.current_start_index, max_start_idx)
        self._is_updating_slider = True
        self.position_var.set((self.current_start_index / max_start_idx) * 100 if max_start_idx > 0 else 100)
        self._is_updating_slider = False
        return self.current_start_index, min(total_points, self.current_start_index + self.points_per_view)
    def _prepare_plot_data(self, data_slice, start_index):
        unit = self.unit_selector.get()
        conversion_factor = self.CONVERSION_FACTORS.get(unit, 1.0)
        return (range(start_index, start_index + len(data_slice)),
                [i[1] * conversion_factor for i in data_slice],
                [i[0] for i in data_slice],
                unit,
                self.backend.warning_threshold * conversion_factor,
                self.backend.critical_threshold * conversion_factor)
    def _setup_plot_style(self, unit='Giá trị'):
        self.ax.set_title('Dữ liệu Cảm biến Theo Thời Gian', fontsize=14, fontweight='bold')
        self.ax.set_xlabel('Thời gian', fontsize=12)
        self.ax.set_ylabel(f'Giá trị ({unit})', fontsize=12)
        self.ax.grid(True, which='major', linestyle='--', alpha=0.6)
    def _draw_plot_elements(self, indices, values, warning_thresh, critical_thresh):
        self.ax.plot(indices, values, color='gray', linestyle='-', linewidth=1, alpha=0.5, zorder=3)
        colors = ['green' if v < warning_thresh else 'orange' if v < critical_thresh else 'red' for v in values]
        self.ax.scatter(indices, values, c=colors, s=30, zorder=5)
        self.ax.axhline(y=warning_thresh, color='gold', linestyle='--', linewidth=2, label=f'Ngưỡng Cảnh báo ({warning_thresh:.2f} {self.unit_selector.get()})')
        self.ax.axhline(y=critical_thresh, color='darkorange', linestyle='--', linewidth=2, label=f'Ngưỡng Nguy hiểm ({critical_thresh:.2f} {self.unit_selector.get()})')
    def _configure_plot_axes(self, start, end, total_points, indices, times):
        self.ax.set_xlim(left=start - 0.5, right=start + self.points_per_view - 0.5)
        num_ticks = min(len(indices), 8)
        if num_ticks > 1:
            tick_indices = np.linspace(0, len(indices) - 1, num_ticks, dtype=int)
            self.ax.set_xticks([indices[i] for i in tick_indices])
            self.ax.set_xticklabels([times[i].strftime('%H:%M:%S') for i in tick_indices], rotation=25, ha='right')
        elif indices:
            self.ax.set_xticks(indices)
            self.ax.set_xticklabels([t.strftime('%H:%M:%S') for t in times])
        self.ax.legend()
        self.info_label.config(text=f"Tổng điểm: {total_points} | Hiển thị: {start+1}-{end}")
        self.fig.tight_layout()
    def on_auto_follow_toggle(self):
        if self.auto_follow_var.get(): self.update_plot()
    def on_slider_change(self, value_str):
        if self._is_updating_slider: return
        if self._slider_after_id: self.root.after_cancel(self._slider_after_id)
        self._slider_after_id = self.root.after(100, lambda: self._perform_slider_update(float(value_str)))
    def _perform_slider_update(self, value):
        self._slider_after_id = None
        self.auto_follow_var.set(False)
        total_points = len(self.backend.plot_data_points)
        if total_points > self.points_per_view:
            self.current_start_index = int((value / 100) * (total_points - self.points_per_view))
            self.update_plot()
    def on_chart_close(self):
        if self._slider_after_id: self.root.after_cancel(self._slider_after_id)
        plt.close(self.fig)
        self.chart_window.destroy()
        self.chart_window = None

# ===========================
# KHỐI ĐIỀU KHIỂN CHÍNH
# ===========================
class MainController:
    # ... (Không có thay đổi trong lớp này) ...
    def __init__(self, backend, command_queue):
        self.backend = backend
        self.command_queue = command_queue
        self.app_instance = None
        self.root = ttk.Window()
        self.root.withdraw()
    def run(self):
        self.check_for_commands()
        self.root.mainloop()
    def check_for_commands(self):
        try:
            command = self.command_queue.get_nowait()
            if command == 'show': self.create_gui_window()
            elif command == 'exit': self.handle_shutdown()
        except queue.Empty: pass
        finally:
            if not self.backend.exiting and self.root.winfo_exists():
                self.root.after(100, self.check_for_commands)
    def create_gui_window(self):
        if self.app_instance and self.app_instance.root.winfo_exists():
            logger.info("Giao diện đã đang chạy.")
            self.app_instance.root.lift()
            return
        logger.info("Đang khởi động giao diện người dùng...")
        toplevel_window = Toplevel(self.root)
        self.app_instance = AppGUI(toplevel_window, self.backend, self.on_gui_close)
    def on_gui_close(self, shutdown=False): 
        self.app_instance = None
        if shutdown: self.command_queue.put('exit')
    def handle_shutdown(self):
        logger.info("Nhận lệnh thoát...")
        if self.app_instance: self.app_instance.destroy_all_windows()
        self.backend.cleanup_on_exit()
        if self.root.winfo_exists(): self.root.destroy()

command_queue = queue.Queue()
def console_input_listener(cmd_queue: queue.Queue):
    while True:
        try:
            command = input().strip().lower()
            if command: cmd_queue.put(command)
            if command in ['exit', 'restart']: break
        except (EOFError, KeyboardInterrupt):
            cmd_queue.put('exit')
            break
def signal_handler(signum, frame):
    logger.info("\nNhận tín hiệu ngắt (Ctrl+C), đang thoát...")
    command_queue.put('exit')

if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal_handler)
    backend_instance = Backend()
    backend_instance.start_background_tasks()
    console_thread = threading.Thread(target=console_input_listener, args=(command_queue,), daemon=True)
    console_thread.start()
    logger.info("="*50)
    logger.info("Chương trình đã sẵn sàng.")
    logger.info("Gõ 'show' để mở giao diện, 'exit' để thoát.")
    logger.info("="*50)
    main_controller = MainController(backend_instance, command_queue)
    if len(sys.argv) == 1 or 'show' in sys.argv:
        command_queue.put('show')
    main_controller.run()
    logger.info("Chương trình đã kết thúc.")
